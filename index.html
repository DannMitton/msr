<!DOCTYPE html>
<html lang="en">
<!--
================================================================================
MY SUNG RUSSIAN (MSR) - IPA Transcription Tool for Singers
================================================================================
Version: 4.16
Last Updated: 2026-01-13
Developer: Dann Mitton
Assistant: Claude (Anthropic)

CHANGES IN 4.16:
- Syllable Lock feature: click üîí to prevent vowel reduction on any syllable
- Locked syllables retain full vowel quality even when unstressed
- Visual feedback: üîí (faded) = unlocked, üîì (solid) = locked
- Added lockedSyllables parameter to transcribeSyllable() function
- Updated 5 vowel reduction branches (–∞, –æ, –µ, —è, —ç) to respect locks
- New functions: toggleLock(), retranscribeSyllablesWithLock()

CHANGES IN 4.15:
- Wiktionary Harvest System: automatically collects verified stress data
- Harvested words stored in localStorage, persist across sessions
- Only harvests words NOT already in Vuizur dictionary (no duplicates)
- Console API: MSR.harvest.stats(), .export(), .download(), .data()
- Tracks word frequency (count) and timestamps for corpus analysis
- Foundation for growing art-song-specific vocabulary over time
- Developer mode: triple-click version number to unlock harvest indicator
- Harvest indicator (üåæ + count) shows next to version when unlocked
- One-click download from indicator (no confirmation dialogs)

CHANGES IN 4.14:
- Code cleanup: removed 957 lines of dead code
- Removed GRAYSON_RULES object (722 lines) - replaced by generateCuratedExplanations()
- Removed old rule-lookup functions (ruleMatchScore, findApplicableRules, etc.)
- Removed moveCharLeft/moveCharRight - replaced by drag-and-drop IPA editor
- Removed renderStressEditor/toggleWordEditor/setStressFromSingersView - unused
- Fixed Wiktionary modal visibility (now uses .show class)
- Fixed click handler on stress-unverified icon (pointer-events on pseudo-elements)

CHANGES IN 4.13:
- Fixed word card tiling/spacing issue
- Removed .word-card-sizer element (visibility:hidden still took up layout space)
- Removed duplicate .stress-indicator CSS rule
- Cards now tile contiguously with consistent 10px gaps

CHANGES IN 4.12:
- User Profile modal (gear icon) with country/jurisdiction setting
- Copyright terms adjust by country (CA/EU: life+70, USA: complex, MX: life+100)
- Profile persists in localStorage across sessions
- Continuation headers for page 2+: "Title, cont'd" left, "Poet / Composer" right
- Compact continuation header with smaller font, same divider line
- isPublicDomain() now uses user's jurisdiction for accurate PD calculation

CHANGES IN 4.11:
- Predictive autocomplete for Poet and Composer fields
- 50+ composers and 45+ poets with Cyrillic+Latin search aliases
- Type "—á–∞–π–∫" or "tchai" or "chai" ‚Üí finds Tchaikovsky
- Public domain indicators: ‚úì (life+70) vs ¬© (potentially copyrighted)
- Dates auto-populate from database selection
- Canonical spelling enforced (MSR controls output format)
- Keyboard navigation: ‚Üë/‚Üì to select, Enter to confirm, Esc to close
- Freeform entry still allowed for unlisted names

CHANGES IN 4.10:
- Metadata input panel for Singer's View
- Required fields: Title, Poet, Composer
- Optional fields: Opus/Catalogue, Page Size (Letter/A4)
- Panel collapses after completion, shows summary
- Validation highlights missing required fields
- Mobile-friendly: 44px touch targets, stacks on narrow screens
- Canvas re-renders on metadata changes

CHANGES IN 4.9:
- Full-page PDF template (Letter 8.5x11 or A4)
- Proper header zone: Title, Poet (dates), Composer (dates), Opus
- Proper footer zone: Attribution, copyright disclaimer, page numbers
- Document metadata structure for cataloguing
- Public domain vs copyright-aware disclaimer text
- Pagination support (calculates total pages)
- Dynamic filename from title

CHANGES IN 4.8:
- Singer's View now renders to zoomable canvas viewport
- Pinch-to-zoom and pan support for mobile
- Live document status indicator (Updating.../Ready)
- Document metadata and hash for future cataloguing
- PDF export now uses same canvas (WYSIWYG)
- Zoom controls: +/- buttons and reset
- Removed html2canvas dependency (native canvas rendering)

CHANGES IN 4.7:
- Added Chapter 9 Style Presets system
- Four presets: Sung Russian (Grayson), Modern Standard, Petersburg, Choir
- Style toggles: vowel reduction (ikanye/ekanye/none), —â pronunciation, 
  velar+–∏–π endings, regressive palatalization extent
- Pre-revolutionary orthography normalization (—£‚Üí–µ, —ñ‚Üí–∏, —µ‚Üí–∏, —≥‚Üí—Ñ)
- Style presets UI in Notation Preferences section
- Each preset documented with Grayson page references

CHANGES IN 4.6:
- Added Chapter 8 Sections 2-5 exceptions (deverbal forms, palatalized —Ü, pure exceptions)
- Restored ‚ü®—ë‚ü© in Cyrillic display when stress changes
- Pure exception indicators (‚ö†Ô∏è) with tooltips
- Why screen integration for pure exceptions (Tier 0.5)
- 100+ exception dictionary entries

CHANGES IN 4.2:
- Added Chapter 5 palatalization examples (12 entries including ‚ü®—Ä‚ü© gating contrasts)
- Refined ‚ü®—Ä‚ü© gating rule: stressed front vowel unlocks ‚ü®—Ä‚ü© for regressive palatalization
- Added –≤–µ—Ä–Ω—É—Ç—å, —á–µ—Ä–Ω–∏–∫–∞ as contrast examples (unstressed = —Ä stays hard)
- Fixed —Ä palatalization logic for stressed front vowel gating
- Total exception dictionary: 250 entries
- Created GRAYSON_CH5_PALATALIZATION_RULES.js for Why screen citations

CHANGES IN 4.1:
- Added 25 Grayson verified examples (rule demonstrations)
- Total exception dictionary: 238 entries
- 100% test suite pass rate

CHANGES IN 4.0:
- Expanded EXCEPTION_WORDS from 75 to 213 entries
- Complete Appendix F integration (154 loan words)
- All hard-–µ, unreduced-–æ, —à—é/–∂—é, and —å–æ exceptions included

CHANGES IN 3.5:
- Added –≥–∫‚Üí/xk/ cluster rule (–º—è–≥–∫–∏–π, –ª—ë–≥–∫–∏–π families) per Grayson p. 240
- Added –≥—á‚Üí/x/ rule (–º—è–≥—á–µ comparatives)
- Expanded EXCEPTION_WORDS from 10 to 75+ entries
- Added Chapter 8.5 common exceptions (—Å—á–∞—Å—Ç—å–µ, —Ü–µ—Ä–∫–æ–≤—å, –∞–Ω–≥–µ–ª, –∞–≥–∞, —Ä—É—Å—Å–∫–∏–π, —Å–µ–π—á–∞—Å, —Ç–∞–Ω—Ü–µ–≤–∞—Ç—å)
- Added Appendix F loan words (–∫–∞—Ñ–µ, —Ç–µ–º–ø, —Ç–µ–Ω–Ω–∏—Å, —Ä–∞–¥–∏–æ, –±—Ä–æ—à—é—Ä–∞, –±–∞—Ç–∞–ª—å–æ–Ω, etc.)
- All exceptions now have Grayson page citations

LICENSE:
- Software: AGPL-3.0
- Educational content: CC BY-NC-SA 4.0
- Stress dictionary: Vuizur (AGPL-3.0, Wiktionary-derived)

AUTHORITATIVE SOURCE:
Craig Grayson, "Russian Lyric Diction: A Practical Guide with Introduction 
and Annotations" (University of Washington, 2012)

================================================================================
ARCHITECTURE OVERVIEW
================================================================================

This is a single-file HTML application with embedded CSS and JavaScript.
Structure:
1. <head> - Fonts, CSS styles
2. <body> - UI structure (header, input, output areas, footer)
3. <script> - All transcription logic and interactivity

KEY CONCEPTS:

1. CLUSTER-FIRST TRANSCRIPTION
   - Special consonant clusters are matched BEFORE character-by-character processing
   - Handles assimilation (—Å–∂‚Üí íÀê), deletion (—Å—Ç–Ω‚Üísn), reflexives (-—Ç—å—Å—è‚ÜítÀês å)
   - Exception words dictionary for cross-syllable patterns (—Å–µ—Ä–¥—Ü–µ, —Å–æ–ª–Ω—Ü–µ)

2. SIBLING VIEW ARCHITECTURE  
   - Workspace (word-cards) and Singer's View (interlinear) are SIBLINGS
   - Both views read from the same processedWords[] array
   - Edit in either view, changes sync to both
   - Neither is "home" ‚Äî user flips freely between them

3. CARD FLIP SYLLABLE BOUNDARY EDITOR
   - Word cards flip (3D CSS transform) to reveal syllable editor on back
   - Users can move consonants across syllable boundaries using ‚Üê ‚Üí buttons
   - Soft/hard signs (—å/—ä) move with their consonants
   - IPA retranscribes automatically after changes

4. NOTATION PREFERENCES
   - Toggle buttons for cosmetic IPA variations
   - ‚ü®—â‚ü©: [ É ≤ É ≤] ‚Üî [ É ≤Àê] (geminate vs length mark)
   - soft ‚ü®–Ω‚ü©: […≤] ‚Üî [n ≤] (palatal nasal vs palatalized n)
   - Stored in notationPrefs object, applied via applyNotationPreferences()

================================================================================
KNOWN ISSUES / TODO
================================================================================

[ ] Vuizur stress dictionary integration (currently placeholder)
[ ] Gloss/translation input in Singer's View (shows "___" placeholder)
[ ] Mobile testing and refinement needed
[ ] Extended repertoire testing (Rachmaninoff, Tchaikovsky)
[ ] Print stylesheet refinement for Singer's View

SYLLABIFICATION:
- Fixed —å/—ä bug (was treating as syllable boundary, now stays with consonant)
- User can manually adjust boundaries via card flip editor
- Open syllable preference for singers (CV.CV pattern)

================================================================================
COLOUR STORY: IMPERIAL PORPHYRY
================================================================================

Background: Deep red porphyry with feldspar inclusions
Primary: #a33d3d (rich red)
Dark: #6e2424, #4a1818
Accent Gold: #d4a820 (toggle alternate, gear icon)
Terracotta: #d4784a (toggle default)
Cream: #fffefb, #faf8f6 (cards, containers)
Border: #c4b5a8, #d4c4b0

================================================================================
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Sung Russian (MSR) - IPA Transcription Tool</title>
    
    <!-- Google Fonts: Noto Sans (UI) + Noto Serif (Cyrillic/IPA) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,400;0,600;0,700;1,400&family=Noto+Serif:ital,wght@0,400;0,600;0,700;1,400&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="css/styles.css">
    
    <!-- External data files -->
    <script src="data/yo-exceptions.js"></script>
    <script src="data/stress-corrections.js"></script>
    <script src="data/exception-words.js"></script>
    
    <!-- jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="header-title">
                    <h1>My Sung Russian <span class="msr-abbrev">(MSR)</span></h1>
                </div>
                <div class="header-actions">
                    <a href="#" class="header-link" onclick="event.preventDefault(); /* TODO: showAbout() */">About</a>
                    <button class="header-gear" onclick="openProfileModal()" title="User Profile">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="header-rule"></div>
        </header>

        <div class="main-content">
            <div class="info-box">
                <h3>How to Use</h3>
                <ol class="instructions">
                    <li>Type or paste your Russian text below.</li>
                    <li>Click a syllable in the resulting word-cards to assign and reassign stress.</li>
                    <li>Use your finished transcription to start singing in Russian. <em>–í–ø–µ—Ä—ë–¥!</em></li>
                </ol>
            </div>

            <div class="input-section">
                <label for="russianInput">Russian Text:</label>
                <div class="textarea-wrapper">
                    <textarea id="russianInput"></textarea>
                    <div class="animated-placeholder" id="animatedPlaceholder">
                        <span class="placeholder-ru">–í–≤–µ–¥–∏—Ç–µ —Ä—É—Å—Å–∫–∏–π —Ç–µ–∫—Å—Ç –∑–¥–µ—Å—å...</span>
                        <span class="placeholder-en">Enter Russian text here...</span>
                    </div>
                </div>
                <div class="input-controls">
                    <button onclick="processText()">Transcribe</button>
                    <button class="secondary-button" onclick="clearAll()">Clear</button>
                    <button class="secondary-button" onclick="runCh6Tests()" style="background:#d4784a;color:white;">Run Ch6 Tests</button>
                </div>
            </div>
            
            <div id="viewToggle" class="view-toggle" style="display: none;">
                <button class="view-tab active" id="workspaceTab" onclick="switchView('workspace')">Workspace</button>
                <button class="view-tab" id="singersTab" onclick="switchView('singers')">Singer's View</button>
            </div>
            
            <div id="workspaceView">
                <div id="output"></div>
            </div>
            
            <div id="singersView" class="singers-view" style="display: none;">
                <!-- Metadata Input Panel -->
                <div class="metadata-panel" id="metadataPanel">
                    <div class="metadata-header" onclick="toggleMetadataPanel()">
                        <span class="metadata-summary" id="metadataSummary">Enter work details</span>
                        <span class="metadata-toggle" id="metadataToggle">‚ñº</span>
                    </div>
                    <div class="metadata-form" id="metadataForm">
                        <div class="metadata-row">
                            <div class="metadata-field full-width">
                                <label for="metaTitle">Title <span class="required">*</span></label>
                                <input type="text" id="metaTitle" placeholder="e.g., –ù–µ –ø–æ–π, –∫—Ä–∞—Å–∞–≤–∏—Ü–∞, –ø—Ä–∏ –º–Ω–µ" 
                                       onchange="updateDocumentMeta()" oninput="updateDocumentMeta()">
                            </div>
                        </div>
                        <div class="metadata-row two-col">
                            <div class="metadata-field">
                                <label for="metaPoet">Poet <span class="required">*</span></label>
                                <div class="autocomplete-wrapper">
                                    <input type="text" id="metaPoet" placeholder="e.g., Pushkin or –ü—É—à–∫–∏–Ω"
                                           oninput="handlePoetInput(this)" 
                                           onkeydown="handleAutocompleteKey(event, 'poet')"
                                           onblur="setTimeout(() => hideAutocomplete('poet'), 200)"
                                           autocomplete="off">
                                    <div class="autocomplete-dropdown" id="poetDropdown"></div>
                                </div>
                            </div>
                            <div class="metadata-field">
                                <label for="metaComposer">Composer <span class="required">*</span></label>
                                <div class="autocomplete-wrapper">
                                    <input type="text" id="metaComposer" placeholder="e.g., Rachmaninoff or –†–∞—Ö–º–∞–Ω–∏–Ω–æ–≤"
                                           oninput="handleComposerInput(this)"
                                           onkeydown="handleAutocompleteKey(event, 'composer')"
                                           onblur="setTimeout(() => hideAutocomplete('composer'), 200)"
                                           autocomplete="off">
                                    <div class="autocomplete-dropdown" id="composerDropdown"></div>
                                </div>
                            </div>
                        </div>
                        <div class="metadata-row two-col">
                            <div class="metadata-field">
                                <label for="metaOpus">Opus / Catalogue</label>
                                <input type="text" id="metaOpus" placeholder="e.g., Op. 4, No. 4"
                                       onchange="updateDocumentMeta()" oninput="updateDocumentMeta()">
                            </div>
                            <div class="metadata-field">
                                <label for="metaPageSize">Page Size</label>
                                <div class="page-size-toggle">
                                    <button type="button" class="size-btn active" id="btnLetter" onclick="setPageSize('letter')">Letter</button>
                                    <button type="button" class="size-btn" id="btnA4" onclick="setPageSize('a4')">A4</button>
                                </div>
                            </div>
                        </div>
                        <div class="metadata-validation" id="metadataValidation"></div>
                    </div>
                </div>
                
                <!-- Zoomable Canvas Viewport -->
                <div class="canvas-viewport" id="canvasViewport">
                    <canvas id="singersCanvas"></canvas>
                </div>
                <!-- Zoom controls -->
                <div class="viewport-controls">
                    <button class="zoom-btn" onclick="zoomCanvas(0.9)" title="Zoom out">‚àí</button>
                    <span class="zoom-level" id="zoomLevel">100%</span>
                    <button class="zoom-btn" onclick="zoomCanvas(1.1)" title="Zoom in">+</button>
                    <button class="zoom-btn reset" onclick="resetCanvasView()" title="Reset view">‚ü≤</button>
                </div>
                <!-- Document status indicator -->
                <div class="document-status" id="documentStatus">
                    <span class="status-dot"></span>
                    <span class="status-text">Live</span>
                </div>
            </div>
            <div id="singersViewControls" class="output-controls" style="display: none;">
                <button onclick="copySingersView()">Copy</button>
                <button onclick="printSingersView()">Print</button>
                <button onclick="exportToPDF()">Export PDF</button>
            </div>
            
            <details class="preferences-panel">
                <summary>Preferences ‚ñæ</summary>
                
                <!-- Style Presets as Radio Buttons -->
                <div class="style-presets-radio">
                    <div class="preset-option">
                        <input type="radio" id="preset-grayson" name="stylePreset" value="sung_russian_grayson" checked onchange="applyStylePreset(this.value)">
                        <label for="preset-grayson" title="Traditional Old Muscovite / Stage pronunciation&#10;‚Ä¢ Ikanye (–µ‚Üí/…™/)&#10;‚Ä¢ Shshokanye (—â‚Üí/ É ≤ É ≤/)&#10;‚Ä¢ Stage endings (-–∫–∏–π‚Üí/k…®j/)&#10;‚Ä¢ Full regressive palatalization">Grayson</label>
                    </div>
                    <div class="preset-option">
                        <input type="radio" id="preset-csr" name="stylePreset" value="modern_standard" onchange="applyStylePreset(this.value)">
                        <label for="preset-csr" title="Contemporary Standard Russian&#10;‚Ä¢ Ikanye (–µ‚Üí/…™/)&#10;‚Ä¢ Shshokanye (—â‚Üí/ É ≤ É ≤/)&#10;‚Ä¢ Modern endings (-–∫–∏–π‚Üí/k ≤ij/)&#10;‚Ä¢ Partial regressive palatalization">CSR</label>
                    </div>
                    <div class="preset-option">
                        <input type="radio" id="preset-petersburg" name="stylePreset" value="petersburg" onchange="applyStylePreset(this.value)">
                        <label for="preset-petersburg" title="Petersburg / Northern tradition&#10;‚Ä¢ Ekanye (–µ‚Üí/…õ/)&#10;‚Ä¢ Shchokanye (—â‚Üí/ É ≤t É ≤/)&#10;‚Ä¢ Modern endings (-–∫–∏–π‚Üí/k ≤ij/)&#10;‚Ä¢ Partial regressive palatalization">Peterburgian</label>
                    </div>
                    <div class="preset-option">
                        <input type="radio" id="preset-choir" name="stylePreset" value="choir" onchange="applyStylePreset(this.value)">
                        <label for="preset-choir" title="Choral (no vowel reduction)&#10;‚Ä¢ No reduction (–µ‚Üí/…õ/, –∞/–æ‚Üí/…ë/)&#10;‚Ä¢ Shshokanye (—â‚Üí/ É ≤ É ≤/)&#10;‚Ä¢ Modern endings&#10;For ensemble vowel matching">Choir</label>
                    </div>
                </div>
                
                <!-- Notation Toggles (cosmetic) - stacked vertically, flush right -->
                <div class="notation-toggles-stack">
                    <div class="notation-toggle-item" onclick="toggleShchaNotation()">
                        <span class="toggle-label-small">‚ü®—â‚ü©</span>
                        <span class="glyph-toggle-small" id="shchaToggle" title="Click to toggle between  É ≤ É ≤ and  É ≤Àê notation"> É ≤ É ≤</span>
                    </div>
                    <div class="notation-toggle-item" onclick="togglePalatalnNotation()">
                        <span class="toggle-label-small">soft ‚ü®–Ω‚ü©</span>
                        <span class="glyph-toggle-small" id="palatalnToggle" title="Click to toggle between …≤ and n ≤ notation">…≤</span>
                    </div>
                </div>
            </details>

            <div id="output"></div>
        </div>

        <footer id="mainFooter" class="collapsed" onclick="toggleFooter()">
            <div class="footer-collapsed-label">
                My Sung Russian (MSR) <span id="versionNumber" onclick="event.stopPropagation()">v4.16</span> ‚Äî tap for credits & license <span class="footer-arrow">‚ñ≤</span>
            </div>
            <div class="footer-main">
            <p>
                <strong>My Sung Russian (MSR)</strong> <span id="versionNumberExpanded" onclick="event.stopPropagation()">v4.16</span>
            </p>
            <p style="margin-top: 8px; font-size: 0.85em; line-height: 1.6;">
                MSR's transcription rules are drawn from Craig Grayson's doctoral dissertation <a href="https://digital.lib.washington.edu/server/api/core/bitstreams/96b596ce-3a65-41c8-a45f-77b2e94ae48a/content" target="_blank" onclick="event.stopPropagation()"><em>Russian Lyric Diction: A Practical Guide with Introduction and Annotations and a Bibliography with Annotations on Selected Sources</em></a> (University of Washington, 2012). Developed and maintained by Dann Mitton (2026). Stress dictionary via <a href="https://github.com/Vuizur/add-stress-to-epub" target="_blank" onclick="event.stopPropagation()">Vuizur</a> (AGPL-3.0).
            </p>
            <p style="margin-top: 10px; font-size: 0.85em; line-height: 1.6;">
                My Sung Russian is noncommercial and is intended for use by singers, teachers, and scholars. This tool is offered freely. Neither it nor its output may be repackaged for sale. Use it generously and improve it. Software licensed under <a href="https://www.gnu.org/licenses/agpl-3.0.en.html" target="_blank" onclick="event.stopPropagation()">AGPL-3.0</a>. Educational content licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" onclick="event.stopPropagation()">CC BY-NC-SA 4.0</a>.
            </p>
            </div>
        </footer>
    </div>
    
    <!-- User Profile Modal -->
    <div class="modal-overlay" id="profileModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>User Profile</h2>
                <button class="modal-close" onclick="closeProfileModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="profile-field">
                    <label for="profileCountry">Country / Jurisdiction</label>
                    <select id="profileCountry" onchange="updateCopyrightPreview()">
                        <option value="">‚Äî Select your country ‚Äî</option>
                        <optgroup label="North America">
                            <option value="CA">Canada</option>
                            <option value="US">United States</option>
                            <option value="MX">Mexico</option>
                        </optgroup>
                        <optgroup label="Europe">
                            <option value="EU">European Union</option>
                            <option value="GB">United Kingdom</option>
                            <option value="RU">Russia</option>
                            <option value="UA">Ukraine</option>
                            <option value="CH">Switzerland</option>
                        </optgroup>
                        <optgroup label="Asia Pacific">
                            <option value="AU">Australia</option>
                            <option value="NZ">New Zealand</option>
                            <option value="JP">Japan</option>
                            <option value="KR">South Korea</option>
                            <option value="CN">China</option>
                        </optgroup>
                        <optgroup label="Other">
                            <option value="OTHER">Other (use life + 70)</option>
                        </optgroup>
                    </select>
                    <div class="field-hint">
                        Copyright terms vary by country. This helps MSR show accurate public domain status for composers and poets.
                    </div>
                    <div class="copyright-preview" id="copyrightPreview">
                        Select a country to see copyright terms.
                    </div>
                </div>
                <div class="profile-field">
                    <label for="profileName">Your Name (optional)</label>
                    <input type="text" id="profileName" placeholder="For PDF attribution">
                    <div class="field-hint">
                        Appears in exported PDFs as "Transcription by [name]"
                    </div>
                </div>
                <div class="profile-field">
                    <label for="profileInstitution">Institution (optional)</label>
                    <input type="text" id="profileInstitution" placeholder="e.g., University of Toronto">
                    <div class="field-hint">
                        Your school, studio, or organization
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeProfileModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="saveUserProfile()">Save Profile</button>
            </div>
        </div>
    </div>
    
    <!-- First-Launch Onboarding Modal -->
    <div class="modal-overlay" id="onboardingModal">
        <div class="modal-content" style="max-width: 420px;">
            <div class="modal-header">
                <h2>Welcome to My Sung Russian</h2>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 16px; color: #444; line-height: 1.5;">
                    MSR helps singers transcribe Russian text into IPA for lyric diction study.
                </p>
                <div class="profile-field">
                    <label for="onboardingName">What name should appear on your transcriptions?</label>
                    <input type="text" id="onboardingName" placeholder="e.g., Dann Mitton" style="font-size: 16px; padding: 12px;">
                    <div class="field-hint">
                        This appears in PDF exports. You can change it anytime in Settings.
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="skipOnboarding()">Skip</button>
                <button class="modal-btn modal-btn-primary" onclick="completeOnboarding()">Continue</button>
            </div>
        </div>
    </div>

    <!-- Stress Source Modal - asks user vs composer -->
    <div class="modal-overlay" id="stressSourceModal">
        <div class="modal-content" style="max-width: 380px;">
            <div class="modal-header">
                <h2>Who assigned this stress?</h2>
                <button class="modal-close" onclick="closeStressSourceModal()">&times;</button>
            </div>
            <div class="modal-body" style="text-align: center; padding: 20px;">
                <p style="margin-bottom: 20px; color: #4a5568;">
                    Moving stress from the dictionary position on <strong id="stressSourceWord"></strong>
                </p>
                <button class="modal-btn" onclick="confirmStressSource('user')" style="width: 100%; margin-bottom: 12px; background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);">
                    üé§ My choice (for learning/practice)
                </button>
                <button class="modal-btn" onclick="confirmStressSource('composer')" style="width: 100%; background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);">
                    üéº Composer's score (published this way)
                </button>
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button class="modal-btn modal-btn-secondary" onclick="closeStressSourceModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // MSR JAVASCRIPT - STRUCTURE OVERVIEW
        // ============================================================================
        // 
        // SECTION 0: GRAYSON RULES KNOWLEDGE BASE (NEW - lines ~1345-2200)
        //            Pedagogical assertions for "Why?" explanations
        //
        // SECTION 1: STRESS DICTIONARY (~47,000 entries, lines ~2200-49200)
        //            Large data block - scroll past to reach logic
        //
        // SECTION 2: GRAYSON IPA INVENTORY (lines ~49230-49340)
        //            Authoritative symbol mappings from dissertation
        //
        // SECTION 3: UTILITY FUNCTIONS (lines ~49340-49450)
        //            Character classification, normalization, notation prefs
        //
        // SECTION 4: SYLLABIFICATION (lines ~49450-49580)
        //            Sonority-based syllable splitting
        //
        // SECTION 5: PHONOLOGICAL ANALYSIS (lines ~49580-49900)
        //            Voicing assimilation, palatalization analysis
        //
        // SECTION 6: SPECIAL CLUSTERS & EXCEPTIONS (lines ~49900-50100)
        //            Grayson Ch. 6 cluster rules, exception words
        //
        // SECTION 7: TRANSCRIPTION ENGINE (lines ~50100-50520)
        //            Core syllable-to-IPA conversion
        //
        // SECTION 8: WORD PROCESSING (lines ~50520-50660)
        //            Orchestrates transcription pipeline
        //
        // SECTION 9: UI RENDERING & INTERACTION (lines ~50660-51100)
        //            DOM manipulation, event handlers, view switching
        //
        // ============================================================================

        // ============================================================================
        // SECTION 1: VUIZUR STRESS DICTIONARY (47,283 entries)
        // ============================================================================
        // Extracted from Wiktionary via Vuizur/add-stress-to-epub
        // Obsolete orthography normalized per Grayson (—≥‚Üí—Ñ, —ñ‚Üí–∏, —£‚Üí–µ, —µ‚Üí–∏)
        // Format: word -> stress position (0-based vowel/syllable index)
        //
        // NOTE: GRAYSON_RULES object and old rule-lookup functions (ruleMatchScore,
        // findApplicableRules, getBestExplanation, getRule, explainHardConsonant)
        // were removed in v4.14. The "Why" feature now uses generateCuratedExplanations().
        // ============================================================================
        
        // ============================================================================
        // CHAPTER 8 EXCEPTION DICTIONARY: Printed ‚ü®–µ‚ü© = Actual ‚ü®—ë‚ü©
        // ============================================================================
        // In standard Russian printing, ‚ü®—ë‚ü© usually appears as ‚ü®–µ‚ü©.
        // These high-frequency words must be recognized and transcribed with /o/ not /…õ/.
        // Source: Grayson Chapter 8, pp. 275-280
        // ============================================================================
        // Data files loaded externally via <script> tags in <head>
        // - –Å_EXCEPTION_DICTIONARY from data/yo-exceptions.js
        // - STRESS_CORRECTIONS from data/stress-corrections.js  
        // - EXCEPTION_WORDS from data/exception-words.js
        // - STRESS_DICTIONARY loaded async from data/vuizur.json
        
        
        // STRESS_DICTIONARY loaded from external file (data/vuizur.json)
        let STRESS_DICTIONARY = {};
        
        
        // ============================================================================
        // STRESS LOOKUP FUNCTIONS
        // ============================================================================
        
        // Manual corrections for known errors in the Vuizur/Wiktionary data
        // These override the dictionary when there are homograph issues or errors
        // Format: word -> correct stress position (0-based syllable index)
        
        // ============================================================================
        // WIKTIONARY HARVEST SYSTEM
        // ============================================================================
        // Collects Wiktionary-verified stress data to grow the dictionary over time.
        // Only harvests words NOT already in Vuizur dictionary.
        // Stored in localStorage, exportable as JSON for dictionary merging.
        //
        // Data structure:
        // {
        //   "word": { stress: 2, timestamp: "2026-01-13T...", count: 3 }
        // }
        // ============================================================================
        
        const HARVEST_STORAGE_KEY = 'msr_wiki_harvest';
        
        // In-memory harvest (loaded from localStorage on init)
        let wikiHarvest = {};
        
        /**
         * Load harvest from localStorage
         */
        function loadHarvest() {
            try {
                const saved = localStorage.getItem(HARVEST_STORAGE_KEY);
                if (saved) {
                    wikiHarvest = JSON.parse(saved);
                    console.log(`[Harvest] Loaded ${Object.keys(wikiHarvest).length} words from localStorage`);
                }
            } catch (e) {
                console.warn('[Harvest] Failed to load from localStorage:', e);
                wikiHarvest = {};
            }
        }
        
        /**
         * Save harvest to localStorage
         */
        function saveHarvest() {
            try {
                localStorage.setItem(HARVEST_STORAGE_KEY, JSON.stringify(wikiHarvest));
            } catch (e) {
                console.warn('[Harvest] Failed to save to localStorage:', e);
            }
        }
        
        /**
         * Add a Wiktionary-verified word to the harvest
         * Only adds if NOT already in Vuizur dictionary
         * @param {string} word - The word (will be normalized)
         * @param {number} stressIndex - 0-based syllable index
         */
        function harvestWord(word, stressIndex) {
            const normalized = word.toLowerCase().replace(/[.,!?;:"""''‚Äû‚Äö¬´¬ª‚Äî‚Äì]/g, '');
            
            // Skip if already in Vuizur dictionary
            if (typeof STRESS_DICTIONARY !== 'undefined' && STRESS_DICTIONARY.hasOwnProperty(normalized)) {
                console.log(`[Harvest] Skipped "${normalized}" ‚Äî already in Vuizur`);
                return false;
            }
            
            // Skip if in manual corrections
            if (STRESS_CORRECTIONS.hasOwnProperty(normalized)) {
                console.log(`[Harvest] Skipped "${normalized}" ‚Äî already in corrections`);
                return false;
            }
            
            // Add or update entry
            if (wikiHarvest[normalized]) {
                wikiHarvest[normalized].count++;
                wikiHarvest[normalized].lastSeen = new Date().toISOString();
                console.log(`[Harvest] Updated "${normalized}" ‚Äî seen ${wikiHarvest[normalized].count} times`);
            } else {
                wikiHarvest[normalized] = {
                    stress: stressIndex,
                    timestamp: new Date().toISOString(),
                    lastSeen: new Date().toISOString(),
                    count: 1
                };
                console.log(`[Harvest] Added "${normalized}" ‚Äî stress on syllable ${stressIndex + 1}`);
            }
            
            saveHarvest();
            return true;
        }
        
        /**
         * Get harvest statistics
         * @returns {object} { total, newest, oldest }
         */
        function getHarvestStats() {
            const words = Object.keys(wikiHarvest);
            if (words.length === 0) {
                return { total: 0, newest: null, oldest: null };
            }
            
            let newest = null, oldest = null;
            for (const word of words) {
                const ts = wikiHarvest[word].timestamp;
                if (!oldest || ts < oldest) oldest = ts;
                if (!newest || ts > newest) newest = ts;
            }
            
            return {
                total: words.length,
                newest: newest ? new Date(newest).toLocaleDateString() : null,
                oldest: oldest ? new Date(oldest).toLocaleDateString() : null
            };
        }
        
        /**
         * Export harvest as JSON (for dictionary merging)
         * Format matches Vuizur: { "word": stressIndex, ... }
         * @returns {string} JSON string
         */
        function exportHarvest() {
            const vuizurFormat = {};
            for (const [word, data] of Object.entries(wikiHarvest)) {
                vuizurFormat[word] = data.stress;
            }
            return JSON.stringify(vuizurFormat, null, 2);
        }
        
        /**
         * Export harvest with full metadata
         * @returns {string} JSON string with timestamps and counts
         */
        function exportHarvestFull() {
            return JSON.stringify(wikiHarvest, null, 2);
        }
        
        /**
         * Download harvest as file
         * @param {boolean} full - Include metadata (true) or Vuizur format (false)
         */
        function downloadHarvest(full = false) {
            const data = full ? exportHarvestFull() : exportHarvest();
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `msr-harvest-${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log(`[Harvest] Downloaded ${Object.keys(wikiHarvest).length} words`);
        }
        
        /**
         * Clear the harvest (use with caution!)
         */
        function clearHarvest() {
            wikiHarvest = {};
            saveHarvest();
            console.log('[Harvest] Cleared all harvested words');
        }
        
        // Expose harvest functions to console for developer access
        window.MSR = window.MSR || {};
        window.MSR.harvest = {
            stats: getHarvestStats,
            export: exportHarvest,
            exportFull: exportHarvestFull,
            download: downloadHarvest,
            clear: clearHarvest,
            data: () => wikiHarvest
        };
        
        /**
         * Look up stress position for a word in the dictionary
         * @param {string} word - Russian word (will be normalized to lowercase)
         * @returns {number} - Syllable index (0-based) or -1 if not found
         */
        function lookupStress(word) {
            // Normalize: lowercase, remove punctuation
            const normalized = word.toLowerCase().replace(/[.,!?;:"""''‚Äû‚Äö¬´¬ª\-‚Äî‚Äì]/g, '');
            
            // Check manual corrections first (highest priority)
            if (STRESS_CORRECTIONS.hasOwnProperty(normalized)) {
                return STRESS_CORRECTIONS[normalized];
            }
            
            // Then check main dictionary
            if (typeof STRESS_DICTIONARY !== 'undefined' && STRESS_DICTIONARY.hasOwnProperty(normalized)) {
                return STRESS_DICTIONARY[normalized];
            }
            
            return -1;
        }
        
        /**
         * Check if a word exists in the stress dictionary
         * @param {string} word - Russian word
         * @returns {boolean}
         */
        function hasStressEntry(word) {
            return lookupStress(word) !== -1;
        }
        
        // ============================================================================
        // GRAYSON'S CANONICAL IPA INVENTORY (2012) - DO NOT MODIFY
        // ============================================================================
        // Source: Craig Grayson, "Russian Lyric Diction" (University of Washington, 2012)
        // This is the AUTHORITATIVE symbol set. Any deviation is INCORRECT.
        //
        // Key page references:
        // - Stressed vowels: Chapter 3, Section 1 (p. 81-96)
        // - Intermediate allophones [a], [e]: Chapter 3, Section 4 (p. 104-107)
        // - Unstressed reduction: Chapter 3, Section 7 (p. 125-127)
        // - Consonants: Chapter 4 (p. 139-192)
        // - Palatalization: Chapter 5 (p. 203+)
        // ============================================================================
        
        const GRAYSON_IPA_INVENTORY = Object.freeze({
            // VOWELS - STRESSED (Grayson Ch. 3, Sec. 1)
            vowels_stressed: {
                '–∞': '…ë',        // Back open (default) - Grayson p. 82
                '–∞_interpalatal': 'a',  // Front open - Grayson p. 104: only interpalatally
                '–æ': 'o',        // Grayson p. 86: "transcribed simply as /o/"
                '–µ': '…õ',        // Open-mid front (default) - Grayson p. 84
                '–µ_interpalatal': 'e',  // Close-mid front - Grayson p. 106
                '—ë': 'o',        // Same as stressed –æ - Grayson p. 85-86
                '–∏': 'i',        // Close front - Grayson p. 96: never reduces
                '—ã': '…®',        // Close central - Grayson p. 89-90
                '—É': 'u',        // Close back rounded - Grayson p. 88
                '—é': 'u',        // Same as stressed —É
                '—è': '…ë',        // Same as stressed –∞ (default)
                '—è_interpalatal': 'a',  // Grayson p. 104: only interpalatally
                '—ç': '…õ'         // Same as stressed –µ - Grayson p. 84
            },
            
            // VOWELS - UNSTRESSED (Grayson Ch. 3, Sec. 7 - Reduction Rules)
            vowels_unstressed: {
                '–∞_pretonic_immediate': '…ë',     // Grayson p. 127: immediate pretonic
                '–∞_remote': ' å',                  // Grayson p. 127: remote positions
                '–∞_interpalatal_remote': '…™',    // Grayson p. 127: ikanye after palatalized
                '–æ_pretonic_immediate': '…ë',     // Grayson p. 127: akanye
                '–æ_remote': ' å',                  // Grayson p. 127: remote positions
                '–µ_unstressed': '…™',              // Ikanye (default)
                '–µ_unstressed_interpalatal': 'i', // Grayson p. 125: fronts to /i/ interpalatally
                '–µ_after_hard': '…®',              // Grayson p. 127: after –∂, —à, —Ü
                '–∏_stressed': 'i',                // Grayson p. 96: never reduces
                '–∏_unstressed': 'i',              // Grayson p. 96: "neither syllabic stress nor position affects the reading as /i/"
                '—ã_unstressed': '…®',              // Grayson p. 89-90
                '—É_unstressed': 'u',              // Grayson: never reduces
                '—é_unstressed': 'u',              // Grayson: never reduces
                '—è_unstressed': '…™',              // Grayson p. 127: ikanye after palatalized
                '—è_unstressed_remote': ' å',       // Grayson p. 127: remote (not interpalatal)
                '—ç_unstressed': '…™'               // Grayson p. 127: ikanye
            },
            
            // CONSONANTS - BASIC (Grayson Ch. 4)
            consonants: {
                '–±': 'b',   '–ø': 'p',
                '–≤': 'v',   '—Ñ': 'f',
                '–¥': 'd',   '—Ç': 't',
                '–≥': '…°',   '–∫': 'k',   // NOTE: …° not g (IPA opentail glyph)
                '–∑': 'z',   '—Å': 's',
                '–∂': ' í',   '—à': ' É',
                '—Ö': 'x',
                '—Ü': 'ts',
                '—á': 't É ≤',             // Grayson p. 169: inherently palatalized
                '—â': ' É ≤ É ≤',            // Grayson p. 171-173: double palatalized fricative (NOT  Ét É)
                '–ª': 'l',   '–ª_hard': '…´',  '–ª_soft': 'l ≤',  // Grayson p. 184
                '–º': 'm',
                '–Ω': 'n',   '–Ω_soft': '…≤',  // Grayson p. 186: palatal nasal (NOT n ≤)
                '—Ä': 'r',
                '–π': 'j'
            },
            
            // SPECIAL MARKERS
            markers: {
                'palatalization': ' ≤',      // Superscript (NOT used for –Ω, which gets …≤ - Grayson p. 183)
                'length': 'Àê',              // Geminate consonants
                'stress': 'Àà',              // Before stressed syllable
                'j_glide': 'j'              // Iotized vowels after vowels
            }
        });
        
        // FORBIDDEN GLYPHS - These must NEVER appear in MSR output
        // Each entry documents why the glyph is forbidden per Grayson
        const FORBIDDEN_IPA_GLYPHS = Object.freeze({
            'g': '…°',      // Typography: Latin g ‚Üí IPA …° (opentail)
            '…ô': ' å',      // Grayson p. 127: "Further reduction to schwa (/…ô/) should 
                           // be avoided, when singing Russian." Use [ å] for remote positions.
            '…ê': '…ë',      // Grayson uses […ë] for pretonic immediate, not near-open […ê]
            'n ≤': '…≤',     // Grayson p. 183: palatalized –Ω ‚Üí […≤] (palatal nasal), not [n ≤]
            '…î': 'o',      // Grayson p. 86: "stressed /o/ will be transcribed simply as /o/"
            ' ä': 'u'       // Grayson inventory: —É/—é never reduce - always [u], never [ ä]
        });
        
        // Debug mode - set to true to enable console logging of validation errors
        const DEBUG = false;
        
        /**
         * Validate IPA output against Grayson's inventory
         * Returns false and logs error (if DEBUG) when forbidden glyph found
         */
        function validateIPAOutput(ipaString) {
            for (const [forbidden, correct] of Object.entries(FORBIDDEN_IPA_GLYPHS)) {
                if (ipaString.includes(forbidden)) {
                    if (DEBUG) {
                        console.error(`FORBIDDEN GLYPH: "${forbidden}" should be "${correct}" in: ${ipaString}`);
                    }
                    return false;
                }
            }
            return true;
        }
        
        // ============================================================================
        // SECTION 3: GLOBAL STATE & UTILITIES
        // ============================================================================
        
        // Global state - array of processed word objects
        let processedWords = [];

        // Character normalization map (Latin/Greek to Cyrillic)
        // Also includes pre-revolutionary orthography (Grayson Ch. 9, p. 291)
        const charMap = {
            // Latin lookalikes
            'A': '–ê', 'a': '–∞', 'B': '–í', 'C': '–°', 'E': '–ï', 'e': '–µ',
            'H': '–ù', 'K': '–ö', 'M': '–ú', 'O': '–û', 'o': '–æ', 'P': '–†',
            'p': '—Ä', 'T': '–¢', 'X': '–•', 'x': '—Ö', 'Y': '–£', 'y': '—É',
            // Greek lookalikes
            'Œ±': '–∞', 'Œ≤': '–≤', 'Œ≥': '–≥', 'Œµ': '–µ', 'Œ∑': '–Ω', 'Œπ': '–∏',
            'Œ∫': '–∫', 'Œº': '–º', 'ŒΩ': '–Ω', 'Œø': '–æ', 'œÅ': '—Ä', 'œÑ': '—Ç',
            'œÖ': '—É', 'œá': '—Ö', 'œâ': '–æ',
            // Pre-revolutionary orthography (Grayson Ch. 9, p. 291)
            // These obsolete letters appear in pre-1918 music publications
            '—£': '–µ', '—¢': '–ï',  // yat ‚Üí –µ
            '—ñ': '–∏', '–Ü': '–ò',  // dotted i ‚Üí –∏
            '—µ': '–∏', '—¥': '–ò',  // izhitsa ‚Üí –∏
            '—≥': '—Ñ', '—≤': '–§'   // fita ‚Üí —Ñ
        };

        // Cyrillic character sets
        const vowels = new Set(['–∞', '–µ', '—ë', '–∏', '–æ', '—É', '—ã', '—ç', '—é', '—è']);
        const consonants = new Set([
            '–±', '–≤', '–≥', '–¥', '–∂', '–∑', '–π', '–∫', '–ª', '–º', '–Ω', '–ø', '—Ä', '—Å', '—Ç', '—Ñ', '—Ö', '—Ü', '—á', '—à', '—â'
        ]);
        const softSign = '—å';
        const hardSign = '—ä';

        // Prepositions and clitics that attach to following words
        // Grayson p. 263: "particles (such as, –±—ã; –∂–µ, –Ω–µ and –Ω–∏)" are unstressed
        // Clitics: words that are inherently unstressed
        // Vowelless ones merge with host word; voweled ones get their own cards but are still unstressed
        const clitics = new Set(['–≤', '–∫', '—Å', '–±', '–≤–æ', '–∫–æ', '—Å–æ', '–æ', '–æ–±', '—É', '–∑–∞', '–Ω–∞', '–ø–æ', '–¥–æ', '–∏–∑', '–æ—Ç', '–ø—Ä–∏', '–ø—Ä–æ', '–∏', '–∞', '–Ω–æ', '–¥–∞', '–ª—å', '–ª–∏', '–∂–µ', '–∂', '–±—ã', '–±', '–Ω–µ', '–Ω–∏']);

        // ============================================================================
        // NOTATION SETTINGS
        // ============================================================================
        // These settings control how IPA is displayed without affecting the
        // underlying transcription (which follows Grayson's conventions).
        // ============================================================================
        
        const notationSettings = {
            // Grayson uses  É ≤ É ≤ for —â; some prefer  É ≤Àê for visual clarity
            // true = use  É ≤Àê (length mark), false = use  É ≤ É ≤ (Grayson default)
            shchaUseLengthMark: false,
            
            // Grayson uses …≤ for palatalized –Ω; some prefer n ≤ for consistency
            // true = use n ≤, false = use …≤ (Grayson default)
            palatalnUseNj: false
        };
        
        // ============================================================================
        // STYLE PRESETS - Chapter 9 Regional/Historical Variations
        // ============================================================================
        // These settings affect actual transcription output (unlike notationSettings
        // which are purely cosmetic). Based on Grayson Ch. 9 (pp. 289-311).
        // ============================================================================
        
        const STYLE_PRESETS = {
            "sung_russian_grayson": {
                id: "sung_russian_grayson",
                label: "Sung Russian (Grayson)",
                description: "Traditional Old Muscovite / Stage pronunciation",
                settings: {
                    vowelReduction: "ikanye",        // –µ‚Üí/…™/, —è‚Üí/…™/ after soft (p. 297)
                    —âPronunciation: "shshokanye",    // —â‚Üí/ É ≤ É ≤/ (p. 299)
                    velar–ò–ô: "stage",                // -–∫–∏–π‚Üí/k…®j/ (p. 301)
                    regressivePalatalization: "full" // Entire cluster (p. 310)
                },
                source: "Grayson (2012) throughout"
            },
            "modern_standard": {
                id: "modern_standard",
                label: "Modern Standard",
                description: "Contemporary educated Moscow speech",
                settings: {
                    vowelReduction: "ikanye",
                    —âPronunciation: "shshokanye",
                    velar–ò–ô: "modern",               // -–∫–∏–π‚Üí/k ≤ij/ (p. 303)
                    regressivePalatalization: "partial"
                },
                source: "Grayson Ch. 9, p. 295"
            },
            "petersburg": {
                id: "petersburg",
                label: "Petersburg Style",
                description: "Northern/academic tradition",
                settings: {
                    vowelReduction: "ekanye",        // –µ‚Üí/…õ/, —è‚Üí/…õ/ after soft (p. 297)
                    —âPronunciation: "shchokanye",    // —â‚Üí/ É ≤t É ≤/ (p. 299-300)
                    velar–ò–ô: "modern",
                    regressivePalatalization: "partial"
                },
                source: "Grayson Ch. 9, p. 300"
            },
            "choir": {
                id: "choir",
                label: "Choral (Simplified)",
                description: "No vowel reduction ‚Äî for ensemble vowel matching",
                settings: {
                    vowelReduction: "none",          // All vowels at full value (p. 308)
                    —âPronunciation: "shshokanye",
                    velar–ò–ô: "modern",
                    regressivePalatalization: "partial"
                },
                source: "Grayson Ch. 9, pp. 306-311",
                notes: [
                    "Unstressed –∞/–æ sung as /…ë/ (no reduction to [ å])",
                    "Unstressed –µ sung as /…õ/ (no reduction to […™])",
                    "—è always /j…ë/ or [ja] before palatalized C",
                    "Exception: -—á–∞–π- in pre-stress still /t Éi-/"
                ]
            }
        };
        
        // Current active style settings (starts with Grayson default)
        let activeStyleSettings = { ...STYLE_PRESETS.sung_russian_grayson.settings };
        let activePresetId = "sung_russian_grayson";
        
        /**
         * Get current style setting value
         */
        function getStyleSetting(key) {
            return activeStyleSettings[key];
        }
        
        /**
         * Apply a preset by ID
         */
        function applyStylePreset(presetId) {
            const preset = STYLE_PRESETS[presetId];
            if (!preset) {
                console.error('Unknown preset:', presetId);
                return;
            }
            
            activeStyleSettings = { ...preset.settings };
            activePresetId = presetId;
            
            // Update description text
            const descEl = document.getElementById('presetDescription');
            if (descEl) {
                descEl.textContent = preset.description;
            }
            
            // Update UI
            updateStyleUI();
            
            // Re-transcribe all words with new settings
            reprocessAllWords();
        }
        
        /**
         * Set individual style toggle
         */
        function setStyleSetting(key, value) {
            activeStyleSettings[key] = value;
            
            // When manually changing, we're no longer using a preset
            activePresetId = "custom";
            
            // Update UI
            updateStyleUI();
            
            // Re-transcribe
            reprocessAllWords();
        }
        
        /**
         * Update style preset UI to reflect current state
         */
        function updateStyleUI() {
            // Update preset radio buttons
            const radioId = `preset-${activePresetId === 'sung_russian_grayson' ? 'grayson' : 
                             activePresetId === 'modern_standard' ? 'csr' : 
                             activePresetId}`;
            const radio = document.getElementById(radioId);
            if (radio) {
                radio.checked = true;
            }
        }
        
        /**
         * Reprocess all words with current style settings
         */
        function reprocessAllWords() {
            if (processedWords.length > 0) {
                processedWords.forEach((wordData, idx) => {
                    const stressIndex = wordData.processed.stressIndex;
                    const wordToProcess = wordData.correctedWord || wordData.originalWord;
                    wordData.processed = processWord(wordToProcess, stressIndex);
                });
                renderOutput();
            }
        }
        
        /**
         * Apply notation preferences to IPA string for display
         */
        function applyNotationPreferences(ipa) {
            let result = ipa;
            
            if (notationSettings.shchaUseLengthMark) {
                // Replace doubled palatalized fricative with length mark
                result = result.replace(/ É ≤ É ≤/g, ' É ≤Àê');
            }
            
            if (notationSettings.palatalnUseNj) {
                // Replace palatal nasal with n + palatalization marker
                result = result.replace(/…≤/g, 'n ≤');
            }
            
            return result;
        }
        
        /**
         * Apply style settings to IPA string
         * This handles regional/historical variations from Chapter 9
         */
        function applyStyleSettings(ipa) {
            let result = ipa;
            
            // 1. Vowel reduction style
            const vowelStyle = getStyleSetting('vowelReduction');
            if (vowelStyle === 'ekanye') {
                // Petersburg style: unstressed –µ/—è stay as /…õ/ not /…™/
                // Only change unstressed positions (not stressed or in specific patterns)
                // This is a simplified approximation - full implementation would
                // require access to stress context during transcription
                result = result.replace(/…™/g, '…õ');
            } else if (vowelStyle === 'none') {
                // Choral simplified: no reduction at all
                // …™ ‚Üí …õ (for –µ),  å ‚Üí …ë (for –æ/–∞ in remote positions)
                result = result.replace(/…™/g, '…õ');
                result = result.replace(/ å/g, '…ë');
            }
            
            // 2. –© pronunciation
            const shchaStyle = getStyleSetting('—âPronunciation');
            if (shchaStyle === 'shchokanye') {
                // Petersburg/Church Slavonic: —â ‚Üí / É ≤t É ≤/
                result = result.replace(/ É ≤ É ≤/g, ' É ≤t É ≤');
            }
            
            // 3. Velar + –∏–π ending (more complex, needs word-level context)
            // This is handled partially through pattern matching
            // Full implementation would need to detect -–∫–∏–π/-–≥–∏–π/-—Ö–∏–π endings
            
            return result;
        }
        
        /**
         * Toggle shcha notation and re-render
         */
        function toggleShchaNotation() {
            notationSettings.shchaUseLengthMark = !notationSettings.shchaUseLengthMark;
            const btn = document.getElementById('shchaToggle');
            if (btn) {
                btn.textContent = notationSettings.shchaUseLengthMark ? ' É ≤Àê' : ' É ≤ É ≤';
                btn.classList.toggle('alt-state', notationSettings.shchaUseLengthMark);
            }
            renderOutput();
        }
        
        /**
         * Toggle palatal n notation and re-render
         */
        function togglePalatalnNotation() {
            notationSettings.palatalnUseNj = !notationSettings.palatalnUseNj;
            const btn = document.getElementById('palatalnToggle');
            if (btn) {
                btn.textContent = notationSettings.palatalnUseNj ? 'n ≤' : '…≤';
                btn.classList.toggle('alt-state', notationSettings.palatalnUseNj);
            }
            renderOutput();
        }

        function normalizeChar(char) {
            return charMap[char] || char;
        }

        function normalizeText(text) {
            return Array.from(text).map(normalizeChar).join('');
        }

        function isVowel(char) {
            return vowels.has(char?.toLowerCase());
        }

        function isConsonant(char) {
            return consonants.has(char?.toLowerCase());
        }

        function isSonorant(char) {
            const sonorants = new Set(['–ª', '–º', '–Ω', '—Ä', '–π']);
            return sonorants.has(char?.toLowerCase());
        }

        function getSonority(char) {
            char = char?.toLowerCase();
            if (isVowel(char)) return 4;
            if (char === '–π') return 3;
            if (isSonorant(char)) return 2;
            if (isConsonant(char)) return 1;
            return 0;
        }

        // Syllabification based on open syllable preference for singers
        // 
        // RULE: ALL consonants between vowels go to the NEXT syllable
        // 
        // EXCEPTIONS:
        // 1. C—å and C—ä stay together as a unit (soft/hard signs modify consonant)
        // 2. –π stays with PRECEDING vowel (Grayson Ch. 3 Sec. 2, p. 96-97)
        //    - –π is a semivowel that forms diphthongs: –∞–π, –µ–π, –∏–π, –æ–π, —É–π, —ã–π, etc.
        //    - The pattern is always V–π (vowel + –π), so –π closes the syllable
        //    - Example: –º–æ–π ‚Üí –º–æ–π (one syllable), not –º–æ-–π
        //    - Example: –≤–æ–π—Ç–∏ ‚Üí –≤–æ–π-—Ç–∏, not –≤–æ-–π—Ç–∏
        //
        function syllabify(word) {
            const chars = Array.from(word.toLowerCase());
            const syllables = [];
            let currentSyllable = '';
            let i = 0;

            while (i < chars.length) {
                const char = chars[i];
                
                // Soft/hard signs attach to previous consonant
                if (char === '—å' || char === '—ä') {
                    currentSyllable += char;
                    i++;
                    continue;
                }
                
                currentSyllable += char;

                // Check if this is a vowel (nucleus of syllable)
                if (isVowel(char)) {
                    // Check if next char is –π (semivowel) - it stays with this vowel
                    // Grayson p. 96-97: –π forms diphthongs with preceding vowels
                    if (i + 1 < chars.length && chars[i + 1] === '–π') {
                        currentSyllable += '–π';
                        i++; // Skip the –π, we've added it
                    }
                    
                    // Look ahead for consonants after this vowel (and any –π we just added)
                    let j = i + 1;
                    while (j < chars.length && !isVowel(chars[j])) {
                        j++;
                    }

                    // If we hit the end of the word, attach all remaining consonants to this syllable
                    if (j >= chars.length) {
                        currentSyllable += chars.slice(i + 1).join('');
                        syllables.push(currentSyllable);
                        currentSyllable = ''; // Clear so leftover check doesn't duplicate
                        break; // Exit loop completely
                    }

                    // If next character is a vowel (no consonants between), close the syllable
                    if (j === i + 1) {
                        syllables.push(currentSyllable);
                        currentSyllable = '';
                        i++;
                        continue;
                    }

                    // We have consonants before the next vowel
                    // OPEN SYLLABLE RULE: ALL consonants go to next syllable
                    // Just close the current syllable after the vowel
                    syllables.push(currentSyllable);
                    currentSyllable = '';
                }
                
                i++;
            }

            // Handle any leftover (shouldn't happen with well-formed words)
            if (currentSyllable) {
                // Check if it's just signs attached to nothing
                const trimmed = currentSyllable.replace(/[—å—ä]/g, '');
                if (trimmed.length > 0) {
                    syllables.push(currentSyllable);
                }
            }

            return syllables.length > 0 ? syllables : [word.toLowerCase()];
        }

        function countVowels(word) {
            return Array.from(word.toLowerCase()).filter(char => isVowel(char)).length;
        }

        // Get position of syllable relative to stress
        function getSyllablePosition(syllableIndex, stressIndex, totalSyllables) {
            if (syllableIndex === stressIndex) return 'stressed';
            if (stressIndex === -1) return 'unstressed'; // No stress marked
            if (syllableIndex === stressIndex - 1) return 'pretonic-immediate';
            if (syllableIndex < stressIndex) return 'pretonic-remote';
            if (syllableIndex === stressIndex + 1) return 'posttonic-immediate';
            return 'posttonic-remote';
        }

        // Check if consonant is "interpalatal" (palatalized)
        // ============================================================================
        // PALATALIZING AGENT DETECTION
        // Grayson p. 104: "[a] only occurs interpalatally" - bounded by palatalized
        // phonemes on BOTH sides. Right side can be "a palatalized consonant or /j/
        // (spelled -–π-)."
        // ============================================================================
        
        /**
         * Check if a character is a palatalizing agent (for interpalatal right-side check)
         * Grayson p. 104: Right side of interpalatal position requires
         * "a palatalized consonant or /j/ (spelled -–π-)"
         */
        function isPalatalizingAgent(char, nextChar) {
            char = char?.toLowerCase();
            nextChar = nextChar?.toLowerCase();
            
            // Grayson p. 104: "/j/ (spelled -–π-)" - –π always counts
            if (char === '–π') return true;
            
            // Palatalizing vowels themselves are palatalizing agents
            // (they represent /j/ + vowel, so the /j/ palatalizes what precedes)
            if (['–∏', '–µ', '—ë', '—é', '—è'].includes(char)) return true;
            
            // Grayson p. 104: —á and —â are inherently palatal (transcribed /t É ≤/ and / É ≤ É ≤/)
            const inherentlyPalatal = new Set(['—á', '—â']);
            if (inherentlyPalatal.has(char)) return true;
            
            // Grayson p. 127: "after the consonants / É/ (-—à-), / í/ (-–∂-), or /ts/ (-—Ü-)"
            // these are always hard - never palatalizing agents
            const alwaysHard = new Set(['–∂', '—à', '—Ü']);
            if (alwaysHard.has(char)) return false;
            
            // Other consonants are palatalizing agents if followed by —å or palatalizing vowel
            if (nextChar === '—å') return true;
            if (['–∏', '–µ', '—ë', '—é', '—è'].includes(nextChar)) return true;
            
            return false;
        }
        
        /**
         * Check if consonant is palatalized (for transcription purposes)
         * Used for determining consonant IPA output and left-side interpalatal check
         * Grayson p. 104: Left side requires —á, —â, or "any other palatalized consonant"
         */
        function isInterpalatal(consonant, nextChar) {
            // Grayson p. 104: —á, —â, –π are inherently palatal
            // Note: –∂, —à, —Ü are ALWAYS HARD - never palatalizing agents
            const inherentlyPalatal = new Set(['—á', '—â', '–π']);
            consonant = consonant?.toLowerCase();
            nextChar = nextChar?.toLowerCase();
            
            if (inherentlyPalatal.has(consonant)) return true;
            // –∂, —à, —Ü are always hard - never count as palatalized
            if (['–∂', '—à', '—Ü'].includes(consonant)) return false;
            if (nextChar === '—å') return true;
            if (nextChar === '–∏' || nextChar === '–µ' || nextChar === '—ë' || nextChar === '—é' || nextChar === '—è') {
                return true;
            }
            return false;
        }

        // ============================================================================
        // REGRESSIVE VOICING ASSIMILATION (Grayson Chapter 6, pp. 214-224)
        // ============================================================================
        // "Regressive assimilation of voicing occurs when one consonant phoneme takes
        // on the voicing quality (voiced or unvoiced) of an immediately following
        // consonant phoneme." (p. 214)
        //
        // Key rules:
        // 1. Sonorants (–ª, –º, –Ω, —Ä, –π) do NOT influence voicing and are never devoiced
        // 2. –≤ has NO assimilative power - look past it to the next consonant
        // 3. Last consonant in cluster determines voicing of entire cluster
        // ============================================================================
        
        /**
         * Analyze a word and return a map of character indices to their assimilated voicing
         * Returns: Map<index, 'voiced'|'unvoiced'|null> where null means no change
         * 
         * KEY INSIGHT: Voicing assimilation only occurs within consonant clusters,
         * NOT across vowels. A vowel breaks the assimilation chain.
         */
        function analyzeVoicingAssimilation(word) {
            const chars = Array.from(word.toLowerCase());
            const voicingMap = new Map();
            
            // Sonorants: never devoice, don't influence others (p. 214, 251)
            const sonorants = new Set(['–ª', '–º', '–Ω', '—Ä', '–π']);
            
            // Voiced consonants that can be devoiced
            const voicedConsonants = new Set(['–±', '–≤', '–≥', '–¥', '–∂', '–∑']);
            
            // Unvoiced consonants that can be voiced
            const unvoicedConsonants = new Set(['–ø', '—Ñ', '–∫', '—Ç', '—à', '—Å', '—Ö', '—Ü', '—á', '—â']);
            
            // Voiced/unvoiced pairs (p. 258-259)
            const voicedToUnvoiced = {
                '–±': 'p', '–≤': 'f', '–≥': 'k', '–¥': 't', '–∂': ' É', '–∑': 's'
            };
            const unvoicedToVoiced = {
                '–ø': 'b', '—Ñ': 'v', '–∫': '…°', '—Ç': 'd', '—à': ' í', '—Å': 'z',
                '—Ö': '…£',  // p. 257: —Ö ‚Üí […£] when voiced
                '—Ü': 'dz', // p. 256: —Ü ‚Üí [dz] when voiced
                '—á': 'd í ≤', // p. 256: —á ‚Üí [d í ≤] when voiced (stays palatalized)
                '—â': ' í ≤ í ≤' // p. 224: —â ‚Üí [ í ≤ í ≤] when voiced (rare)
            };
            
            // Process right-to-left to find voicing agents
            for (let i = chars.length - 1; i >= 0; i--) {
                const char = chars[i];
                
                // Skip non-consonants and signs
                if (!isConsonant(char) || char === '—ä' || char === '—å') continue;
                
                // Skip sonorants - they don't participate in voicing assimilation
                if (sonorants.has(char)) continue;
                
                // Find the IMMEDIATELY following consonant in the cluster
                // A vowel BREAKS the cluster - no assimilation across vowels
                let nextConsonantIdx = -1;
                let nextConsonant = null;
                
                for (let j = i + 1; j < chars.length; j++) {
                    const nc = chars[j];
                    
                    // Signs don't break the cluster
                    if (nc === '—å' || nc === '—ä') continue;
                    
                    // A VOWEL BREAKS THE CLUSTER - stop looking
                    if (isVowel(nc)) break;
                    
                    // Sonorants don't influence voicing but are part of cluster
                    // They don't trigger assimilation but we continue past them
                    if (sonorants.has(nc)) continue;
                    
                    // –≤ has no assimilative power (p. 251) - look past it
                    // BUT –≤ itself IS influenced by what follows
                    if (nc === '–≤') {
                        // Keep looking for the actual voicing agent
                        continue;
                    }
                    
                    if (isConsonant(nc)) {
                        nextConsonantIdx = j;
                        nextConsonant = nc;
                        break;
                    }
                }
                
                // No following consonant in this cluster to assimilate from
                if (nextConsonant === null) continue;
                
                // Determine if next consonant is voiced or unvoiced
                const nextIsVoiced = voicedConsonants.has(nextConsonant);
                const nextIsUnvoiced = unvoicedConsonants.has(nextConsonant);
                
                // Apply assimilation
                if (nextIsUnvoiced && voicedConsonants.has(char)) {
                    // Voiced consonant before unvoiced ‚Üí devoice
                    // e.g., –≤–æ–¥–∫–∞: –¥ before –∫ ‚Üí —Ç (p. 217)
                    voicingMap.set(i, { type: 'devoice', ipa: voicedToUnvoiced[char] });
                } else if (nextIsVoiced && unvoicedConsonants.has(char)) {
                    // Unvoiced consonant before voiced ‚Üí voice
                    // e.g., –≤–æ–∫–∑–∞–ª: –∫ before –∑ ‚Üí –≥ (p. 219-220)
                    // e.g., —Å–¥–µ–ª–∫–∞: —Å before –¥ ‚Üí –∑ (p. 220)
                    voicingMap.set(i, { type: 'voice', ipa: unvoicedToVoiced[char] });
                }
            }
            
            return voicingMap;
        }
        
        // ============================================================================
        // REGRESSIVE PALATALIZATION IN CLUSTERS (Grayson Chapter 5, pp. 205-211)
        // ============================================================================
        // "Since one consonant can be a palatalizing agent of preceding consonants,
        // one must determine that the first consonant is palatalized." (p. 206)
        //
        // Russian lyric diction follows Old Muscovite pronunciation which palatalizes
        // nearly all secondary cluster members (p. 209).
        //
        // LIMITING RULES (p. 209):
        // 1. Do NOT regressively palatalize /…´/ except when doubled (–ª–ª—å ‚Üí l ≤l ≤)
        // 2. Do NOT regressively palatalize /r/ except when doubled OR after stressed –∏,–µ,—ç
        // 3. Do NOT regressively palatalize /n/ except before palatalized /n/ or dental
        // 4. ONLY regressively palatalize velars (–∫,–≥,—Ö) before another palatalized velar
        // 5. ONLY regressively palatalize labials (–±,–ø,–≤,—Ñ,–º) before another palatalized labial
        //
        // BOUNDARIES that block palatalization (p. 206):
        // 1. —à, –∂, —Ü (always hard consonants)
        // 2. —ä (hard sign) - except after –≤, —Å, –∑
        // 3. Vowels (though vowel may be fronted)
        // 4. New palatalizing agent (starts new chain)
        // 5. Word boundary - except –≤, —Å, –∑ before indicator letters
        // 6. Punctuation (absolute)
        // ============================================================================
        
        /**
         * Analyze regressive palatalization in consonant clusters
         * Returns: Map<index, boolean> where true means this consonant should be palatalized
         */
        function analyzeRegressivePalatalization(word) {
            const chars = Array.from(word.toLowerCase());
            const palatalizationMap = new Map();
            
            // Consonant groups for limiting rules
            const dentals = new Set(['—Ç', '–¥', '—Å', '–∑', '–Ω', '—Ü']);
            const velars = new Set(['–∫', '–≥', '—Ö']);
            const labials = new Set(['–±', '–ø', '–≤', '—Ñ', '–º']);
            const sonorants = new Set(['–ª', '–º', '–Ω', '—Ä', '–π']);
            
            // Always hard consonants - boundaries to palatalization
            const alwaysHard = new Set(['–∂', '—à', '—Ü']);
            
            // Inherently palatalized
            const inherentlyPalatalized = new Set(['—á', '—â', '–π']);
            
            // Palatalizing vowels
            const palatalizingVowels = new Set(['–µ', '—ë', '–∏', '—é', '—è']);
            
            // First pass: identify directly palatalized consonants
            for (let i = 0; i < chars.length; i++) {
                const char = chars[i];
                const nextChar = chars[i + 1];
                
                if (!isConsonant(char)) continue;
                if (alwaysHard.has(char)) continue; // Never palatalized
                
                // Check if directly palatalized
                if (inherentlyPalatalized.has(char)) {
                    palatalizationMap.set(i, true);
                } else if (nextChar === '—å') {
                    palatalizationMap.set(i, true);
                } else if (palatalizingVowels.has(nextChar) && !alwaysHard.has(char)) {
                    palatalizationMap.set(i, true);
                }
            }
            
            // Second pass: regressive palatalization through clusters
            // Process right-to-left, spreading palatalization backward
            for (let i = chars.length - 1; i >= 0; i--) {
                const char = chars[i];
                
                if (!isConsonant(char)) continue;
                if (alwaysHard.has(char)) continue;
                if (palatalizationMap.get(i)) continue; // Already palatalized
                
                // Look for next consonant in cluster (vowels break clusters)
                let nextConsIdx = -1;
                let nextCons = null;
                for (let j = i + 1; j < chars.length; j++) {
                    const nc = chars[j];
                    if (nc === '—å' || nc === '—ä') continue;
                    if (isVowel(nc)) break; // Vowel breaks cluster
                    if (isConsonant(nc)) {
                        nextConsIdx = j;
                        nextCons = nc;
                        break;
                    }
                }
                
                if (nextCons === null) continue;
                if (!palatalizationMap.get(nextConsIdx)) continue; // Next consonant not palatalized
                
                // Check if the always-hard consonants block this
                if (alwaysHard.has(nextCons)) continue;
                
                // Apply limiting rules (Grayson p. 209)
                
                // Rule 1: Don't palatalize –ª except when doubled
                if (char === '–ª') {
                    if (nextCons === '–ª' && palatalizationMap.get(nextConsIdx)) {
                        palatalizationMap.set(i, true); // –ª–ª—å ‚Üí l ≤l ≤
                    }
                    continue;
                }
                
                // Rule 2: Don't palatalize —Ä except when doubled OR after stressed front vowel
                // Grayson p. 209, fn. 277: "directly following -–∏-, -–µ-, or -—ç- (in the stressed syllable only)"
                // Examples: —Å–º–µ—Ä—Ç—å /s ≤m ≤er ≤t ≤/, —Ç–µ—Ä–ø–µ—Ç—å /t ≤ir ≤ Ààp ≤et ≤/, –∫–∏—Ä–ø–∏—á /k ≤ir ≤ Ààp ≤it É ≤/
                if (char === '—Ä') {
                    // Check if doubled
                    if (nextCons === '—Ä' && palatalizationMap.get(nextConsIdx)) {
                        palatalizationMap.set(i, true); // —Ä—Ä—å ‚Üí r ≤r ≤
                        continue;
                    }
                    // Check if preceded by stressed front vowel (–∏, –µ, —ç)
                    // This requires knowing stress position, which we check in transcribeSyllable
                    // For now, we allow —Ä to palatalize if directly following palatalized consonant
                    // The stressed-vowel check happens separately in transcribeSyllable
                    continue;
                }
                
                // Rule 3: –Ω only palatalizes before palatalized –Ω or dental
                if (char === '–Ω') {
                    if (nextCons === '–Ω' || dentals.has(nextCons)) {
                        palatalizationMap.set(i, true);
                    }
                    continue;
                }
                
                // Rule 4: Velars only palatalize before palatalized velars
                if (velars.has(char)) {
                    if (velars.has(nextCons) && palatalizationMap.get(nextConsIdx)) {
                        palatalizationMap.set(i, true);
                    }
                    continue;
                }
                
                // Rule 5: Labials only palatalize before palatalized labials
                if (labials.has(char)) {
                    if (labials.has(nextCons) && palatalizationMap.get(nextConsIdx)) {
                        palatalizationMap.set(i, true);
                    }
                    continue;
                }
                
                // Default for dentals (—Ç, –¥, —Å, –∑): palatalize before any palatalized consonant
                // This is the Old Muscovite style (p. 209)
                if (dentals.has(char)) {
                    palatalizationMap.set(i, true);
                }
            }
            
            return palatalizationMap;
        }
        
        // ============================================================================
        // EXCEPTION WORDS - Complete IPA overrides
        // ============================================================================
        // Sources: Grayson Ch. 8.5 (pp. 287-288), Ch. 6 (pp. 243-246),
        //          Appendix F (pp. 344-353)
        // These words have exceptional pronunciations that override standard rules.
        // ============================================================================
        
        /**
         * Check if word has a complete IPA exception override
         */
        function checkExceptionWord(word) {
            const normalized = word.toLowerCase();
            return EXCEPTION_WORDS[normalized] || null;
        }
        
        // ============================================================================
        // SPECIAL CLUSTER READINGS (Grayson Chapter 6, Section 2, pp. 235-247)
        // ============================================================================
        // Certain consonant clusters have special pronunciations that don't directly
        // reflect the usually associated phonemes of the Cyrillic spelling.
        // ============================================================================
        
        /**
         * Check for special cluster readings and return replacement IPA
         * Returns: { startIdx, length, ipa } or null if no special cluster
         */
        function checkSpecialCluster(word, startIdx) {
            const chars = Array.from(word.toLowerCase());
            const remaining = chars.slice(startIdx).join('');
            
            // Two-letter clusters that read as one double consonant (p. 235-236)
            // —Å—à, –∑—à ‚Üí / ÉÀê/
            if (remaining.startsWith('—Å—à') || remaining.startsWith('–∑—à')) {
                return { length: 2, ipa: ' ÉÀê', description: '—Å—à/–∑—à ‚Üí  ÉÀê (p. 235)' };
            }
            // –∑–∂, —Å–∂ ‚Üí / íÀê/
            if (remaining.startsWith('–∑–∂') || remaining.startsWith('—Å–∂')) {
                return { length: 2, ipa: ' íÀê', description: '–∑–∂/—Å–∂ ‚Üí  íÀê (p. 236)' };
            }
            
            // Two- and three-letter clusters that read like another consonant (p. 236)
            // —Å—á, –∑—á ‚Üí / É ≤ É ≤/ (like —â)
            if (remaining.startsWith('—Å—á') || remaining.startsWith('–∑—á')) {
                return { length: 2, ipa: ' É ≤ É ≤', description: '—Å—á/–∑—á ‚Üí  É ≤ É ≤ (p. 236)' };
            }
            // –∂—á ‚Üí / É ≤ É ≤/ (like —â)
            if (remaining.startsWith('–∂—á')) {
                return { length: 2, ipa: ' É ≤ É ≤', description: '–∂—á ‚Üí  É ≤ É ≤ (p. 236)' };
            }
            // —Å—Ç—á, –∑–¥—á ‚Üí / É ≤ É ≤/ (like —â)
            if (remaining.startsWith('—Å—Ç—á') || remaining.startsWith('–∑–¥—á')) {
                return { length: 3, ipa: ' É ≤ É ≤', description: '—Å—Ç—á/–∑–¥—á ‚Üí  É ≤ É ≤ (p. 236)' };
            }
            // —Å—Å—á ‚Üí / É ≤ É ≤/ (like —â)
            if (remaining.startsWith('—Å—Å—á')) {
                return { length: 3, ipa: ' É ≤ É ≤', description: '—Å—Å—á ‚Üí  É ≤ É ≤ (p. 236)' };
            }
            
            // —Ç—à, –¥—à, —á—à ‚Üí /t ÉÀê/ (p. 236)
            if (remaining.startsWith('—Ç—à') || remaining.startsWith('–¥—à') || remaining.startsWith('—á—à')) {
                return { length: 2, ipa: 't ÉÀê', description: '—Ç—à/–¥—à/—á—à ‚Üí t ÉÀê (p. 236)' };
            }
            
            // –¥–∂, —Ç–∂ ‚Üí /d íÀê/ (p. 237)
            // Example: –ø–æ–¥–∂—ë–≥ /p…ë Ààd íÀêok/, –æ—Ç–∂–∏–ª /Àào d íÀê…®…´/
            if (remaining.startsWith('–¥–∂') || remaining.startsWith('—Ç–∂')) {
                return { length: 2, ipa: 'd íÀê', description: '–¥–∂/—Ç–∂ ‚Üí d íÀê (p. 237)' };
            }
            
            // —Ç—á, –¥—á ‚Üí /t ≤Àê É ≤Àê/ (p. 237)
            // Example: –≤–æ—Ç—á–∏–Ω–∞ /Ààvo t ≤Àê É ≤Àêi n å/, –ø–æ–¥—á–∞—Å /p…ë Ààt ≤Àê É ≤Àê…ës/
            if (remaining.startsWith('—Ç—á') || remaining.startsWith('–¥—á')) {
                return { length: 2, ipa: 't ≤ É ≤', description: '—Ç—á/–¥—á ‚Üí t ≤ É ≤ (p. 237)' };
            }
            
            // —Ç—Ü, –¥—Ü ‚Üí /tÀês/ - assimilated (p. 237-238)
            // Example: –æ—Ç—Ü–∞ /…ë ÀàtÀês…ë/, –º–æ–ª–æ–¥—Ü—ã /m å …´…ë ÀàtÀês…®/
            if (remaining.startsWith('—Ç—Ü') || remaining.startsWith('–¥—Ü')) {
                return { length: 2, ipa: 'tÀês', description: '—Ç—Ü/–¥—Ü ‚Üí tÀês (p. 237)' };
            }
            
            // Grayson p. 239-240: —á–Ω ‚Üí / Én/ (—Å–∫—É—á–Ω–æ rule)
            // Limited to specific common words: —Å–∫—É—á–Ω—ã–π, —Å–∫—É—á–Ω–æ, –∫–æ–Ω–µ—á–Ω–æ
            // BUT NOT –∫–æ–Ω–µ—á–Ω—ã–π (which is /t É ≤n/)
            if (remaining.startsWith('—á–Ω')) {
                // Check if this is one of the special words
                const word = chars.join('');
                if (word.includes('—Å–∫—É—á–Ω') || word === '–∫–æ–Ω–µ—á–Ω–æ') {
                    return { length: 2, ipa: ' Én', description: '—á–Ω ‚Üí  Én (—Å–∫—É—á–Ω–æ rule, p. 239)' };
                }
            }
            
            // Grayson p. 240: —á—Ç ‚Üí / Ét/ (—á—Ç–æ rule)
            // Only for —á—Ç–æ and derivatives (—á—Ç–æ–±—ã, –Ω–∏—á—Ç–æ), NOT –Ω–µ—á—Ç–æ
            if (remaining.startsWith('—á—Ç')) {
                const word = chars.join('');
                if (word === '—á—Ç–æ' || word.startsWith('—á—Ç–æ–±') || word === '–Ω–∏—á—Ç–æ') {
                    return { length: 2, ipa: ' Ét', description: '—á—Ç ‚Üí  Ét (—á—Ç–æ rule, p. 240)' };
                }
            }
            
            // Grayson p. 240: –≥–∫ ‚Üí /xk/ or /x ≤k ≤/ (–º—è–≥–∫–æ/–º—è–≥–∫–∏–π rule)
            // The palatalization of —Ö depends on whether the following –∫ is soft
            // –≥–∫ before hard vowel (–∞, –æ, —É, —ã, —ç) or word-end ‚Üí /xk/
            // –≥–∫ before soft vowel (–µ, —ë, –∏, —é, —è) ‚Üí /x ≤k ≤/
            // Examples: –º—è–≥–∫–æ /Ààm ≤…ëx k å/, –º—è–≥–∫–∏–π /Ààm ≤…ëx ≤ k ≤ij/
            //           –ª–µ–≥–∫–æ /l ≤…™x Ààko/, –ª—ë–≥–∫–∏–π /Ààl ≤ox ≤ k ≤ij/
            if (remaining.startsWith('–≥–∫')) {
                const word = chars.join('');
                if (word.includes('–º—è–≥–∫') || word.includes('–ª—ë–≥–∫') || word.includes('–ª–µ–≥–∫')) {
                    // Check what follows the –∫ to determine palatalization
                    const afterK = chars[startIdx + 2]; // character after –≥–∫
                    const softVowels = ['–µ', '—ë', '–∏', '—é', '—è', '—å'];
                    if (afterK && softVowels.includes(afterK)) {
                        return { length: 2, ipa: 'x ≤k ≤', description: '–≥–∫ ‚Üí x ≤k ≤ before soft vowel (p. 240)' };
                    } else {
                        return { length: 2, ipa: 'xk', description: '–≥–∫ ‚Üí xk before hard vowel (p. 240)' };
                    }
                }
            }
            
            // Grayson p. 241: –≥—á ‚Üí /xt É ≤/ (–º—è–≥—á–µ - comparative forms)
            // CRITICAL: The —Ö is NOT palatalized before —á (exception to regressive palatalization)
            // "Note that although /t É ≤/ is a palatalized phoneme, the preceding /x/-phoneme is
            // not palatalized. This is an exception to the normal, regressive assimilation of
            // palatalization rule." (p. 241)
            if (remaining.startsWith('–≥—á')) {
                const word = chars.join('');
                if (word.includes('–º—è–≥—á') || word.includes('–ª—ë–≥—á') || word.includes('–ª–µ–≥—á')) {
                    return { length: 1, ipa: 'x', description: '–≥ ‚Üí x before —á (NOT palatalized, p. 241)' };
                }
            }
            
            // Grayson p. 243: —Å—Ç–Ω ‚Üí /sn/ or /s…≤/ (deletion)
            // Example: —Å—Ç—Ä–∞—Å—Ç–Ω—ã–π /Ààstr…ë sn…®j/, —á–µ—Å—Ç–Ω–µ–µ /t É ≤…™ Ààs ≤…≤e j…™/
            // The –Ω palatalizes if followed by a palatalizing vowel
            if (remaining.startsWith('—Å—Ç–Ω')) {
                const afterCluster = remaining.substring(3);
                const palatalizingVowels = ['–µ', '—ë', '–∏', '—é', '—è', '—å'];
                if (afterCluster.length > 0 && palatalizingVowels.includes(afterCluster[0])) {
                    return { length: 3, ipa: 's…≤', description: '—Å—Ç–Ω ‚Üí s…≤ before soft vowel (p. 243)' };
                }
                return { length: 3, ipa: 'sn', description: '—Å—Ç–Ω ‚Üí sn (deletion, p. 243)' };
            }
            
            // Grayson p. 243: –∑–¥–Ω ‚Üí /zn/ or /z…≤/ (deletion)
            // Example: –ø–æ–∑–¥–Ω–æ /Ààpo zn å/, –ø–æ–∑–¥–Ω–∏–π /Ààpo z…≤ij/
            // The –Ω palatalizes if followed by a palatalizing vowel (–µ, —ë, –∏, —é, —è, —å)
            // Exception: –±–µ–∑–¥–Ω–∞ keeps all three consonants
            if (remaining.startsWith('–∑–¥–Ω')) {
                const word = chars.join('');
                if (!word.includes('–±–µ–∑–¥–Ω')) {
                    // Check what follows the –∑–¥–Ω cluster
                    const afterCluster = remaining.substring(3);
                    const palatalizingVowels = ['–µ', '—ë', '–∏', '—é', '—è', '—å'];
                    if (afterCluster.length > 0 && palatalizingVowels.includes(afterCluster[0])) {
                        return { length: 3, ipa: 'z…≤', description: '–∑–¥–Ω ‚Üí z…≤ before soft vowel (p. 243)' };
                    }
                    return { length: 3, ipa: 'zn', description: '–∑–¥–Ω ‚Üí zn (deletion, p. 243)' };
                }
            }
            
            // Grayson p. 243: —Ä–¥—Ü ‚Üí /rts/ (deletion)
            // Example: —Å–µ—Ä–¥—Ü–µ /Ààs ≤…õr ts…®/
            if (remaining.startsWith('—Ä–¥—Ü')) {
                return { length: 3, ipa: 'rts', description: '—Ä–¥—Ü ‚Üí rts (deletion, p. 243)' };
            }
            
            // Grayson p. 246: –ª–Ω—Ü ‚Üí /nts/ (—Å–æ–ª–Ω—Ü–µ rule - unique)
            // Example: —Å–æ–ª–Ω—Ü–µ /Ààson ts…®/
            if (remaining.startsWith('–ª–Ω—Ü')) {
                return { length: 3, ipa: 'nts', description: '–ª–Ω—Ü ‚Üí nts (—Å–æ–ª–Ω—Ü–µ rule, p. 246)' };
            }
            
            // Grayson p. 246: –≤—Å—Ç–≤ ‚Üí /stv/ (deletion)
            // Example: —á—É–≤—Å—Ç–≤–æ /Ààt É ≤u stv å/, –∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ /Ààzdr…ë stvuj t ≤…™/
            if (remaining.startsWith('–≤—Å—Ç–≤')) {
                return { length: 4, ipa: 'stv', description: '–≤—Å—Ç–≤ ‚Üí stv (deletion, p. 246)' };
            }
            
            // Grayson p. 237: -—Ç—å—Å—è/-—Ç—Å—è verb endings ‚Üí /tÀês å/
            // "The clusters -—Ç—Å-/-–¥—Å- and -—Ç—å—Å-/-–¥—å—Å- as part of the reflexive verb endings
            // -—Ç—Å—è-/-–¥—Å—è- and -—Ç—å—Å—è-/-–¥—å—Å—è-... resemble the reading of the letter -—Ü- (/ts/),
            // but have an elongated stop on the /t/-portion of the phoneme."
            // Example: –∫—É–ø–∞—Ç—å—Å—è ‚Üí /ku Ààp…ë tÀês å/
            if (remaining.startsWith('—Ç—å—Å—è') || remaining.startsWith('—Ç—Å—è')) {
                return { length: remaining.startsWith('—Ç—å—Å—è') ? 4 : 3, ipa: 'tÀês å', description: '-—Ç—å—Å—è/-—Ç—Å—è ‚Üí tÀês å (p. 237)' };
            }
            if (remaining.startsWith('–¥—å—Å—è') || remaining.startsWith('–¥—Å—è')) {
                return { length: remaining.startsWith('–¥—å—Å—è') ? 4 : 3, ipa: 'tÀês å', description: '-–¥—å—Å—è/-–¥—Å—è ‚Üí tÀês å (p. 237)' };
            }
            
            // Grayson p. 267: Reflexive -—Å—è/-—Å—å endings (without preceding —Ç/–¥)
            // "except in the reflexive verbal endings -—Ç—å—Å—è and -—Ç—Å—è, when it is read as [ å]"
            // The —Å in reflexive endings stays unpalatalized (like in /ts/), —è ‚Üí  å
            // This applies to all reflexive verbs: —Å–∂–∞–ª—å—Å—è, –±–æ–π—Å—è, etc.
            // Example: —Å–∂–∞–ª—å—Å—è ‚Üí / íÀê…ël ≤s å/
            // Only match at word end AND not if preceded by —Ç/–¥ (those are handled above)
            if ((remaining === '—Å—è' || remaining === '—Å—å') || 
                (remaining.startsWith('—Å—è') && remaining.length === 2) ||
                (remaining.startsWith('—Å—å') && remaining.length === 2)) {
                // Check that this isn't part of -—Ç—Å—è/-–¥—Å—è (already handled above)
                const prevCharInWord = chars[startIdx - 1];
                const prevPrevCharInWord = chars[startIdx - 2];
                // If preceded by —Ç, —Ç—å, –¥, or –¥—å, skip ‚Äî already handled by -—Ç—Å—è/-–¥—Å—è rule
                if (prevCharInWord === '—Ç' || prevCharInWord === '–¥' ||
                    (prevCharInWord === '—å' && (prevPrevCharInWord === '—Ç' || prevPrevCharInWord === '–¥'))) {
                    return null;
                }
                return { length: 2, ipa: 's å', description: '-—Å—è/-—Å—å reflexive ‚Üí s å (p. 267)' };
            }
            
            // ================================================================
            // GENITIVE/ADJECTIVE ENDING: -–æ–≥–æ/-–µ–≥–æ ‚Üí –≥ = /v/
            // ================================================================
            // Grayson p. 189: "The letter ‚ü®–≥‚ü© in the endings -–æ–≥–æ and -–µ–≥–æ is 
            // pronounced /v/, not /…°/."
            // This applies to:
            // - Genitive singular masculine/neuter adjectives: –∫—Ä–∞—Å–∏–≤–æ–≥–æ, —Å–∏–Ω–µ–≥–æ
            // - Genitive singular masculine/neuter pronouns: –µ–≥–æ, –º–æ–µ–≥–æ, —Ç–≤–æ–µ–≥–æ
            // - Words ending in -–æ–≥–æ/-–µ–≥–æ at word end
            // 
            // Examples: 
            //   –º–∏–ª–æ–≥–æ /Ààm ≤i …´ å v å/
            //   –∫—Ä–∞—Å–Ω–æ–≥–æ /Ààkr…ë sn å v å/
            //   —Å–∏–Ω–µ–≥–æ /Ààs ≤i …≤…™ v å/
            //   –µ–≥–æ /j…™ Ààvo/
            // ================================================================
            if (remaining.startsWith('–≥')) {
                const word = chars.join('');
                // Check if word ends in -–æ–≥–æ or -–µ–≥–æ (genitive adjective/pronoun ending)
                if (word.endsWith('–æ–≥–æ') || word.endsWith('–µ–≥–æ')) {
                    // Check if this –≥ is in the -–æ–≥–æ/-–µ–≥–æ ending
                    const endingStart = word.length - 3; // position of –æ in -–æ–≥–æ/-–µ–≥–æ
                    if (startIdx === endingStart + 1) { // –≥ is at position endingStart+1
                        return { length: 1, ipa: 'v', description: '-–æ–≥–æ/-–µ–≥–æ: –≥ ‚Üí v (p. 189)' };
                    }
                }
            }
            
            return null;
        }
        
        // Transcribe a single syllable
        function transcribeSyllable(syllable, position, wordContext, lockedSyllables = new Set()) {
            const chars = Array.from(syllable.toLowerCase());
            let ipa = '';
            
            // Get voicing assimilation map from word context
            const voicingMap = wordContext.voicingMap || new Map();
            // Get regressive palatalization map from word context
            const palatalizationMap = wordContext.palatalizationMap || new Map();
            const syllableStartInWord = wordContext.syllableStartInWord || 0;
            // Get cross-syllable geminates set
            const crossSyllableGeminates = wordContext.crossSyllableGeminates || new Set();
            
            // Grayson p. 199-202: Final consonant devoicing
            // "In Russian, as in German, final consonants are generally unvoiced"
            // Exception: sonorants (–ª, –º, –Ω, —Ä) are not devoiced
            const isLastSyllable = wordContext.isLastSyllable || false;
            
            // Devoicing map: voiced ‚Üí unvoiced (Grayson p. 199-202)
            const devoicingMap = {
                '–±': 'p',   // p. 199-200
                '–≤': 'f',   // p. 200
                '–≥': 'k',   // p. 201
                '–¥': 't',   // p. 201
                '–∂': ' É',   // p. 202 (stays hard, NOT palatalized)
                '–∑': 's'    // p. 202
            };
            
            // Helper: check if consonant is word-final (possibly followed only by —å or —ä)
            function isWordFinal(index) {
                if (!isLastSyllable) return false;
                // Check if only —å or —ä follow this consonant
                for (let j = index + 1; j < chars.length; j++) {
                    if (chars[j] !== '—å' && chars[j] !== '—ä') return false;
                }
                return true;
            }
            
            for (let i = 0; i < chars.length; i++) {
                const char = chars[i];
                const prevChar = chars[i - 1];
                const nextChar = chars[i + 1];
                const nextNextChar = chars[i + 2];

                // Skip hard and soft signs in initial pass (handled with consonants)
                if (char === '—ä' || char === '—å') {
                    continue;
                }

                // Consonants
                if (isConsonant(char)) {
                    const isGeminate = char === nextChar;
                    
                    // Calculate this character's position in the full word
                    const wordCharIdx = syllableStartInWord + i;
                    
                    // Check if this consonant is the SECOND part of a cross-syllable geminate
                    // (i.e., the first consonant of this syllable that matches the last of previous)
                    // If so, skip it - the Àê was already added by the previous syllable
                    if (crossSyllableGeminates.has(wordCharIdx) && i === 0) {
                        // This is the first char of syllable AND it's marked as part of cross-syllable geminate
                        // Skip it - the previous syllable will handle the geminate mark
                        continue;
                    }
                    
                    // Check if this —Å is part of -—Ç—Å—è/-–¥—Å—è cluster that was handled in previous syllable
                    // The cluster was found when processing —Ç, so we need to skip the —Å here
                    if (char === '—Å') {
                        const wordCharsCheck = Array.from(wordContext.word.toLowerCase());
                        const prevInWord = wordCharsCheck[wordCharIdx - 1];
                        const prevPrevInWord = wordCharsCheck[wordCharIdx - 2];
                        const nextInWord = wordCharsCheck[wordCharIdx + 1];
                        // If preceded by —Ç/–¥ (or —Ç—å/–¥—å) and followed by —è, this —Å was part of -—Ç—Å—è cluster
                        if ((prevInWord === '—Ç' || prevInWord === '–¥' || 
                             (prevInWord === '—å' && (prevPrevInWord === '—Ç' || prevPrevInWord === '–¥'))) &&
                            nextInWord === '—è') {
                            continue; // Skip - already handled by -—Ç—Å—è cluster
                        }
                    }
                    
                    // Check for special cluster at this position
                    const specialCluster = checkSpecialCluster(wordContext.word, wordCharIdx);
                    if (specialCluster) {
                        // Check if this special cluster starts at current position
                        const clusterChars = Array.from(wordContext.word.toLowerCase()).slice(wordCharIdx, wordCharIdx + specialCluster.length).join('');
                        const expectedStart = chars.slice(i, i + specialCluster.length).join('');
                        
                        if (clusterChars.startsWith(expectedStart.substring(0, Math.min(expectedStart.length, specialCluster.length)))) {
                            ipa += specialCluster.ipa;
                            // Skip ALL characters consumed by this cluster in the syllable
                            // The cluster.length tells us how many Cyrillic chars were consumed
                            // We need to skip that many chars from position i
                            const charsInSyllableForCluster = Math.min(specialCluster.length, chars.length - i);
                            i += (charsInSyllableForCluster - 1); // -1 because for loop will do i++
                            continue;
                        }
                    }
                    
                    // Check if this consonant has voicing assimilation
                    const voicingChange = voicingMap.get(wordCharIdx);
                    
                    // Check if this consonant should be devoiced (word-final position)
                    const shouldDevoice = isWordFinal(i) && devoicingMap.hasOwnProperty(char);
                    
                    // Priority: voicing assimilation > word-final devoicing > default
                    if (voicingChange) {
                        // Use the assimilated IPA from the voicing map
                        ipa += voicingChange.ipa;
                    } else {
                        switch (char) {
                            // Grayson p. 181, 199-200: Labials (–±, –ø, —Ñ, –≤)
                            // –± ‚Üí p when word-final; –≤ ‚Üí f when word-final
                            case '–±': ipa += shouldDevoice ? 'p' : 'b'; break;
                            case '–ø': ipa += 'p'; break;
                            case '–≤': ipa += shouldDevoice ? 'f' : 'v'; break;
                            case '—Ñ': ipa += 'f'; break;
                            // Grayson p. 179-180, 201: Dentals (–¥, —Ç)
                            // –¥ ‚Üí t when word-final
                            case '–¥': ipa += shouldDevoice ? 't' : 'd'; break;
                            case '—Ç': ipa += 't'; break;
                            // Grayson p. 187-189, 201: Velars (–≥, –∫, —Ö)
                            // –≥ ‚Üí k when word-final
                            case '–≥': ipa += shouldDevoice ? 'k' : '…°'; break;
                            case '–∫': ipa += 'k'; break;
                            case '—Ö': ipa += 'x'; break;
                            // Grayson p. 177-178, 202: Dental sibilants (–∑, —Å)
                            // –∑ ‚Üí s when word-final
                            case '–∑': ipa += shouldDevoice ? 's' : 'z'; break;
                            case '—Å': ipa += 's'; break;
                            // Grayson p. 162-165, 202: Hard hushers (–∂, —à) - always hard
                            // –∂ ‚Üí  É when word-final (NOT  í ‚Üí  É ≤, stays unpalatalized)
                            case '–∂': ipa += shouldDevoice ? ' É' : ' í'; break;
                            case '—à': ipa += ' É'; break;
                            // Grayson p. 166-168: —Ü - always hard (except —Ü–≤–µ—Ç derivatives)
                            case '—Ü': ipa += 'ts'; break;
                            // Grayson p. 169: —á is inherently palatalized /t É ≤/
                            case '—á': ipa += 't É ≤'; break;
                            // Grayson p. 171-173: —â is double palatalized / É ≤ É ≤/ (NOT  Ét É)
                            case '—â': ipa += ' É ≤ É ≤'; break;
                            case '–ª':
                                // Grayson p. 184: Hard –ª ‚Üí /…´/ (velarized), Soft –ª ‚Üí /l ≤/
                                // Check both direct and regressive palatalization
                                const lIsPalatalized = palatalizationMap.get(wordCharIdx) ||
                                    nextChar === '—å' || 
                                    (isInterpalatal(char, nextChar) && !['–∂', '—à', '—Ü', '—á', '—â'].includes(char));
                                if (lIsPalatalized) {
                                    ipa += 'l ≤';
                                } else {
                                    ipa += '…´';
                                }
                                break;
                            // Grayson p. 185: –º palatalization
                            case '–º': ipa += 'm'; break;
                            case '–Ω': 
                            // Grayson p. 186: Soft –Ω ‚Üí /…≤/ (palatal nasal, NOT n ≤)
                            // "The single IPA symbol incorporates palatalization"
                            // "The single IPA symbol incorporates palatalization"
                            // Check both direct and regressive palatalization
                            const nIsPalatalized = palatalizationMap.get(wordCharIdx) || 
                                nextChar === '—å' || 
                                (isInterpalatal(char, nextChar) && !['–∂', '—à', '—Ü', '—á', '—â'].includes(char));
                            if (nIsPalatalized) {
                                ipa += '…≤';
                            } else {
                                ipa += 'n';
                            }
                            break;
                        // Grayson p. 190: —Ä is difficult to palatalize for Anglophones
                        // Grayson p. 209 fn. 277: —Ä palatalizes after stressed –∏, –µ, —ç
                        case '—Ä': 
                            // Grayson p. 209, fn. 277: —Ä palatalizes after stressed –∏, –µ, —ç
                            // BUT only when followed by a consonant cluster, NOT word-finally
                            // Examples: —Å–º–µ—Ä—Ç—å /s ≤m ≤er ≤t ≤/, —Ç–µ—Ä–ø–µ—Ç—å /t ≤ir ≤ Ààp ≤et ≤/, –∫–∏—Ä–ø–∏—á /k ≤ir ≤ Ààp ≤it É ≤/
                            // Counter-example: –º–∏—Ä /m ≤ir/ (word-final, no cluster)
                            const rIsPalatalized = palatalizationMap.get(wordCharIdx) ||
                                nextChar === '—å';
                            
                            // Check for stressed front vowel + following cluster condition
                            const prevCharForR = chars[i - 1];
                            const frontVowels = ['–∏', '–µ', '—ç'];
                            const hasFollowingCluster = nextChar && isConsonant(nextChar) && nextChar !== '—å';
                            const afterStressedFrontVowel = position === 'stressed' && 
                                frontVowels.includes(prevCharForR) &&
                                hasFollowingCluster;  // MUST have following cluster
                            
                            if (rIsPalatalized || afterStressedFrontVowel) {
                                ipa += 'r ≤';
                            } else {
                                ipa += 'r';
                            }
                            break;
                        case '–π': ipa += 'j'; break;
                        }
                    } // Close the else block for voicingChange check

                    // Grayson p. 169-170, 195-198: Add palatalization marker
                    // Triggered by: —å, palatalizing vowels (–µ, —ë, –∏, —é, —è), or regressive palatalization
                    // 
                    // Grayson p. 206: "a consonant that is generally not palatalized, as 
                    // represented by the letters, -—à-, -–∂-, or -—Ü-"
                    // These consonants do NOT palatalize even when followed by —å.
                    // Example: –º—ã—à—å /m…® É/ (mouse), –≤–∏–¥–∏—à—å /Ààv ≤id ≤i É/ (you see)
                    //
                    // Exceptions: —á, —â already inherently palatalized
                    // Note: Don't add palatalization if we already used voicingChange IPA
                    // (voicingChange.ipa already includes palatalization where needed)
                    
                    // –∂, —à, —Ü NEVER palatalize, even with —å (Grayson p. 206)
                    const neverPalatalize = ['–∂', '—à', '—Ü'];
                    
                    // Check if this consonant should be palatalized (direct OR regressive)
                    const shouldPalatalize = !neverPalatalize.includes(char) && (
                        palatalizationMap.get(wordCharIdx) ||
                        nextChar === '—å' || 
                        isInterpalatal(char, nextChar)
                    );
                    
                    if (shouldPalatalize && !voicingChange) {
                        if (!['–π', '—á', '—â', '–Ω', '–ª', '—Ä'].includes(char)) { // –π, —á, —â already palatal; –Ω uses …≤; –ª, —Ä handled separately
                            ipa += ' ≤';
                        }
                    }
                    
                    // Handle voicing change with palatalization
                    // If voicingChange was applied, we need to add palatalization marker if needed
                    if (voicingChange && shouldPalatalize) {
                        // The voicingChange.ipa is the base sound; add  ≤ if needed
                        // Exception: —á‚Üíd í ≤ already includes palatalization
                        if (!voicingChange.ipa.includes(' ≤') && !['–Ω'].includes(char)) {
                            ipa += ' ≤';
                        }
                    }

                    // Mark geminate with length marker
                    if (isGeminate && !['–∂', '—à', '—â', '—á'].includes(char)) {
                        ipa += 'Àê';
                        i++; // Skip next char
                    }
                    // Also mark cross-syllable geminates (this char is last of syllable, next syllable starts with same)
                    else if (crossSyllableGeminates.has(wordCharIdx) && !['–∂', '—à', '—â', '—á'].includes(char)) {
                        ipa += 'Àê';
                        // Don't skip - the next char is in the next syllable (and will be skipped there)
                    }
                }
                // Vowels
                else if (isVowel(char)) {
                    // Check if preceded by consonant for context
                    const prevIsVowel = isVowel(prevChar);
                    const prevIsConsonant = isConsonant(prevChar);
                    const afterInterpalatal = prevIsConsonant && isInterpalatal(prevChar, char);

                    switch (char) {
                        case '–∞':
                            // Grayson p. 266: "the letter -–∞- is read as /…ë/ in all positions except 
                            // for the remote-pre- or post-stress, when not the initial letter or 
                            // the adjectival, feminine ending -–∞—è (always /…ë j…ë/, in Russian lyric diction)."
                            //
                            // The -–∞—è ending applies to feminine adjectives like:
                            // - –∫—Ä–∞—Å–∏–≤–∞—è, –≥–æ–ª—É–±–∞—è, –≤–æ–ª—à–µ–±–Ω–∞—è, –∫–æ–ª—ã–±–µ–ª—å–Ω–∞—è
                            // The pattern is: any consonant + –∞—è at word end
                            //
                            // Must use FULL WORD context, not just syllable
                            const wordCharsA = Array.from(wordContext.word.toLowerCase());
                            const wordCharIdxA = syllableStartInWord + i;
                            const nextCharInWordA = wordCharsA[wordCharIdxA + 1];
                            const nextNextCharInWordA = wordCharsA[wordCharIdxA + 2];
                            
                            // Grayson p. 266: "-–∞—è (always /…ë j…ë/, in Russian lyric diction)"
                            // Check if this –∞ is part of feminine adjectival ending:
                            // - This –∞ followed by —è at word end (standard -–∞—è)
                            // - OR this –∞ IS the final –∞ in -–Ω–∞—è/-—è–∞—è/-–ª–∞—è etc. pattern
                            //   (where —è follows this –∞ and is word-final)
                            const isAyaEndingA = nextCharInWordA === '—è' && 
                                (wordCharIdxA + 2 === wordCharsA.length || // —è is last char
                                 (wordCharIdxA + 2 === wordCharsA.length - 1 && wordCharsA[wordCharIdxA + 2] === '—å'));
                            
                            const beforePalatalA = isPalatalizingAgent(nextCharInWordA, nextNextCharInWordA);
                            const inInterpalatalA = afterInterpalatal && beforePalatalA;
                            
                            if (position === 'stressed') {
                                // Grayson p. 266: -–∞—è ending exception ‚Üí always /…ë/
                                if (isAyaEndingA) {
                                    ipa += '…ë';
                                } else {
                                    // Grayson p. 104: [a] only interpalatally; otherwise […ë]
                                    ipa += inInterpalatalA ? 'a' : '…ë';
                                }
                            } else if (position === 'pretonic-immediate') {
                                // Grayson p. 127: unstressed –∞ in immediate pretonic ‚Üí […ë]
                                ipa += inInterpalatalA ? 'a' : '…ë';
                            } else if (position === 'posttonic-immediate') {
                                // Grayson p. 266 footnote 306: "This guide suggests that -–∞- in 
                                // the immediate-post-stress position be read as /…ë/ in order to 
                                // aurally differentiate from words that have the letter -–æ- in 
                                // the same position."
                                // Example: –±–ª—é–¥a /Ààbl ≤u d…ë/ (platters) vs –±–ª—é–¥–æ /Ààbl ≤u d å/ (a platter)
                                ipa += '…ë';
                            } else if (!lockedSyllables.has(position)) {
                                // Grayson p. 266: -–∞—è ending exception ‚Üí always /…ë/ even in remote post-tonic
                                // This overrides the normal remote reduction to [ å] or […™]
                                if (isAyaEndingA) {
                                    ipa += '…ë';
                                } else {
                                    // Grayson p. 266: remote positions (not initial) ‚Üí [ å]
                                    // Note: interpalatal […™] only applies when BETWEEN two palatalizing
                                    // agents, not just after one. Remote unstressed –∞ ‚Üí  å.
                                    ipa += ' å';
                                }
                            } else {
                                // Locked syllable: use full vowel quality
                                ipa += inInterpalatalA ? 'a' : '…ë';
                            }
                            break;

                        case '–æ':
                            // Grayson p. 86: "stressed /o/ will be transcribed simply as /o/"
                            if (position === 'stressed') {
                                ipa += 'o';
                            } else if (position === 'pretonic-immediate') {
                                // Grayson p. 127: Akanye - unstressed –æ ‚Üí […ë] in immediate pretonic
                                ipa += '…ë';
                            } else if (position === 'posttonic-immediate') {
                                // Grayson p. 97: immediate posttonic –æ ‚Üí [ å]
                                // (Unlike –∞ which stays …ë, –æ reduces to  å)
                                ipa += ' å';
                            } else if (!lockedSyllables.has(position)) {
                                // Grayson p. 127: remote positions ‚Üí [ å]
                                // EXCEPTION: Word-initial –æ ‚Üí […ë] (same as immediate pretonic)
                                // Grayson p. 97 treats word-initial as a special case
                                const wordCharIdxO = syllableStartInWord + i;
                                const isCliticWord = wordContext.isClitic || false;
                                if (wordCharIdxO === 0 || isCliticWord) {
                                    // Word-initial OR standalone clitic (–≤–æ, –∫–æ, —Å–æ)
                                    // Clitics function as immediate pretonic to host word
                                    // MSR extension: singable /…ë/ preferred (p.97 parallel)
                                    ipa += '…ë';
                                } else {
                                    ipa += ' å';
                                }
                            } else {
                                // Locked syllable: use full vowel quality
                                ipa += 'o';
                            }
                            break;

                        case '–µ':
                        case '—ë':
                            // Grayson p. 106: –µ/—ë after vowel, —ä, —å, or word-initial ‚Üí j + vowel
                            if (prevIsVowel || prevChar === '—ä' || prevChar === '—å' || i === 0) {
                                ipa += 'j';
                            }
                            
                            // Check for interpalatal context (between two palatalizing agents)
                            // Must use FULL WORD context, not just syllable
                            const wordChars = Array.from(wordContext.word.toLowerCase());
                            const wordCharIdxE = syllableStartInWord + i;
                            const nextCharInWord = wordChars[wordCharIdxE + 1];
                            const nextNextCharInWord = wordChars[wordCharIdxE + 2];
                            
                            // Left side: previous char must be a palatalizing agent
                            // Right side: next char must be a palatalizing agent
                            const leftIsPalatalizing = afterInterpalatal || 
                                (prevIsVowel && ['–∏', '–µ', '—ë', '—é', '—è'].includes(prevChar)) ||
                                prevChar === '—å' || prevChar === '–π' ||
                                (i === 0 && wordCharIdxE === 0); // word-initial –µ gets j, which counts as palatalizing
                            const rightIsPalatalizing = isPalatalizingAgent(nextCharInWord, nextNextCharInWord);
                            const inInterpalatal = leftIsPalatalizing && rightIsPalatalizing;
                            
                            if (position === 'stressed') {
                                // Grayson p. 85-86: —ë is always stressed /o/
                                if (char === '—ë') {
                                    ipa += 'o';
                                } else if (inInterpalatal) {
                                    // Grayson p. 106: [e] when interpalatal
                                    ipa += 'e';
                                } else {
                                    // Grayson p. 106: default stressed –µ ‚Üí […õ]
                                    ipa += '…õ';
                                }
                            } else if (position === 'pretonic-immediate') {
                                // Grayson p. 127: Ikanye - unstressed –µ ‚Üí […™]
                                // But interpalatal ‚Üí [i]
                                if (inInterpalatal) {
                                    ipa += 'i';
                                } else {
                                    ipa += '…™';
                                }
                            } else if (!lockedSyllables.has(position)) {
                                // Grayson p. 125: "The allophone is […™]... and it fronts to 
                                // the /i/-phoneme when interpalatal."
                                if (inInterpalatal) {
                                    ipa += 'i';
                                } else {
                                    ipa += '…™';
                                }
                            } else {
                                // Locked syllable: use full vowel quality
                                ipa += inInterpalatal ? 'e' : '…õ';
                            }
                            break;

                        case '—è':
                            // Check if this —è is part of -—Ç—Å—è/-–¥—Å—è/-—Ç—å—Å—è/-–¥—å—Å—è ending
                            // Those clusters include the vowel in their IPA output (tÀês å)
                            // so we must skip processing this —è to avoid double output
                            const wordCharsYaCheck = Array.from(wordContext.word.toLowerCase());
                            const wordCharIdxYaCheck = syllableStartInWord + i;
                            const prevCharYaCheck = wordCharsYaCheck[wordCharIdxYaCheck - 1];
                            const prevPrevCharYaCheck = wordCharsYaCheck[wordCharIdxYaCheck - 2];
                            const prevPrevPrevCharYaCheck = wordCharsYaCheck[wordCharIdxYaCheck - 3];
                            
                            // Check for -—Ç—Å—è/-–¥—Å—è pattern (—Å preceded by —Ç or –¥)
                            const isPartOfTsyaCluster = prevCharYaCheck === '—Å' && 
                                (prevPrevCharYaCheck === '—Ç' || prevPrevCharYaCheck === '–¥' ||
                                 (prevPrevCharYaCheck === '—å' && (prevPrevPrevCharYaCheck === '—Ç' || prevPrevPrevCharYaCheck === '–¥')));
                            
                            if (isPartOfTsyaCluster) {
                                // Skip this —è - it was already included in the tÀês å cluster output
                                break;
                            }
                            
                            // Grayson p. 104: —è after vowel, —ä, —å, or word-initial ‚Üí j + vowel
                            if (prevIsVowel || prevChar === '—ä' || prevChar === '—å' || i === 0) {
                                ipa += 'j';
                            }
                            // Grayson p. 104: "—è only in the stressed syllable, when preceded 
                            // by a palatalized consonant, and only when followed by a 
                            // palatalized consonant or /j/ (spelled -–π-)."
                            // Must use FULL WORD context, not just syllable
                            const wordCharsYa = Array.from(wordContext.word.toLowerCase());
                            const wordCharIdxYa = syllableStartInWord + i;
                            const nextCharInWordYa = wordCharsYa[wordCharIdxYa + 1];
                            const nextNextCharInWordYa = wordCharsYa[wordCharIdxYa + 2];
                            const prevCharInWordYa = wordCharsYa[wordCharIdxYa - 1];
                            
                            const beforePalatalYa = isPalatalizingAgent(nextCharInWordYa, nextNextCharInWordYa);
                            const inInterpalatalYa = afterInterpalatal && beforePalatalYa;
                            
                            // Grayson p. 266: "-–∞—è (always /…ë j…ë/, in Russian lyric diction)"
                            // This is a special exception for feminine adjectival endings
                            // Check using WORD context, not syllable
                            const isAyaEnding = prevCharInWordYa === '–∞' && 
                                (wordCharIdxYa === wordCharsYa.length - 1 || 
                                 (wordCharIdxYa === wordCharsYa.length - 2 && wordCharsYa[wordCharIdxYa + 1] === '—å'));
                            
                            // Grayson p. 266-267: "except in the reflexive verbal endings -—Ç—å—Å—è 
                            // and -—Ç—Å—è, when it is read as [ å]"
                            // This applies to all reflexive -—Å—è/-—Å—å endings (—è preceded by —Å)
                            // BUT NOT if preceded by —Ç—Å/–¥—Å ‚Äî those are handled by cluster rule
                            // Examples: —Å–∂–∞–ª—å—Å—è, –±–æ–π—Å—è (NOT –∫—É–ø–∞—Ç—å—Å—è, –±–æ–∏—Ç—Å—è)
                            const isReflexiveEnding = prevCharInWordYa === '—Å' && 
                                (wordCharIdxYa === wordCharsYa.length - 1 || 
                                 (wordCharIdxYa === wordCharsYa.length - 2 && wordCharsYa[wordCharIdxYa + 1] === '—å'));
                            
                            if (position === 'stressed') {
                                // Grayson p. 104: [a] only interpalatally; otherwise […ë]
                                ipa += inInterpalatalYa ? 'a' : '…ë';
                            } else if (position === 'pretonic-immediate') {
                                // Grayson p. 127: immediate pretonic after palatalized
                                ipa += inInterpalatalYa ? 'a' : '…ë';
                            } else if (!lockedSyllables.has(position)) {
                                // Grayson p. 266: -–∞—è ending exception ‚Üí always /…ë/
                                if (isAyaEnding) {
                                    ipa += '…ë';
                                } else if (isReflexiveEnding) {
                                    // Grayson p. 266-267: reflexive -—Å—è/-—Å—å ‚Üí [ å]
                                    ipa += ' å';
                                } else if (position === 'posttonic-immediate' && wordCharIdxYa === wordCharsYa.length - 1) {
                                    // MSR extension (pending Grayson clarification):
                                    // Word-final posttonic —è ‚Üí /…ë/ (parallels posttonic –∞ pattern)
                                    // Examples: –Ω—è–Ω—è, –í–∞–Ω—è, –°–æ–Ω—è
                                    // See TODO-grayson-questions.md #1
                                    ipa += '…ë';
                                } else {
                                    // Grayson p. 127: Ikanye - unstressed —è after palatalized ‚Üí […™]
                                    // Remote after non-palatalized ‚Üí [ å]
                                    ipa += afterInterpalatal ? '…™' : ' å';
                                }
                            } else {
                                // Locked syllable: use full vowel quality
                                ipa += inInterpalatalYa ? 'a' : '…ë';
                            }
                            break;

                        case '—é':
                            // Grayson p. 104: —é after vowel, —ä, —å, or word-initial ‚Üí j + vowel
                            if (prevIsVowel || prevChar === '—ä' || prevChar === '—å' || i === 0) {
                                ipa += 'j';
                            }
                            // Grayson: —É/—é never reduce - always /u/ (see vowels_unstressed inventory)
                            ipa += 'u';
                            break;

                        case '–∏':
                            // Grayson p. 96: "neither syllabic stress nor position affects 
                            // the reading as /i/, in sung Russian"
                            // EXCEPT: After always-hard consonants –∂, —à, —Ü, the spelling –∏
                            // represents […®] ‚Äî the tongue position of these consonants is
                            // physically incompatible with cardinal [i]
                            const alwaysHardConsonants = ['–∂', '—à', '—Ü'];
                            if (prevIsConsonant && alwaysHardConsonants.includes(prevChar?.toLowerCase())) {
                                ipa += '…®';
                            } else {
                                ipa += 'i';
                            }
                            break;

                        case '—ã':
                            // Grayson p. 89-90: —ã ‚Üí […®] (close central unrounded)
                            // Note: unstressed may be slightly lowered […®Ãû] but Grayson
                            // does not require this distinction for lyric diction
                            ipa += '…®';
                            break;

                        case '—É':
                            // Grayson inventory: —É never reduces - always /u/
                            // (unlike –æ which reduces via akanye)
                            ipa += 'u';
                            break;

                        case '—ç':
                            // Grayson p. 106-107: stressed —ç ‚Üí […õ] (or [e] if followed by palatalized)
                            // Grayson p. 127: unstressed —ç ‚Üí […™] (ikanye)
                            if (position === 'stressed') {
                                ipa += '…õ';
                            } else if (!lockedSyllables.has(position)) {
                                ipa += '…™';
                            } else {
                                // Locked syllable: use full vowel quality
                                ipa += '…õ';
                            }
                            break;
                    }
                }
            }

            return ipa;
        }

        // Process a word with stress information
        function processWord(word, stressIndex = -1, options = {}) {
            const { isClitic = false } = options;
            const normalized = normalizeText(word);
            
            // Check for exception words with complete IPA override
            // BUT only use exception IPA if stress is NOT being overridden by user
            const exception = checkExceptionWord(normalized);
            console.log('[processWord] word:', normalized, 'stressIndex:', stressIndex, 'exception:', exception ? exception.stressIndex : 'none');
            if (exception && (stressIndex === -1 || stressIndex === exception.stressIndex)) {
                console.log('[processWord] Using exception IPA');
                // Use exception's pre-computed IPA (stress matches dictionary or not specified)
                const syllableIPAs = exception.ipa.split('.');
                const syllables = syllabify(normalized);
                
                // Use passed stressIndex if provided, otherwise use exception's default
                const effectiveStress = (stressIndex !== -1) ? stressIndex : exception.stressIndex;
                
                return {
                    word: normalized,
                    syllables: syllableIPAs.map((ipa, idx) => ({
                        cyrillic: syllables[idx] || '',
                        ipa: ipa,
                        isStressed: idx === effectiveStress,
                        showStressMarker: idx === effectiveStress && syllableIPAs.length > 1
                    })),
                    stressIndex: effectiveStress,
                    originalStressIndex: stressIndex,
                    isMonosyllable: syllableIPAs.length === 1,
                    showStressMarker: syllableIPAs.length > 1,
                    isException: true,
                    exceptionRule: exception.rule || null
                };
            }
            console.log('[processWord] Using normal transcription (user override or no exception)');
            // If user overrides stress on exception word, fall through to normal processing
            // so vowel reduction recalculates based on new stress position
            
            const syllables = syllabify(normalized);
            const vowelCount = countVowels(normalized);
            
            // Detect cross-syllable geminates (e.g., –≥—Ä—É–ø|–ø–∞ where –ø–ø spans boundary)
            // Build a set of character indices that are part of cross-syllable geminates
            const crossSyllableGeminates = new Set();
            let charIdx = 0;
            for (let i = 0; i < syllables.length - 1; i++) {
                const currentSyl = syllables[i];
                const nextSyl = syllables[i + 1];
                const lastCharOfCurrent = currentSyl[currentSyl.length - 1]?.toLowerCase();
                const firstCharOfNext = nextSyl[0]?.toLowerCase();
                
                // Check for soft sign - if current ends in C—å, check the C
                let actualLastChar = lastCharOfCurrent;
                let lastCharIdx = charIdx + currentSyl.length - 1;
                if (lastCharOfCurrent === '—å' && currentSyl.length >= 2) {
                    actualLastChar = currentSyl[currentSyl.length - 2]?.toLowerCase();
                    lastCharIdx = charIdx + currentSyl.length - 2;
                }
                
                if (actualLastChar && firstCharOfNext && 
                    isConsonant(actualLastChar) && actualLastChar === firstCharOfNext) {
                    // Mark both positions as cross-syllable geminate
                    crossSyllableGeminates.add(lastCharIdx); // Last C of current syllable (gets Àê)
                    crossSyllableGeminates.add(charIdx + currentSyl.length); // First C of next syllable (skip)
                }
                
                charIdx += currentSyl.length;
            }

            // Grayson rule: Monosyllabic words don't show stress MARKER (Àà)
            // BUT the vowel still has STRESSED QUALITY (no reduction)
            // So we track two things:
            // 1. effectiveStressIndex: which syllable gets stressed vowel quality
            // 2. showStressMarker: whether to display Àà
            const isMonosyllable = vowelCount === 1;
            const showStressMarker = !isMonosyllable;
            
            // For monosyllables, vowel quality is always stressed (index 0)
            // UNLESS stressIndex is explicitly -1 (clitic/unstressed word)
            // For polysyllables, use provided stress or -1 if unknown
            const effectiveStressIndex = isMonosyllable && stressIndex !== -1 ? 0 : stressIndex;
            
            // Compute voicing assimilation for the entire word (Grayson Ch. 6)
            const voicingMap = analyzeVoicingAssimilation(normalized);
            
            // Compute regressive palatalization for the entire word (Grayson Ch. 5)
            const palatalizationMap = analyzeRegressivePalatalization(normalized);
            
            // Track character position as we process syllables
            let charPosition = 0;

            const transcribedSyllables = syllables.map((syl, idx) => {
                const position = getSyllablePosition(idx, effectiveStressIndex, syllables.length);
                const isLastSyllable = idx === syllables.length - 1;
                const syllableStartInWord = charPosition;
                
                const ipa = transcribeSyllable(syl, position, { 
                    word: normalized, 
                    syllables, 
                    isLastSyllable,
                    voicingMap,
                    palatalizationMap,
                    syllableStartInWord,
                    crossSyllableGeminates,
                    isClitic  // Pass clitic flag for vowel handling
                });
                
                // Update character position for next syllable
                charPosition += syl.length;
                
                return {
                    cyrillic: syl,
                    ipa: ipa,
                    isStressed: idx === effectiveStressIndex,
                    showStressMarker: showStressMarker && idx === effectiveStressIndex
                };
            });

            return {
                word: normalized,
                syllables: transcribedSyllables,
                stressIndex: effectiveStressIndex,
                originalStressIndex: stressIndex,
                isMonosyllable: isMonosyllable,
                showStressMarker: showStressMarker
            };
        }

        // Main text processing function
        function processText() {
            const input = document.getElementById('russianInput').value;
            
            // Split into lines first, preserving structure
            const inputLines = input.split(/\n/);
            
            // === CLITIC MERGING ===
            // Proclitics (vowelless prepositions + particles): attach to FOLLOWING word
            // Grayson p. 263: –Ω–µ and –Ω–∏ are particles, treated as unstressed
            const proclitics = new Set(['–≤', '–∫', '—Å', '–±']);  // Vowelless prepositions only ‚Äî attach forward
            const enclitics = new Set(['–ª–∏', '–ª—å', '–∂–µ', '–∂', '–±—ã', '–±']);  // Particles, attach backward
            
            // Helper: check if string contains any Cyrillic letters
            const hasCyrillic = (str) => /[–∞-—è—ë–ê-–Ø–Å]/.test(str);
            
            // Helper: normalize Unicode (handle combining characters)
            const normalizeUnicode = (str) => str.normalize('NFC');
            
            // Helper: strip ALL punctuation from word except hyphens
            // Returns [cleanWord, strippedPunctuation]
            const stripPunctuation = (str) => {
                // First strip trailing punctuation (not hyphens)
                const trailingMatch = str.match(/^(.+?)([.,!?;:¬ª¬´"'‚Äî‚Äì‚Ä¶]+)$/);
                let word = trailingMatch ? trailingMatch[1] : str;
                let trailing = trailingMatch ? trailingMatch[2] : '';
                
                // Also strip leading punctuation (not hyphens)
                const leadingMatch = word.match(/^([.,!?;:¬ª¬´"'‚Äî‚Äì‚Ä¶]+)(.+)$/);
                if (leadingMatch) {
                    word = leadingMatch[2];
                }
                
                return [word, trailing];
            };
            
            // Process each line separately, marking line breaks
            const allMergedWords = [];
            
            inputLines.forEach((line, lineIndex) => {
                const rawWords = line.split(/\s+/).filter(w => w.length > 0 && hasCyrillic(w));
                if (rawWords.length === 0) return; // Skip empty lines or punctuation-only lines
                
                let i = 0;
                while (i < rawWords.length) {
                    let word = rawWords[i];
                    const [cleanWord, trailingPunct] = stripPunctuation(word);
                    const lowerWord = normalizeUnicode(cleanWord).toLowerCase();
                    
                    // Check if this is the last word (accounting for enclitics)
                    let isLastWordInLine = (i >= rawWords.length - 1);
                    if (i === rawWords.length - 2) {
                        const [nextClean, nextPunct] = stripPunctuation(rawWords[i + 1]);
                        const nextNormalized = normalizeUnicode(nextClean).toLowerCase();
                        if (enclitics.has(nextNormalized)) {
                            isLastWordInLine = true;
                        }
                    }
                    
                    // Check if this is a proclitic (attach to next word)
                    if (proclitics.has(lowerWord) && i + 1 < rawWords.length) {
                        const nextWord = rawWords[i + 1];
                        const [cleanNextWord, nextPunct] = stripPunctuation(nextWord);
                        const isLastMerged = i + 1 >= rawWords.length - 1;
                        allMergedWords.push({
                            combined: word + ' ' + nextWord,
                            parts: [{ text: cleanWord, type: 'proclitic' }, { text: cleanNextWord, type: 'main' }],
                            trailingPunctuation: nextPunct,
                            lineBreakAfter: isLastMerged,
                            lineIndex: lineIndex
                        });
                        i += 2;
                        continue;
                    }
                    
                    // Check if NEXT word is an enclitic (attach to this word)
                    if (i + 1 < rawWords.length) {
                        const nextWordRaw = rawWords[i + 1];
                        const [cleanNext, punct] = stripPunctuation(nextWordRaw);
                        const normalizedNext = normalizeUnicode(cleanNext).toLowerCase();
                        
                        if (enclitics.has(normalizedNext)) {
                            const isLastMerged = i + 1 >= rawWords.length - 1;
                            // Strip punctuation from enclitic for processing, store punct separately
                            const [cleanEnclitic, encliticPunct] = stripPunctuation(nextWordRaw);
                            allMergedWords.push({
                                combined: word + ' ' + nextWordRaw,
                                parts: [{ text: cleanWord, type: 'main' }, { text: cleanEnclitic, type: 'enclitic' }],
                                trailingPunctuation: encliticPunct || trailingPunct,
                                lineBreakAfter: isLastMerged,  // Only break if this is actually the last word in the line
                                lineIndex: lineIndex
                            });
                            i += 2;
                            continue;
                        }
                    }
                    
                    // Regular word - strip punctuation for processing
                    allMergedWords.push({
                        combined: word,
                        parts: [{ text: cleanWord, type: 'main' }],
                        trailingPunctuation: trailingPunct,
                        lineBreakAfter: isLastWordInLine,
                        lineIndex: lineIndex
                    });
                    i++;
                }
            });

            processedWords = allMergedWords.map(mergedWord => {
                const word = mergedWord.combined;
                const hasMergedParts = mergedWord.parts.length > 1;  // Has proclitic or enclitic attached
                
                // Check if this word itself is a standalone clitic (inherently unstressed)
                const standaloneWord = mergedWord.parts.length === 1 ? mergedWord.parts[0].text.toLowerCase() : null;
                const isStandaloneClitic = standaloneWord && clitics.has(normalizeUnicode(standaloneWord).toLowerCase());
                
                // For merged words, we need to process each part separately then combine
                // But for now, process as a unit and let the main word carry stress
                
                // Find the main word part for dictionary lookup
                const mainPart = mergedWord.parts.find(p => p.type === 'main');
                const mainWord = mainPart ? mainPart.text : word;
                
                // Normalize and lowercase for lookups (use main word, not clitic)
                let normalizedWord = normalizeText(mainWord);
                const lowerWord = normalizedWord.toLowerCase();
                
                // CHECK EXCEPTION DICTIONARY (Chapter 8)
                // Two types of exceptions:
                // 1. –µ‚Üí—ë: printed ‚ü®–µ‚ü© = actual ‚ü®—ë‚ü© (has actualForm property)
                // 2. Pure exceptions: words with irregular pronunciations (has exception property)
                let —ëException = null;
                let pureException = null;
                let wordToProcess = mainWord;
                
                if (–Å_EXCEPTION_DICTIONARY[lowerWord]) {
                    const entry = –Å_EXCEPTION_DICTIONARY[lowerWord];
                    
                    if (entry.actualForm) {
                        // Type 1: –µ‚Üí—ë substitution
                        —ëException = entry;
                        wordToProcess = entry.actualForm;
                    } else if (entry.exception) {
                        // Type 2: Pure pronunciation exception (no spelling change)
                        pureException = entry;
                        // Word stays the same, but we note the exception
                    }
                }
                
                // Look up stress in dictionary (returns syllable index or -1)
                let dictionaryStress = —ëException ? —ëException.stress : lookupStress(mainWord);
                let stressSource = dictionaryStress !== -1 ? 'dictionary' : 'none';
                
                // If from —ë-exception dictionary, mark it specially
                if (—ëException) {
                    stressSource = '—ë-exception';
                }
                
                // Also check EXCEPTION_WORDS for words with special IPA
                // These should be treated as dictionary words for stress source tracking
                const exceptionWord = typeof checkExceptionWord === 'function' ? checkExceptionWord(mainWord) : null;
                if (exceptionWord && dictionaryStress === -1) {
                    dictionaryStress = exceptionWord.stressIndex;
                    stressSource = 'dictionary';  // Exception words count as dictionary entries
                    console.log('[processText] Found exception word:', mainWord, 'stress:', dictionaryStress);
                }
                
                // RULE: —ë always takes stress (one of the few reliable Russian orthography rules)
                // If word contains —ë and we don't have dictionary stress, find the —ë syllable
                if (dictionaryStress === -1) {
                    const normalized = normalizeText(wordToProcess).toLowerCase();
                    const —ëIndex = normalized.indexOf('—ë');
                    if (—ëIndex !== -1) {
                        // Find which syllable contains the —ë
                        const syllables = syllabify(normalized);
                        let charPos = 0;
                        for (let sylIdx = 0; sylIdx < syllables.length; sylIdx++) {
                            const sylEnd = charPos + syllables[sylIdx].length;
                            if (—ëIndex >= charPos && —ëIndex < sylEnd) {
                                dictionaryStress = sylIdx;
                                stressSource = '—ë-rule';
                                break;
                            }
                            charPos = sylEnd;
                        }
                    }
                }
                
                // For merged words, adjust stress index to account for proclitic syllables
                let adjustedStress = dictionaryStress;
                if (dictionaryStress !== -1 && mergedWord.parts.length > 1) {
                    const procliticPart = mergedWord.parts.find(p => p.type === 'proclitic');
                    if (procliticPart) {
                        // Count syllables in the proclitic
                        const procliticSyllables = syllabify(procliticPart.text.toLowerCase()).length;
                        adjustedStress = dictionaryStress + procliticSyllables;
                    }
                }
                
                // PLACEHOLDER STRESS: Unknown words get temporary stress on syllable 1
                // This ensures every word is actionable immediately (no blank states)
                // Grey dotted circle signals "needs attention"
                // EXCEPTION: Standalone clitics are inherently unstressed ‚Äî no placeholder
                if (stressSource === 'none' && adjustedStress === -1 && !isStandaloneClitic) {
                    adjustedStress = 0;  // Syllable 1
                    stressSource = 'placeholder';
                }
                
                // Standalone clitics: force unstressed (no stress index)
                if (isStandaloneClitic) {
                    adjustedStress = -1;
                    stressSource = 'clitic';  // Special source to indicate inherently unstressed
                }
                
                // Build the combined word for processing (remove spaces)
                const combinedWord = mergedWord.parts.map(p => p.text).join('');
                
                return {
                    originalWord: word,
                    displayWord: word,  // Keep spaces for display
                    // Store the corrected form (with —ë) for reprocessing
                    correctedWord: —ëException ? —ëException.actualForm : mainWord,
                    // Process the full combined word with adjusted stress
                    processed: processWord(combinedWord, adjustedStress, { isClitic: isStandaloneClitic }),
                    isClitic: hasMergedParts,
                    isStandaloneClitic: isStandaloneClitic,
                    mergedParts: mergedWord.parts,  // Track what was merged
                    trailingPunctuation: mergedWord.trailingPunctuation || '',  // Store punctuation separately
                    lineBreakAfter: mergedWord.lineBreakAfter,  // Preserve poetry line breaks
                    lineIndex: mergedWord.lineIndex,  // Track which line this word is from
                    stressSource: stressSource,  // Track where stress came from
                    —ëException: —ëException,  // Store –µ‚Üí—ë exception info for Why screen
                    pureException: pureException  // Store pure pronunciation exception info
                };
            });

            renderOutput();
        }

        // ============================================================================
        // STRESS SOURCE MODAL - User vs Composer attribution
        // ============================================================================
        
        let pendingStressChange = null;  // Stores {wordIndex, syllableIndex} while modal is open
        
        function showStressSourceModal(wordIndex, syllableIndex, wordText) {
            pendingStressChange = { wordIndex, syllableIndex };
            document.getElementById('stressSourceWord').textContent = wordText;
            document.getElementById('stressSourceModal').classList.add('show');
        }
        
        function closeStressSourceModal() {
            document.getElementById('stressSourceModal').classList.remove('show');
            pendingStressChange = null;
        }
        
        function confirmStressSource(source) {
            if (!pendingStressChange) return;
            
            const { wordIndex, syllableIndex } = pendingStressChange;
            closeStressSourceModal();
            
            // Now apply the stress change with the chosen source
            applyStressChange(wordIndex, syllableIndex, source);
        }

        // ============================================================================
        // CLICK HANDLING: Single-click for stress, Double-click for –µ‚Üî—ë
        // ============================================================================
        
        let clickTimer = null;
        let clickedWordIndex = null;
        let clickedSyllableIndex = null;
        const DOUBLE_CLICK_DELAY = 300; // ms
        
        function handleSyllableClick(wordIndex, syllableIndex) {
            
            // If this is a second click on the same syllable within the delay, it's a double-click
            if (clickTimer && clickedWordIndex === wordIndex && clickedSyllableIndex === syllableIndex) {
                clearTimeout(clickTimer);
                clickTimer = null;
                cycleYo(wordIndex, syllableIndex);
                return;
            }
            
            // Clear any existing timer
            if (clickTimer) {
                clearTimeout(clickTimer);
            }
            
            // Store click info
            clickedWordIndex = wordIndex;
            clickedSyllableIndex = syllableIndex;
            
            // Set timer for single-click action
            clickTimer = setTimeout(() => {
                clickTimer = null;
                toggleStress(wordIndex, syllableIndex);
            }, DOUBLE_CLICK_DELAY);
        }
        
        // Toggle stress on a syllable (called after single-click confirmed)
        function toggleStress(wordIndex, syllableIndex) {
            const wordData = processedWords[wordIndex];
            const currentStress = wordData.processed.stressIndex;
            
            console.log('[toggleStress] START:', {
                word: wordData.originalWord,
                currentStress,
                clickedSyllable: syllableIndex,
                stressSource: wordData.stressSource,
                originalDictionaryStress: wordData.originalDictionaryStress
            });
            
            // RULE: If word contains —ë, stress CANNOT be moved away from —ë syllable
            // —ë is always stressed in Russian; allowing unstressed —ë violates Grayson's schema
            if (wordData.stressSource === '—ë-rule') {
                showTooltip('The letter ‚ü®—ë‚ü© is always stressed in Russian.', wordIndex);
                return;
            }

            // Clicking same syllable does nothing (no toggle off)
            if (currentStress === syllableIndex) {
                // Exception: clicking placeholder confirms it
                if (wordData.stressSource === 'placeholder') {
                    showStressSourceModal(wordIndex, syllableIndex, wordData.originalWord);
                }
                return;
            }
            
            // Clicking a different syllable...
            const isOverridingDictionary = ['dictionary', 'wiktionary', '—ë-exception'].includes(wordData.stressSource);
            const isOverridingVerified = isOverridingDictionary || 
                (wordData.originalDictionaryStress !== undefined && syllableIndex !== wordData.originalDictionaryStress);
            
            if (isOverridingVerified) {
                // Show modal to ask: user choice or composer's score?
                // Save original dictionary stress before showing modal
                if (wordData.originalDictionaryStress === undefined) {
                    wordData.originalDictionaryStress = currentStress;
                }
                showStressSourceModal(wordIndex, syllableIndex, wordData.originalWord);
                return;
            }
            
            // For placeholder words or returning to dictionary stress, apply directly
            if (wordData.stressSource === 'placeholder') {
                showStressSourceModal(wordIndex, syllableIndex, wordData.originalWord);
                return;
            }
            
            // User/composer clicking different syllable ‚Äî show modal
            if (wordData.stressSource === 'user' || wordData.stressSource === 'composer') {
                showStressSourceModal(wordIndex, syllableIndex, wordData.originalWord);
                return;
            }
            
            // Default: apply change as user
            applyStressChange(wordIndex, syllableIndex, 'user');
        }
        
        // Apply the stress change after source is determined
        function applyStressChange(wordIndex, syllableIndex, source) {
            const wordData = processedWords[wordIndex];
            const currentStress = wordData.processed.stressIndex;
            
            console.log('[applyStressChange]', { wordIndex, syllableIndex, source });

            // Reprocess word with new stress (use correctedWord to preserve —ë)
            const wordToUse = wordData.correctedWord || wordData.originalWord;
            const oldIPA = wordData.processed.syllables.map(s => s.ipa).join('.');
            wordData.processed = processWord(wordToUse, syllableIndex);
            const newIPA = wordData.processed.syllables.map(s => s.ipa).join('.');
            console.log('[applyStressChange] IPA changed:', oldIPA, '->', newIPA);
            
            // Track original dictionary stress for comparison
            if (wordData.originalDictionaryStress === undefined && 
                ['dictionary', 'wiktionary', '—ë-exception'].includes(wordData.stressSource)) {
                wordData.originalDictionaryStress = currentStress;
            }
            
            // Update stressSource
            const oldSource = wordData.stressSource;
            if (wordData.originalDictionaryStress !== undefined && syllableIndex === wordData.originalDictionaryStress) {
                // User returned to dictionary stress
                wordData.stressSource = 'dictionary';
            } else {
                // Apply the chosen source (user or composer)
                wordData.stressSource = source;
            }
            console.log('[applyStressChange] stressSource:', oldSource, '->', wordData.stressSource);
            
            // Clear cached IPA editor state so it regenerates with new stress
            delete wordData.ipaEditorState;

            // Update BOTH views so changes propagate everywhere
            renderOutput();
            if (currentView === 'singers') {
                renderSingersView();
            }
        }
        
        // ============================================================================
        // DOUBLE-CLICK/TAP: Cycle –µ‚Üî—ë on stressed syllables
        // ============================================================================
        // When a syllable is already stressed and contains ‚ü®–µ‚ü©, double-clicking
        // converts it to ‚ü®—ë‚ü© (and vice versa). This handles the common case where
        // Russian text uses ‚ü®–µ‚ü© in place of ‚ü®—ë‚ü© (standard publishing practice).
        // ============================================================================
        
        function cycleYo(wordIndex, syllableIndex) {
            const wordData = processedWords[wordIndex];
            const processed = wordData.processed;
            
            // Only works on stressed syllable
            if (processed.stressIndex !== syllableIndex) {
                showTooltip('Stress this syllable first, then double-tap to change –µ‚Üî—ë', wordIndex);
                return;
            }
            
            // Get the syllable text
            const syllable = processed.syllables[syllableIndex];
            if (!syllable) return;
            
            const syllableText = syllable.cyrillic;
            
            // Check if syllable contains –µ or —ë
            const hasYe = syllableText.includes('–µ') || syllableText.includes('–ï');
            const hasYo = syllableText.includes('—ë') || syllableText.includes('–Å');
            
            if (!hasYe && !hasYo) {
                showTooltip('No ‚ü®–µ‚ü© or ‚ü®—ë‚ü© in this syllable', wordIndex);
                return;
            }
            
            // Get the current word form
            const currentWord = wordData.correctedWord || wordData.originalWord;
            let newWord;
            
            if (hasYo) {
                // —ë ‚Üí –µ (user is reverting)
                newWord = currentWord.replace(/—ë/g, '–µ').replace(/–Å/g, '–ï');
                wordData.correctedWord = newWord;
                wordData.stressSource = 'user';
                showTooltip('Changed ‚ü®—ë‚ü© ‚Üí ‚ü®–µ‚ü©', wordIndex);
            } else {
                // –µ ‚Üí —ë (user is correcting hidden —ë)
                // Only convert the –µ in the stressed syllable, not all –µ's in the word
                newWord = convertStressedYeToYo(currentWord, syllableIndex);
                wordData.correctedWord = newWord;
                wordData.stressSource = '—ë-rule';
                showTooltip('Changed ‚ü®–µ‚ü© ‚Üí ‚ü®—ë‚ü©', wordIndex);
            }
            
            // Reprocess with the corrected word
            wordData.processed = processWord(newWord, processed.stressIndex);
            
            // Clear cached IPA editor state
            delete wordData.ipaEditorState;
            
            // Update views
            renderOutput();
            if (currentView === 'singers') {
                renderSingersView();
            }
        }
        
        /**
         * Convert ‚ü®–µ‚ü© to ‚ü®—ë‚ü© only in the stressed syllable
         */
        function convertStressedYeToYo(word, stressedSyllableIndex) {
            // Syllabify to find which characters belong to stressed syllable
            const syllables = syllabify(word.toLowerCase());
            if (stressedSyllableIndex >= syllables.length) return word;
            
            const stressedSyllable = syllables[stressedSyllableIndex];
            
            // Find the position of this syllable in the original word
            let pos = 0;
            for (let i = 0; i < stressedSyllableIndex; i++) {
                pos += syllables[i].length;
            }
            
            // Convert –µ‚Üí—ë within this syllable range
            const chars = Array.from(word);
            for (let i = pos; i < pos + stressedSyllable.length && i < chars.length; i++) {
                if (chars[i] === '–µ') chars[i] = '—ë';
                if (chars[i] === '–ï') chars[i] = '–Å';
            }
            
            return chars.join('');
        }
        
        // Show a temporary tooltip near a word card
        function showTooltip(message, wordIndex) {
            // Remove any existing tooltip
            const existing = document.querySelector('.msr-tooltip');
            if (existing) existing.remove();
            
            const card = document.getElementById(`card-${wordIndex}`);
            if (!card) return;
            
            const tooltip = document.createElement('div');
            tooltip.className = 'msr-tooltip';
            tooltip.textContent = message;
            
            // Position near the card
            const rect = card.getBoundingClientRect();
            tooltip.style.position = 'fixed';
            tooltip.style.left = `${rect.left + rect.width / 2}px`;
            tooltip.style.top = `${rect.bottom + 8}px`;
            tooltip.style.transform = 'translateX(-50%)';
            
            document.body.appendChild(tooltip);
            
            // Fade out and remove after 2.5 seconds
            setTimeout(() => {
                tooltip.style.opacity = '0';
                setTimeout(() => tooltip.remove(), 300);
            }, 2500);
        }
        
        // ============================================================================
        // ONLINE STRESS VERIFICATION (Wiktionary Integration)
        // ============================================================================
        // When user clicks the person+X icon, we query Wiktionary for the correct
        // stress. This requires network access, so we ask for permission first.
        // 
        // Flow:
        // 1. Check localStorage for permission ('msr_online_lookup')
        // 2. If no permission, show one-time prompt
        // 3. If permitted, query Wiktionary API
        // 4. Compare result to user's stress assignment
        // 5. Update icon: match ‚Üí üìñ‚úì, mismatch ‚Üí üë§‚ö†Ô∏è, not found ‚Üí üë§‚úé
        // ============================================================================
        
        // Permission states: 'allowed', 'denied', or null (not yet asked)
        function getOnlineLookupPermission() {
            return localStorage.getItem('msr_online_lookup');
        }
        
        function setOnlineLookupPermission(value) {
            localStorage.setItem('msr_online_lookup', value);
        }
        
        /**
         * Request permission to use online lookup
         * Returns promise that resolves to true (allowed) or false (denied)
         */
        function requestOnlineLookupPermission() {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay show';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 400px;">
                        <div class="modal-header">
                            <h2>Verify Stress Online?</h2>
                        </div>
                        <div class="modal-body">
                            <p style="margin-bottom: 15px;">MSR can look up word stress from Wiktionary to verify your assignment. This requires internet access.</p>
                            <p style="font-size: 0.9em; color: #666;">Your word will be sent to Wiktionary's public API. No personal data is collected.</p>
                        </div>
                        <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button class="secondary-button" id="lookup-deny">Not Now</button>
                            <button class="primary-button" id="lookup-allow">Allow</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                document.getElementById('lookup-allow').onclick = () => {
                    setOnlineLookupPermission('allowed');
                    modal.remove();
                    resolve(true);
                };
                
                document.getElementById('lookup-deny').onclick = () => {
                    modal.remove();
                    resolve(false);
                };
            });
        }
        
        /**
         * Query Wiktionary for stress information
         * Returns: { found: boolean, stressIndex: number, stressedForm: string } or null on error
         */
        async function queryWiktionaryStress(word) {
            const normalizedWord = word.toLowerCase().replace(/[.,!?;:¬ª"'\-‚Äî‚Äì]/g, '');
            
            try {
                // Query Russian Wiktionary API
                const url = `https://ru.wiktionary.org/w/api.php?action=parse&page=${encodeURIComponent(normalizedWord)}&format=json&origin=*&prop=wikitext`;
                
                const response = await fetch(url);
                if (!response.ok) {
                    console.warn('Wiktionary API error:', response.status);
                    return null;
                }
                
                const data = await response.json();
                
                if (data.error) {
                    // Page doesn't exist
                    return { found: false };
                }
                
                const wikitext = data.parse?.wikitext?.['*'] || '';
                
                // Debug: log what we're searching
                console.log(`[Wiktionary] Querying: "${normalizedWord}"`);
                
                // Look for stress mark (combining acute accent U+0301) in the headword
                // Wiktionary typically has the stressed form in the first line or –∑–∞–≥–æ–ª–æ–≤–æ–∫ template
                
                // Method 1: Look for word with combining acute accent
                const stressedWordMatch = wikitext.match(new RegExp(`[–∞-—è—ë–ê-–Ø–Å]*${normalizedWord.split('').join('[ÃÅ]?')}[–∞-—è—ë–ê-–Ø–Å]*`.replace(/–µ/g, '[–µ—ë]'), 'i'));
                
                // Method 2: Look for explicit stress mark anywhere in first few lines
                const lines = wikitext.split('\n').slice(0, 20).join('\n');
                const acuteMatch = lines.match(/([–∞-—è—ë–ê-–Ø–Å]+ÃÅ[–∞-—è—ë–ê-–Ø–Å]*)/);
                
                // Method 3: Look for stress in templates like {{–ø–æ-—Å–ª–æ–≥–∞–º|...}} or headword
                const templateMatch = wikitext.match(/\{\{–ø–æ-—Å–ª–æ–≥–∞–º\|([^}]+)\}\}/);
                const slogi = templateMatch ? templateMatch[1] : null;
                
                // Debug: log what we found
                console.log(`[Wiktionary] Acute match: ${acuteMatch ? acuteMatch[1] : 'none'}`);
                console.log(`[Wiktionary] Template match: ${slogi || 'none'}`);
                
                if (acuteMatch) {
                    const stressedForm = acuteMatch[1];
                    // Find position of stress mark (combining acute U+0301)
                    const stressPos = stressedForm.indexOf('\u0301');
                    if (stressPos > 0) {
                        // Count which syllable this falls in
                        const beforeStress = stressedForm.substring(0, stressPos);
                        const syllables = syllabify(beforeStress.replace(/\u0301/g, ''));
                        const stressIndex = syllables.length - 1;
                        
                        return {
                            found: true,
                            stressIndex: stressIndex,
                            stressedForm: stressedForm.replace(/\u0301/g, '')
                        };
                    }
                }
                
                // If no stress mark found but page exists, return found but unknown stress
                if (data.parse?.title) {
                    return { found: true, stressIndex: -1, stressedForm: normalizedWord };
                }
                
                return { found: false };
                
            } catch (error) {
                console.error('Wiktionary lookup failed:', error);
                return null;
            }
        }
        
        /**
         * Main entry point: verify stress online for a word
         */
        async function verifyStressOnline(wordIndex) {
            const wordData = processedWords[wordIndex];
            if (!wordData) return;
            
            // Check permission
            const permission = getOnlineLookupPermission();
            if (permission === 'denied') {
                showTooltip('Online lookup disabled. Change in settings.', wordIndex);
                return;
            }
            
            if (permission !== 'allowed') {
                const allowed = await requestOnlineLookupPermission();
                if (!allowed) {
                    showTooltip('Online lookup declined', wordIndex);
                    return;
                }
            }
            
            // Show loading state
            showTooltip('Looking up...', wordIndex);
            
            // Get the main word (without clitics)
            const mainPart = wordData.mergedParts?.find(p => p.type === 'main');
            const wordToLookup = mainPart ? mainPart.text : wordData.originalWord;
            // Strip punctuation but KEEP hyphens (compound words like —á–µ–π-–Ω–∏–±—É–¥—å need them)
            const cleanWord = wordToLookup.replace(/[.,!?;:¬ª"'‚Äî‚Äì]/g, '');
            
            // Query Wiktionary
            const result = await queryWiktionaryStress(cleanWord);
            
            if (result === null) {
                // Network error
                showTooltip('Network error. Try again later.', wordIndex);
                return;
            }
            
            if (!result.found) {
                // Not in Wiktionary either
                wordData.stressSource = 'user';
                showTooltip('Not found in Wiktionary. Your stress saved.', wordIndex);
                renderOutput();
                return;
            }
            
            if (result.stressIndex === -1) {
                // Found but stress not marked
                wordData.stressSource = 'user';
                showTooltip('Found but stress not marked. Your stress saved.', wordIndex);
                renderOutput();
                return;
            }
            
            // Compare with user's stress
            const userStress = wordData.processed.stressIndex;
            
            if (userStress === result.stressIndex) {
                // Match! Promote to verified
                wordData.stressSource = 'wiktionary';
                wordData.wiktionaryStress = result.stressIndex;
                harvestWord(cleanWord, result.stressIndex);  // Harvest verified word
                showTooltip('‚úì Verified! Stress confirmed.', wordIndex);
            } else if (userStress === -1) {
                // User hasn't assigned stress yet ‚Äî use Wiktionary's
                wordData.processed = processWord(cleanWord, result.stressIndex);
                wordData.stressSource = 'wiktionary';
                wordData.wiktionaryStress = result.stressIndex;
                harvestWord(cleanWord, result.stressIndex);  // Harvest new word
                showTooltip(`Stress found: syllable ${result.stressIndex + 1}`, wordIndex);
            } else {
                // Mismatch ‚Äî user has different stress than Wiktionary
                wordData.stressSource = 'mismatch';
                wordData.wiktionaryStress = result.stressIndex;
                // Also harvest the Wiktionary stress (it's authoritative even if user overrides)
                harvestWord(cleanWord, result.stressIndex);
                showTooltip(`Wiktionary: syllable ${result.stressIndex + 1}. Yours: ${userStress + 1}. Musical override?`, wordIndex);
            }
            
            renderOutput();
            if (currentView === 'singers') {
                renderSingersView();
            }
        }
        
        // ============================================================================
        // EXPLANATION PANEL - "Why?" Feature
        // ============================================================================
        // Shows pedagogical explanations from Grayson Rules knowledge base
        // 
        // CURATION PHILOSOPHY (2026-01-12):
        // - Lead with what's UNUSUAL about this word
        // - Express transformations in IPA (what user sees), not Cyrillic
        // - Format: ‚ü®cluster‚ü© ‚Üí /ipa/ ‚Äî explanation (p. X)
        // - Suppress "default" rules unless nothing else applies
        // ============================================================================
        
        /**
         * Generate curated explanation for a word's transcription
         * Returns array of { html: string, priority: number } objects
         */
        function generateCuratedExplanations(wordData) {
            const { processed, originalWord, —ëException, mergedParts } = wordData;
            const wordLower = originalWord.toLowerCase();
            const explanations = [];
            
            // Priority tiers:
            // -1 = Clitic/particle explanation - HIGHEST (structural info)
            // 0 = —ë-exception (printed –µ = actual —ë)
            // 1 = Special clusters, deletions, unusual readings (ALWAYS show)
            // 2 = Voicing/devoicing assimilation (show if present)
            // 3 = Palatalization notes (show if space)
            // 4 = Default vowel/consonant rules (only if nothing else)
            
            // ================================================================
            // TIER -1: Clitic/particle explanation (structural info)
            // ================================================================
            
            if (mergedParts && mergedParts.length > 1) {
                const procliticPart = mergedParts.find(p => p.type === 'proclitic');
                const encliticPart = mergedParts.find(p => p.type === 'enclitic');
                const mainPart = mergedParts.find(p => p.type === 'main');
                
                if (procliticPart && mainPart) {
                    const procLower = procliticPart.text.toLowerCase();
                    
                    // Check for voweled preposition variants
                    const voweledPrepositions = {
                        '–≤–æ': '–≤',
                        '–∫–æ': '–∫', 
                        '—Å–æ': '—Å',
                        '–æ–±–æ': '–æ–±',
                        '–æ—Ç–æ': '–æ—Ç',
                        '–∏–∑–æ': '–∏–∑',
                        '–Ω–∞–¥–æ': '–Ω–∞–¥',
                        '–ø–æ–¥–æ': '–ø–æ–¥',
                        '–ø—Ä–µ–¥–æ': '–ø—Ä–µ–¥'
                    };
                    
                    let extraNote = '';
                    if (voweledPrepositions[procLower]) {
                        extraNote = ` (the voweled form of ‚ü®${voweledPrepositions[procLower]}‚ü©, used before certain consonant clusters)`;
                    }
                    
                    explanations.push({
                        html: `<strong>‚ü®${procliticPart.text}‚ü©</strong>${extraNote} is unstressed by definition ‚Äî it attaches to ‚ü®${mainPart.text}‚ü© like a prefix, even though it is written as a separate word <span class="cite">(p. 263)</span>`,
                        priority: -1
                    });
                }
                
                if (encliticPart && mainPart) {
                    const isQuestionParticle = ['–ª–∏', '–ª—å', '–ª–∏', '–ª'].includes(encliticPart.text.toLowerCase());
                    const particleNote = isQuestionParticle ? ' (a question particle, like adding "?" to the phrase)' : '';
                    explanations.push({
                        html: `<strong>‚ü®${encliticPart.text}‚ü©</strong>${particleNote} is unstressed by definition ‚Äî it attaches to ‚ü®${mainPart.text}‚ü© like a suffix, even though it is written as a separate word <span class="cite">(p. 263)</span>`,
                        priority: -1
                    });
                }
            }
            
            // ================================================================
            // TIER 0: —ë-exception (Chapter 8) - printed –µ = actual —ë
            // ================================================================
            
            if (—ëException) {
                const ambiguousNote = —ëException.ambiguous 
                    ? ' <em>(context-dependent ‚Äî may be ‚ü®–µ‚ü© /…õ/ if referring to people)</em>' 
                    : '';
                explanations.push({
                    html: `<strong>‚ü®${originalWord}‚ü©</strong> ‚Üí printed ‚ü®–µ‚ü© is actually ‚ü®${—ëException.actualForm}‚ü© with /o/ ‚Äî ${—ëException.note}${ambiguousNote} <span class="cite">(Ch. 8, p. 275)</span>`,
                    priority: 0
                });
            }
            
            // ================================================================
            // TIER 0.5: Pure pronunciation exceptions (Chapter 8, Section 5)
            // ================================================================
            
            const pureException = wordData.pureException;
            if (pureException) {
                const ipaNote = pureException.ipa_note ? ` ‚Üí ${pureException.ipa_note}` : '';
                explanations.push({
                    html: `<strong>‚ü®${originalWord}‚ü©</strong> ‚Äî ${pureException.note}${ipaNote} <span class="cite">(Ch. 8, p. 287)</span>`,
                    priority: 0
                });
            }
            
            // ================================================================
            // TIER 1: Special clusters and deletions (highest priority)
            // ================================================================
            
            const specialPatterns = [
                // Deletions - always interesting
                { pattern: /—Å—Ç–Ω/, cyrillic: '—Å—Ç–Ω', ipa: '/sn/', note: 'the /t/ is silent', page: 243 },
                { pattern: /–∑–¥–Ω/, cyrillic: '–∑–¥–Ω', ipa: '/zn/', note: 'the /d/ is silent', page: 243, 
                  exception: { pattern: /–±–µ–∑–¥–Ω/, note: '(exception: –±–µ–∑–¥–Ω–∞ keeps /zdn/)' } },
                { pattern: /—Ä–¥—Ü/, cyrillic: '—Ä–¥—Ü', ipa: '/rts/', note: 'the /d/ is silent', page: 243 },
                { pattern: /–ª–Ω—Ü/, cyrillic: '–ª–Ω—Ü', ipa: '/nts/', note: 'the /l/ is silent', page: 244 },
                { pattern: /–≤—Å—Ç–≤/, cyrillic: '–≤—Å—Ç–≤', ipa: '/stv/', note: 'first /v/ is silent', page: 244 },
                { pattern: /—Å—Ç—Å–∫/, cyrillic: '—Å—Ç—Å–∫', ipa: '/sk/', note: 'simplified cluster', page: 245 },
                
                // Special readings
                { pattern: /—á–Ω/, cyrillic: '—á–Ω', ipa: '/ Én/', note: 'not /t É ≤n/', page: 239,
                  wordList: ['—Å–∫—É—á–Ω', '–∫–æ–Ω–µ—á–Ω', '—è–∏—á–Ω', '–ø—Ä–∞—á–µ—á–Ω', '—Å–∫–≤–æ—Ä–µ—á–Ω', '–Ω–∞—Ä–æ—á–Ω'] },
                { pattern: /—á—Ç/, cyrillic: '—á—Ç', ipa: '/ Ét/', note: 'the "—á—Ç–æ rule"', page: 240,
                  wordList: ['—á—Ç–æ', '—á—Ç–æ–±', '–Ω–∏—á—Ç', '–∫–æ–µ-—á—Ç'] },
                { pattern: /–≥–∫/, cyrillic: '–≥–∫', ipa: '/xk/', note: '–≥ becomes fricative /x/', page: 240 },
                { pattern: /–≥—á/, cyrillic: '–≥—á', ipa: '/xt É ≤/', note: '/x/ does NOT palatalize', page: 241 },
                
                // Chapter 8: Palatalized —Ü in -—Ü–∏—è/-—Ü–∏–æ–Ω–Ω—ã–π suffixes (p. 283-284)
                // Only when analogous to English -tion/-ence (not -ture like –ª–µ–∫—Ü–∏—è)
                { pattern: /—Ü–∏—è$|—Ü–∏–æ–Ω–Ω/, cyrillic: '-—Ü–∏—è/-—Ü–∏–æ–Ω–Ω-', ipa: '/t ≤s ≤i/', note: 'palatalized —Ü (rare exception)', page: 283,
                  wordList: ['—Ä–µ–≤–æ–ª—é—Ü', '–¥–µ–∫–ª–∞–º–∞—Ü', '–∫–∞–¥–µ–Ω—Ü', '–Ω–∞—Ü', '–∫–æ–Ω—Å—Ç–∏—Ç', '–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü', '–∏–Ω—Ñ–æ—Ä–º–∞—Ü', '–æ–ø–µ—Ä–∞—Ü', '—Å—Ç–∞–Ω—Ü', '—ç–≤–æ–ª—é—Ü', '–∞–≤–∏–∞—Ü'] },
                
                // Cluster mergers
                { pattern: /—Å—à|–∑—à/, cyrillic: '—Å—à/–∑—à', ipa: '/ ÉÀê/', note: 'merged long fricative', page: 235 },
                { pattern: /—Å–∂|–∑–∂/, cyrillic: '—Å–∂/–∑–∂', ipa: '/ íÀê/', note: 'merged long fricative', page: 236 },
                { pattern: /—Å—á|–∑—á|–∂—á|—Å—Ç—á|–∑–¥—á|—Å—Å—á/, cyrillic: 'cluster', ipa: '/ É ≤ É ≤/', note: 'like ‚ü®—â‚ü©', page: 236 },
                { pattern: /—Ç—à|–¥—à|—á—à/, cyrillic: '—Ç—à/–¥—à/—á—à', ipa: '/t ÉÀê/', note: 'merged affricate', page: 236 },
                { pattern: /–¥–∂|—Ç–∂/, cyrillic: '–¥–∂/—Ç–∂', ipa: '/d íÀê/', note: 'merged affricate', page: 237 },
                { pattern: /—Ç—á|–¥—á/, cyrillic: '—Ç—á/–¥—á', ipa: '/tÀê É ≤/', note: 'elongated ‚ü®—á‚ü©', page: 237 },
                
                // Reflexive verbs
                { pattern: /—Ç—å—Å—è|—Ç—Å—è/, cyrillic: '-—Ç—å—Å—è/-—Ç—Å—è', ipa: '/tÀês å/', note: 'reflexive ending', page: 238 },
                { pattern: /—Ç—Ü|–¥—Ü/, cyrillic: '—Ç—Ü/–¥—Ü', ipa: '/tÀês/', note: 'elongated /t/', page: 238 },
            ];
            
            for (const sp of specialPatterns) {
                if (sp.pattern.test(wordLower)) {
                    // Check wordList filter if specified
                    if (sp.wordList && !sp.wordList.some(stem => wordLower.includes(stem))) {
                        continue;
                    }
                    // Check for exception
                    let note = sp.note;
                    if (sp.exception && sp.exception.pattern.test(wordLower)) {
                        note = sp.exception.note;
                    }
                    explanations.push({
                        html: `<strong>‚ü®${sp.cyrillic}‚ü©</strong> ‚Üí ${sp.ipa} ‚Äî ${note} <span class="cite">(p. ${sp.page})</span>`,
                        priority: 1
                    });
                }
            }
            
            // ================================================================
            // TIER 2: Voicing assimilation (interesting but common)
            // ================================================================
            
            const voicedConsonants = { '–±': 'b', '–≤': 'v', '–≥': '…°', '–¥': 'd', '–∂': ' í', '–∑': 'z' };
            const unvoicedConsonants = { '–ø': 'p', '—Ñ': 'f', '–∫': 'k', '—Ç': 't', '—à': ' É', '—Å': 's', '—Ö': 'x', '—Ü': 'ts', '—á': 't É ≤', '—â': ' É ≤ É ≤' };
            const devoiceMap = { '–±': 'p', '–≥': 'k', '–¥': 't', '–∂': ' É', '–∑': 's' };
            const voiceMap = { '–∫': '…°', '—Å': 'z', '—Ç': 'd', '–ø': 'b', '—Ñ': 'v' };
            const devoicePages = { '–±': 215, '–≥': 216, '–¥': 217, '–∂': 218, '–∑': 218 };
            const voicePages = { '–∫': 219, '—Å': 220, '—Ç': 221, '–ø': 221, '—Ñ': 222 };
            
            for (let i = 0; i < wordLower.length - 1; i++) {
                const curr = wordLower[i];
                const next = wordLower[i + 1];
                
                // Skip if this is part of a special cluster already handled
                const twoChar = curr + next;
                const threeChar = i < wordLower.length - 2 ? curr + next + wordLower[i + 2] : '';
                if (['–≥–∫', '–≥—á', '—Å—à', '–∑—à', '—Å–∂', '–∑–∂', '—Å—á', '–∑—á', '–∂—á', '—Ç—à', '–¥—à', '—á—à', '–¥–∂', '—Ç–∂', '—Ç—á', '–¥—á', '—Ç—Ü', '–¥—Ü'].includes(twoChar)) {
                    continue;
                }
                if (['—Å—Ç–Ω', '–∑–¥–Ω', '—Ä–¥—Ü', '–ª–Ω—Ü', '—Å—Ç—á', '–∑–¥—á'].includes(threeChar)) {
                    continue;
                }
                
                // Devoicing: voiced before unvoiced
                if (devoiceMap[curr] && unvoicedConsonants[next]) {
                    const fromIPA = voicedConsonants[curr];
                    const toIPA = devoiceMap[curr];
                    explanations.push({
                        html: `<strong>‚ü®${curr}${next}‚ü©</strong> ‚Üí /${toIPA}${unvoicedConsonants[next]}/ ‚Äî /${fromIPA}/ devoices before unvoiced consonant <span class="cite">(p. ${devoicePages[curr]})</span>`,
                        priority: 2
                    });
                }
                
                // Voicing: unvoiced before voiced (except sonorants and –≤)
                const voicingTriggers = ['–±', '–≥', '–¥', '–∂', '–∑'];
                if (voiceMap[curr] && voicingTriggers.includes(next)) {
                    const fromIPA = unvoicedConsonants[curr];
                    const toIPA = voiceMap[curr];
                    explanations.push({
                        html: `<strong>‚ü®${curr}${next}‚ü©</strong> ‚Üí /${toIPA}${voicedConsonants[next]}/ ‚Äî /${fromIPA}/ voices before voiced consonant <span class="cite">(p. ${voicePages[curr]})</span>`,
                        priority: 2
                    });
                }
            }
            
            // ================================================================
            // TIER 3: Notable palatalization (if word has interesting cases)
            // ================================================================
            
            // Check for soft –Ω ‚Üí …≤ (often surprises learners)
            if (/–Ω[–µ—ë–∏—é—è—å]/.test(wordLower)) {
                explanations.push({
                    html: `<strong>‚ü®–Ω—å‚ü©</strong> or ‚ü®–Ω‚ü©+soft vowel ‚Üí /…≤/ ‚Äî true palatal nasal <span class="cite">(p. 183)</span>`,
                    priority: 3
                });
            }
            
            // Check for hard –ª ‚Üí …´ 
            if (/–ª[–∞–æ—É—ã—ç]|–ª$|–ª[–±–≤–≥–¥–∂–∑–∫–ª–º–Ω–ø—Ä—Å—Ç—Ñ—Ö—Ü—á—à—â]/.test(wordLower)) {
                explanations.push({
                    html: `<strong>‚ü®–ª‚ü©</strong> (hard) ‚Üí /…´/ ‚Äî velarized, tongue back raised <span class="cite">(p. 150)</span>`,
                    priority: 4  // Lower priority, common knowledge
                });
            }
            
            // ================================================================
            // TIER 4: Default rules (only show if nothing else applies)
            // ================================================================
            
            // Only add default vowel rule if we have almost nothing else
            if (explanations.filter(e => e.priority <= 2).length === 0) {
                // Check for akanye (–æ ‚Üí –∞ in pretonic)
                if (/–æ/.test(wordLower) && processed.stressIndex >= 0) {
                    const syllables = processed.syllables;
                    for (let i = 0; i < syllables.length; i++) {
                        if (i !== processed.stressIndex && /–æ/.test(syllables[i].cyrillic.toLowerCase())) {
                            explanations.push({
                                html: `Unstressed ‚ü®–æ‚ü© ‚Üí /…ë/ or / å/ ‚Äî vowel reduction (akanye) <span class="cite">(p. 127)</span>`,
                                priority: 4
                            });
                            break;
                        }
                    }
                }
            }
            
            // Sort by priority, then take top results
            explanations.sort((a, b) => a.priority - b.priority);
            
            // Deduplicate by checking for similar content
            const seen = new Set();
            const unique = explanations.filter(exp => {
                const key = exp.html.substring(0, 30);
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
            
            return unique.slice(0, 4);  // Max 4 explanations
        }
        
        /**
         * Show explanation panel for a word's transcription
         */
        function showExplanationPanel(wordIndex) {
            // Remove any existing panel
            closeExplanationPanel();
            
            const wordData = processedWords[wordIndex];
            if (!wordData) return;
            
            // Get card element for positioning (the visible front face, not container)
            const cardContainer = document.getElementById(`card-${wordIndex}`);
            const card = cardContainer?.querySelector('.word-card-front') || cardContainer;
            
            const { processed, originalWord } = wordData;
            
            // Generate curated explanations
            const explanations = generateCuratedExplanations(wordData);
            
            // Build explanation panel HTML
            const panel = document.createElement('div');
            panel.className = 'explanation-panel';
            panel.id = 'explanation-panel';
            
            const cyrillicDisplay = getCyrillicWithStress(processed);
            
            // Get IPA for display
            let ipaDisplay;
            if (wordData.ipaEditorState) {
                const { units, boundaries } = wordData.ipaEditorState;
                const parts = [];
                let start = 0;
                for (const b of boundaries) {
                    parts.push(units.slice(start, b).map(u => u.symbol).join(''));
                    start = b;
                }
                parts.push(units.slice(start).map(u => u.symbol).join(''));
                const stressIdx = processed.stressIndex;
                if (stressIdx >= 0 && stressIdx < parts.length && processed.showStressMarker) {
                    parts[stressIdx] = 'Àà' + parts[stressIdx];
                }
                ipaDisplay = parts.filter(p => p.length > 0).join(' ');
            } else {
                ipaDisplay = processed.syllables.map((s, idx) => {
                    const stressMark = s.showStressMarker ? 'Àà' : '';
                    return stressMark + s.ipa;
                }).filter(s => s.length > 0).join(' ');
            }
            ipaDisplay = applyNotationPreferences(applyStyleSettings(ipaDisplay));
            
            let explanationHTML;
            if (explanations.length > 0) {
                explanationHTML = explanations.map(exp => `<p class="why-item">${exp.html}</p>`).join('');
            } else {
                explanationHTML = '<p class="why-item">This word follows standard transcription rules.</p>';
            }
            
            panel.innerHTML = `
                <span class="explanation-panel-close" onclick="closeExplanationPanel()" title="Close">‚úï</span>
                <div class="explanation-panel-header">
                    <span class="explanation-panel-title">${cyrillicDisplay}</span>
                    <span class="explanation-panel-ipa">/${ipaDisplay}/</span>
                </div>
                <div class="explanation-panel-body">
                    ${explanationHTML}
                </div>
                <div class="explanation-panel-citation">
                    Source: Grayson, <em>Russian Lyric Diction</em> (2012)
                </div>
            `;
            
            // Position panel near the card using scroll-aware coordinates
            if (card) {
                placePanelNearCard(card, panel);
            } else {
                // Fallback: center on screen
                panel.style.position = 'fixed';
                panel.style.left = '50%';
                panel.style.top = '50%';
                panel.style.transform = 'translate(-50%, -50%)';
                panel.style.transformOrigin = 'center center';
            }
            
            panel.style.animation = 'emergeFromCard 0.45s ease-out forwards';
            
            document.body.appendChild(panel);
            
            // Re-position on scroll/resize (throttled)
            let repositionTimeout;
            const repositionHandler = () => {
                clearTimeout(repositionTimeout);
                repositionTimeout = setTimeout(() => {
                    if (card && document.getElementById('explanation-panel')) {
                        placePanelNearCard(card, panel);
                    }
                }, 50);
            };
            window.addEventListener('scroll', repositionHandler);
            window.addEventListener('resize', repositionHandler);
            
            // Store handlers for cleanup
            panel._repositionHandler = repositionHandler;
            
            // Prevent scroll on panel wheel events
            panel.addEventListener('wheel', (e) => {
                const body = panel.querySelector('.explanation-panel-body');
                if (body) {
                    const atTop = body.scrollTop === 0;
                    const atBottom = body.scrollTop + body.clientHeight >= body.scrollHeight;
                    
                    if ((e.deltaY < 0 && atTop) || (e.deltaY > 0 && atBottom)) {
                        e.preventDefault();
                    }
                }
            }, { passive: false });
            
            // Close on click outside panel (delay to avoid immediate close)
            setTimeout(() => {
                document.addEventListener('click', handleExplanationClickOutside);
            }, 10);
            
            // Close on escape key
            document.addEventListener('keydown', handleExplanationEscape);
        }
        
        /**
         * Position panel adjacent to card, scroll-aware
         * KIMI's fix: use absolute positioning with scrollX/scrollY offsets
         */
        function placePanelNearCard(card, panel, gap = 12) {
            const r = card.getBoundingClientRect();
            const scrollY = window.scrollY;
            const scrollX = window.scrollX;
            const vw = document.documentElement.clientWidth;
            const vh = document.documentElement.clientHeight;
            
            const panelWidth = Math.min(350, vw - 40);
            panel.style.maxWidth = `${panelWidth}px`;
            
            // Start with panel to the right of card
            let left = r.right + scrollX + gap;
            let top = r.top + scrollY;
            
            // If overflows right, try left side
            if (left + panelWidth > scrollX + vw - 20) {
                left = r.left + scrollX - panelWidth - gap;
            }
            
            // Clamp to viewport
            if (left < scrollX + 10) {
                left = scrollX + 10;
            }
            
            // Keep top within reasonable bounds
            if (top < scrollY + 10) {
                top = scrollY + 10;
            }
            
            panel.style.position = 'absolute';
            panel.style.left = `${left}px`;
            panel.style.top = `${top}px`;
        }
        
        function handleExplanationClickOutside(e) {
            const panel = document.getElementById('explanation-panel');
            if (panel && !panel.contains(e.target) && !e.target.closest('.why-icon')) {
                closeExplanationPanel();
            }
        }
        
        function closeExplanationPanel() {
            const panel = document.getElementById('explanation-panel');
            if (panel) {
                // Clean up scroll/resize handlers
                if (panel._repositionHandler) {
                    window.removeEventListener('scroll', panel._repositionHandler);
                    window.removeEventListener('resize', panel._repositionHandler);
                }
                // Animate out
                panel.style.animation = 'recedeToCard 0.3s ease-in forwards';
                // Remove after animation completes
                setTimeout(() => {
                    if (panel.parentNode) panel.remove();
                }, 300);
            }
            document.removeEventListener('keydown', handleExplanationEscape);
            document.removeEventListener('click', handleExplanationClickOutside);
        }
        
        function handleExplanationEscape(e) {
            if (e.key === 'Escape') closeExplanationPanel();
        }

        // Render the output
        /**
         * Add stress mark (combining acute accent) to the vowel in a syllable
         * Exception: —ë already indicates stress via its dieresis, so no acute needed
         */
        function addStressToSyllable(syllable) {
            const vowelSet = new Set(['–∞', '–µ', '—ë', '–∏', '–æ', '—É', '—ã', '—ç', '—é', '—è',
                                      '–ê', '–ï', '–Å', '–ò', '–û', '–£', '–´', '–≠', '–Æ', '–Ø']);
            const chars = Array.from(syllable);
            let result = '';
            let stressAdded = false;
            
            for (const char of chars) {
                result += char;
                // Skip adding acute to —ë/–Å - the dieresis already indicates stress
                if (!stressAdded && vowelSet.has(char) && char !== '—ë' && char !== '–Å') {
                    result += '\u0301'; // Combining acute accent
                    stressAdded = true;
                }
                // For —ë, mark stress as "added" so we don't add acute to a later vowel
                if (char === '—ë' || char === '–Å') {
                    stressAdded = true;
                }
            }
            return result;
        }
        
        /**
         * Get Cyrillic word with stress mark (combining acute accent) on stressed vowel
         * Exception: —ë already indicates stress via its dieresis, so no acute needed
         */
        function getCyrillicWithStress(processed) {
            const stressIdx = processed.stressIndex;
            if (stressIdx === -1) {
                // No stress marked, return plain
                return processed.syllables.map(s => s.cyrillic).join('');
            }
            
            // Build the word, adding combining acute (U+0301) after the stressed vowel
            const vowelSet = new Set(['–∞', '–µ', '—ë', '–∏', '–æ', '—É', '—ã', '—ç', '—é', '—è']);
            let result = '';
            
            processed.syllables.forEach((syl, sylIdx) => {
                if (sylIdx === stressIdx) {
                    // Find the vowel in this syllable and add stress mark after it
                    const chars = Array.from(syl.cyrillic);
                    let stressAdded = false;
                    for (let i = 0; i < chars.length; i++) {
                        result += chars[i];
                        const lowerChar = chars[i].toLowerCase();
                        // Skip adding acute to —ë - the dieresis already indicates stress
                        if (!stressAdded && vowelSet.has(lowerChar) && lowerChar !== '—ë') {
                            result += '\u0301'; // Combining acute accent
                            stressAdded = true;
                        }
                        // For —ë, mark stress as "added" so we don't add acute to a later vowel
                        if (lowerChar === '—ë') {
                            stressAdded = true;
                        }
                    }
                } else {
                    result += syl.cyrillic;
                }
            });
            
            return result;
        }
        
        function renderOutput() {
            const outputDiv = document.getElementById('output');

            if (processedWords.length === 0) {
                outputDiv.innerHTML = '';
                return;
            }
            
            // Count statistics
            const dictCount = processedWords.filter(w => ['dictionary', 'wiktionary', '—ë-rule', '—ë-exception'].includes(w.stressSource)).length;
            const userCount = processedWords.filter(w => w.stressSource === 'user').length;
            const composerCount = processedWords.filter(w => w.stressSource === 'composer').length;
            const overrideCount = userCount + composerCount + processedWords.filter(w => w.stressSource === 'mismatch').length;
            const placeholderCount = processedWords.filter(w => w.stressSource === 'placeholder').length;
            const totalCount = processedWords.length;
            
            // Build override label
            let overrideLabel = 'your choice';
            if (userCount > 0 && composerCount > 0) {
                overrideLabel = `your choice (${userCount}) + composer (${composerCount})`;
            } else if (composerCount > 0) {
                overrideLabel = `composer's score`;
            }

            const html = `
                <div class="info-box" style="margin-top: 30px;">
                    <h3>Transcription Results</h3>
                    <p style="line-height: 1.8;">
                        <span style="display: inline-block; width: 12px; height: 12px; border: 2px solid #48bb78; border-radius: 50%; vertical-align: middle; margin-right: 4px;"></span>verified (${dictCount})
                        <span style="display: inline-block; width: 12px; height: 12px; border: 2px solid #3B82F6; border-radius: 50%; vertical-align: middle; margin-left: 12px; margin-right: 4px;"></span>${overrideLabel} (${overrideCount})
                        <span style="display: inline-block; width: 12px; height: 12px; border: 2px dashed rgba(140,140,140,0.35); border-radius: 50%; vertical-align: middle; margin-left: 12px; margin-right: 4px;"></span>needs attention (${placeholderCount})
                    </p>
                </div>
                <div class="word-grid">
                    ${processedWords.map((wordData, wordIdx) => {
                        const { processed, isClitic, isStandaloneClitic, stressSource, —ëException } = wordData;
                        
                        // Initialize IPA editor state if not present (for proper syllable spacing)
                        if (!wordData.ipaEditorState && processed.syllables.length > 1) {
                            getWordIPAWithBoundaries(wordIdx);
                        }
                        
                        // Build IPA with syllable spacing
                        let fullIPA;
                        if (wordData.ipaEditorState) {
                            // Use edited state with boundaries
                            const { units, boundaries } = wordData.ipaEditorState;
                            const parts = [];
                            let start = 0;
                            for (const b of boundaries) {
                                parts.push(units.slice(start, b).map(u => u.symbol).join(''));
                                start = b;
                            }
                            parts.push(units.slice(start).map(u => u.symbol).join(''));
                            // Add stress mark to stressed syllable
                            const stressIdx = processed.stressIndex;
                            if (stressIdx >= 0 && stressIdx < parts.length && processed.showStressMarker) {
                                parts[stressIdx] = 'Àà' + parts[stressIdx];
                            }
                            fullIPA = parts.filter(p => p.length > 0).join(' ');
                        } else {
                            // Original syllable-based IPA (monosyllables)
                            fullIPA = processed.syllables.map((s, idx) => {
                                const stressMark = s.showStressMarker ? 'Àà' : '';
                                return stressMark + s.ipa;
                            }).filter(s => s.length > 0).join(' ');
                        }
                        
                        // Apply notation preferences (e.g.,  É ≤ É ≤ ‚Üí  É ≤Àê toggle)
                        fullIPA = applyNotationPreferences(applyStyleSettings(fullIPA));
                        
                        // Validate IPA output against Grayson inventory
                        if (DEBUG && !validateIPAOutput(fullIPA)) {
                            console.error(`Validation failed for: ${wordData.originalWord}`);
                        }
                        
                        // PROVENANCE VIA CIRCLE COLOUR ONLY (no icons)
                        // - Green = verified (dictionary, Wiktionary, —ë-rule)
                        // - Blue = user-assigned
                        // - Grey dotted = placeholder (needs attention)
                        // Tooltip on stressed syllable carries the full provenance sentence
                        // Exception info (pronunciation irregularities) shown in Why section, not on card

                        return `
                            <div class="word-card-container${isStandaloneClitic ? ' clitic-card' : ''}" id="card-${wordIdx}">
                                <div class="word-card-inner">
                                    <div class="word-card-front word-card">
                                                                                <button class="why-icon" onclick="showExplanationPanel(${wordIdx})" aria-label="IPA notes" title="Why this transcription?">?</button>
                                        <div class="cyrillic">
                                            ${(() => {
                                                // Calculate proclitic syllable count for spacing
                                                let procliticSyllableCount = 0;
                                                let encliticText = '';
                                                let mainText = '';
                                                
                                                if (wordData.mergedParts && wordData.mergedParts.length > 1) {
                                                    const procliticPart = wordData.mergedParts.find(p => p.type === 'proclitic');
                                                    const encliticPart = wordData.mergedParts.find(p => p.type === 'enclitic');
                                                    const mainPart = wordData.mergedParts.find(p => p.type === 'main');
                                                    
                                                    if (procliticPart) {
                                                        // Count vowels in proclitic to estimate syllables
                                                        const vowels = procliticPart.text.toLowerCase().match(/[–∞–µ—ë–∏–æ—É—ã—ç—é—è]/g);
                                                        procliticSyllableCount = vowels ? vowels.length : 1;
                                                    }
                                                    if (encliticPart) {
                                                        encliticText = encliticPart.text.toLowerCase();
                                                    }
                                                    if (mainPart) {
                                                        mainText = mainPart.text.toLowerCase();
                                                    }
                                                }
                                                
                                                // Track cumulative characters to detect when enclitic starts
                                                let charCount = 0;
                                                const mainLength = mainText.length;
                                                
                                                return processed.syllables.map((syl, sylIdx) => {
                                                // Determine circle style based on stress source
                                                const isUserStress = wordData.stressSource === 'user' || wordData.stressSource === 'composer' || wordData.stressSource === 'mismatch';
                                                const isPlaceholder = wordData.stressSource === 'placeholder';
                                                const isVerified = ['dictionary', 'wiktionary', '—ë-rule', '—ë-exception'].includes(wordData.stressSource);
                                                
                                                let stressClass = '';
                                                if (syl.isStressed) {
                                                    if (isPlaceholder) {
                                                        stressClass = 'stressed placeholder-stress';
                                                    } else if (isUserStress) {
                                                        stressClass = 'stressed user-stress';
                                                    } else {
                                                        stressClass = 'stressed'; // green = verified
                                                    }
                                                }
                                                
                                                // Add spacer class after proclitic
                                                const isAfterProclitic = procliticSyllableCount > 0 && sylIdx === procliticSyllableCount;
                                                
                                                // For enclitics: check if this syllable contains enclitic characters
                                                // by looking at whether the syllable text matches or contains the enclitic
                                                const sylLower = syl.cyrillic.toLowerCase();
                                                const containsEnclitic = encliticText && sylLower.includes(encliticText);
                                                const startsWithEnclitic = encliticText && sylLower.startsWith(encliticText);
                                                
                                                // If syllable contains enclitic and it's not the whole syllable, we need inline spacing
                                                // For now, add before-clitic class to syllables that END with the enclitic
                                                const endsWithEnclitic = encliticText && sylLower.endsWith(encliticText) && sylLower !== encliticText;
                                                
                                                let spacerClass = isAfterProclitic ? 'after-clitic' : '';
                                                // For vowelless enclitics merged into previous syllable, we handle via CSS
                                                if (encliticText && sylLower === encliticText) {
                                                    spacerClass = 'before-clitic';
                                                }
                                                
                                                const clickableClass = 'clickable';
                                                
                                                // Check if this is the last syllable and contains an absorbed enclitic
                                                const isLastSyl = sylIdx === processed.syllables.length - 1;
                                                const hasAbsorbedEnclitic = isLastSyl && encliticText && 
                                                    sylLower.endsWith(encliticText) && sylLower !== encliticText;
                                                
                                                // Add stress mark to stressed syllable
                                                let displayText = syl.isStressed ? addStressToSyllable(syl.cyrillic) : syl.cyrillic;
                                                
                                                // If enclitic is absorbed, split it off with spacing
                                                if (hasAbsorbedEnclitic) {
                                                    const mainPart = syl.cyrillic.slice(0, -encliticText.length);
                                                    const encliticDisplay = syl.cyrillic.slice(-encliticText.length);
                                                    const stressedMain = syl.isStressed ? addStressToSyllable(mainPart) : mainPart;
                                                    displayText = `${stressedMain}<span class="enclitic-spacer"></span>${encliticDisplay}`;
                                                }
                                                
                                                // Dynamic tooltip based on provenance
                                                const has–Å = /—ë/i.test(syl.cyrillic);
                                                const has–ï = /–µ/i.test(syl.cyrillic);
                                                let tooltip = 'Click to stress';
                                                
                                                if (syl.isStressed) {
                                                    if (isPlaceholder) {
                                                        tooltip = 'Temporary stress ‚Äî tap to confirm or move';
                                                    } else if (wordData.stressSource === 'user') {
                                                        tooltip = `Your choice ‚Äî syllable ${sylIdx + 1}`;
                                                    } else if (wordData.stressSource === 'composer') {
                                                        tooltip = `Composer's score ‚Äî syllable ${sylIdx + 1}`;
                                                    } else if (wordData.stressSource === 'dictionary') {
                                                        tooltip = 'Stress verified ‚Äî Vuizur dictionary';
                                                    } else if (wordData.stressSource === 'wiktionary') {
                                                        tooltip = 'Stress verified ‚Äî Wiktionary lookup';
                                                    } else if (wordData.stressSource === '—ë-rule') {
                                                        tooltip = 'Stress on ‚ü®—ë‚ü© is always marked';
                                                    } else if (wordData.stressSource === '—ë-exception') {
                                                        tooltip = 'Printed ‚ü®–µ‚ü© is actually ‚ü®—ë‚ü© ‚Äî stress verified';
                                                    }
                                                    
                                                    // Add –µ‚Üî—ë hint if applicable
                                                    if (has–Å) {
                                                        tooltip += ' ‚Ä¢ Double-click to restore ‚ü®–µ‚ü©';
                                                    } else if (has–ï && isVerified) {
                                                        tooltip += ' ‚Ä¢ Double-click to change to ‚ü®—ë‚ü©';
                                                    }
                                                } else if (has–ï || has–Å) {
                                                    tooltip = 'Click to stress ‚Ä¢ Then double-click for –µ‚Üî—ë';
                                                }
                                                
                                                return `<span class="syllable ${stressClass} ${clickableClass} ${spacerClass}" 
                                                             onclick="handleSyllableClick(${wordIdx}, ${sylIdx})"
                                                             title="${tooltip}">
                                                            ${displayText}
                                                        </span>`;
                                                }).join('');
                                            })()}${(() => {
                                                // If there's an enclitic, render it as a separate visual element
                                                if (wordData.mergedParts && wordData.mergedParts.length > 1) {
                                                    const encliticPart = wordData.mergedParts.find(p => p.type === 'enclitic');
                                                    if (encliticPart) {
                                                        // Check if the enclitic is absorbed into the last syllable
                                                        const lastSyl = processed.syllables[processed.syllables.length - 1];
                                                        const lastSylLower = lastSyl?.cyrillic.toLowerCase() || '';
                                                        const encliticLower = encliticPart.text.toLowerCase();
                                                        
                                                        if (lastSylLower.endsWith(encliticLower) && lastSylLower !== encliticLower) {
                                                            // Enclitic was absorbed ‚Äî we need to visually separate it
                                                            // Return empty here; we'll handle this by modifying the syllable rendering above
                                                        }
                                                    }
                                                }
                                                return '';
                                            })()}
                                        </div>
                                        <div class="ipa">/${fullIPA}/</div>
                                                                                <button class="flip-button" onclick="flipCard(${wordIdx})" aria-label="Edit syllables"><svg viewBox="0 0 24 24" width="18" height="18" fill="none"><path d="M4 12a8 8 0 0 1 8-8c2.8 0 5.2 1.4 6.7 3.5" stroke="currentColor" stroke-width="2.8" stroke-linecap="round"/><path d="M20 12a8 8 0 0 1-8 8c-2.8 0-5.2-1.4-6.7-3.5" stroke="currentColor" stroke-width="2.8" stroke-linecap="round"/><path d="M20 4v4h-4" stroke="currentColor" stroke-width="2.8" stroke-linecap="round" stroke-linejoin="round"/><path d="M4 20v-4h4" stroke="currentColor" stroke-width="2.8" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
                                    </div>
                                    <div class="word-card-back">
                                        <div class="card-back-header">
                                            <span class="card-back-title">${getCyrillicWithStress(processed)}</span>
                                        </div>
                                        ${renderSyllableEditor(wordIdx)}
                                        <button class="card-back-close" onclick="flipCard(${wordIdx})" title="Done"><svg viewBox="0 0 24 24" width="18" height="18" fill="none"><path d="M4 12a8 8 0 0 1 8-8c2.8 0 5.2 1.4 6.7 3.5" stroke="currentColor" stroke-width="2.8" stroke-linecap="round"/><path d="M20 12a8 8 0 0 1-8 8c-2.8 0-5.2-1.4-6.7-3.5" stroke="currentColor" stroke-width="2.8" stroke-linecap="round"/><path d="M20 4v4h-4" stroke="currentColor" stroke-width="2.8" stroke-linecap="round" stroke-linejoin="round"/><path d="M4 20v-4h4" stroke="currentColor" stroke-width="2.8" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
                                    </div>
                                    <div class="word-card-sizer">
                                                                                <div class="sizer-front">
                                                                                    <div class="cyrillic">${processed.syllables.map(s => s.cyrillic).join('')}</div>
                                                                                    <div class="ipa">/${fullIPA}/</div>
                                                                                </div>
                                                                                <div class="sizer-back">${getIPAForSizer(wordIdx)}</div>
                                                                            </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;

            outputDiv.innerHTML = html;
            showViewToggle();
            
            // Equalize card heights per row after render
            requestAnimationFrame(() => {
                equalizeCardHeights();
            });
        }
        
        /**
         * Equalize card heights within each visual row
         * Cards in the same row should have uniform height
         */
        function equalizeCardHeights() {
            const cards = document.querySelectorAll('.word-card-container');
            if (cards.length === 0) return;
            
            // Group cards by their top position (same row = same top)
            const rows = new Map();
            cards.forEach(card => {
                const top = Math.round(card.getBoundingClientRect().top);
                if (!rows.has(top)) rows.set(top, []);
                rows.get(top).push(card);
            });
            
            // For each row, find max height and apply to all
            rows.forEach(rowCards => {
                // Reset heights first to get natural height
                rowCards.forEach(card => {
                    const inner = card.querySelector('.word-card');
                    if (inner) inner.style.height = 'auto';
                });
                
                // Measure max natural height in this row
                let maxHeight = 0;
                rowCards.forEach(card => {
                    const inner = card.querySelector('.word-card');
                    if (inner) {
                        maxHeight = Math.max(maxHeight, inner.offsetHeight);
                    }
                });
                
                // Apply max height to all cards in row
                rowCards.forEach(card => {
                    const inner = card.querySelector('.word-card');
                    if (inner) {
                        inner.style.height = maxHeight + 'px';
                    }
                });
            });
        }
        
        // ============================================================================
        // SYLLABLE BOUNDARY EDITOR
        // ============================================================================
        // These functions power the card-flip syllable adjustment feature.
        // 
        // UX Philosophy: This is COSMETIC adjustment, not structural editing.
        // Users are "tinkering with the guts" but really just moving consonants
        // across syllable boundaries to suit their preferred syllabification.
        // 
        // The IPA retranscribes automatically after each move, maintaining
        // phonetic accuracy while letting users choose boundary placement.
        // ============================================================================
        
        /**
         * Flip a word card to show/hide the syllable boundary editor
         * Uses CSS 3D transform (rotateY) for satisfying flip animation
         */
        function flipCard(wordIdx) {
            const container = document.getElementById(`card-${wordIdx}`);
            if (container) {
                // Add flipping class for transition effects
                container.classList.add('flipping');
                container.classList.toggle('flipped');
                
                // Remove flipping class after animation completes
                setTimeout(() => {
                    container.classList.remove('flipping');
                }, 600); // Match transition duration
            }
        }
        
        /**
         * Parse IPA string into phoneme units for the syllable editor
         * 
         * Returns array of { symbol, isVowel, isGeminate, baseConsonant }
         * Handles: single consonants, geminates (CÀê), affricates (ts, t É, etc.), vowels
         * 
         * NOTE: tÀês is NOT an affricate - it's elongated t + plain s (from -—Ç—Å—è cluster)
         * The tÀê is the geminate that can split, s is a separate consonant
         */
        function parseIPAtoUnits(ipa) {
            const units = [];
            const ipaVowels = new Set(['…ë', 'a', 'o', '…î', '…õ', 'e', 'i', '…™', '…®', 'u', ' ä', ' å']);
            // True affricates (single articulation units) - NOT tÀês which is t + s
            const affricates = [' É ≤ É ≤', 't É ≤', 't É', 'ts', 'd í', ' ÉÀê', ' íÀê'];
            
            let i = 0;
            while (i < ipa.length) {
                // Skip stress markers
                if (ipa[i] === 'Àà' || ipa[i] === 'Àå') {
                    i++;
                    continue;
                }
                
                // Check for affricates/clusters first (multi-char units)
                let foundAffricate = false;
                for (const aff of affricates) {
                    if (ipa.substring(i).startsWith(aff)) {
                        units.push({
                            symbol: aff,
                            isVowel: false,
                            isGeminate: aff.includes('Àê'),
                            baseConsonant: aff.replace('Àê', '')
                        });
                        i += aff.length;
                        foundAffricate = true;
                        break;
                    }
                }
                if (foundAffricate) continue;
                
                // Check for vowels
                if (ipaVowels.has(ipa[i])) {
                    units.push({
                        symbol: ipa[i],
                        isVowel: true,
                        isGeminate: false,
                        baseConsonant: null
                    });
                    i++;
                    continue;
                }
                
                // Consonant - check for following modifiers
                let consonant = ipa[i];
                i++;
                
                // Collect modifiers: palatalization  ≤, length Àê, etc.
                while (i < ipa.length && (ipa[i] === ' ≤' || ipa[i] === ' ∑' || ipa[i] === 'À†' || ipa[i] === 'Àê')) {
                    consonant += ipa[i];
                    i++;
                }
                
                const isGeminate = consonant.includes('Àê');
                
                units.push({
                    symbol: consonant,
                    isVowel: false,
                    isGeminate: isGeminate,
                    baseConsonant: consonant.replace('Àê', '')
                });
            }
            
            return units;
        }
        
        /**
         * Convert IPA units back to string
         */
        function unitsToIPA(units) {
            return units.map(u => u.symbol).join('');
        }
        
        /**
         * Get combined IPA units for the whole word with boundary positions
         * 
         * Returns { units: [...], boundaries: [index1, index2, ...] }
         * where boundaries are indices in units array where syllable breaks occur
         */
        function getWordIPAWithBoundaries(wordIdx) {
            const wordData = processedWords[wordIdx];
            
            // Initialize if needed
            if (!wordData.ipaEditorState) {
                // Parse each syllable's IPA separately to preserve original boundaries
                const syllables = wordData.processed.syllables;
                const allUnits = [];
                const boundaries = [];
                
                for (let sylIdx = 0; sylIdx < syllables.length; sylIdx++) {
                    const sylIPA = syllables[sylIdx].ipa;
                    const sylUnits = parseIPAtoUnits(sylIPA);
                    
                    // Add units from this syllable
                    allUnits.push(...sylUnits);
                    
                    // Add boundary after this syllable (except after last syllable)
                    if (sylIdx < syllables.length - 1) {
                        boundaries.push(allUnits.length);
                    }
                }
                
                wordData.ipaEditorState = { units: allUnits, boundaries };
            }
            
            return wordData.ipaEditorState;
        }
        
        /**
         * Get IPA content for hidden sizer element (controls card width)
         */
        function getIPAForSizer(wordIdx) {
            const wordData = processedWords[wordIdx];
            if (!wordData) return '';
            const syllables = wordData.processed.syllables;
            
            // Always return IPA content for proper sizing
            if (syllables.length <= 1) {
                return syllables[0]?.ipa || '';
            }
            
            // Build IPA string with pipes for boundaries
            const parts = syllables.map(s => s.ipa);
            return parts.join(' | ');
        }
        
        /**
         * Render the IPA syllable boundary editor
         * 
         * Features:
         * - Shows IPA (not Cyrillic) for direct phonetic editing
         * - Red pipe | at syllable boundaries
         * - Drag consonant to move it across boundary
         * - Geminates split when dragged: tÀê ‚Üí t|t (with fade animation on Àê)
         * - Adjacent identical consonants merge: t+t ‚Üí tÀê
         */
        function renderSyllableEditor(wordIdx) {
            const wordData = processedWords[wordIdx];
            const syllables = wordData.processed.syllables;
            
            if (syllables.length <= 1) {
                // Single syllable ‚Äî show IPA only (no boundaries to edit)
                const ipa = syllables[0]?.ipa || '';
                // Add stress mark if this syllable is stressed
                const stressMarker = syllables[0]?.isStressed ? 'Àà' : '';
                return `<div class="syllable-editor" style="font-size: 2em;">${stressMarker}${ipa}</div>`;
            }
            
            const state = getWordIPAWithBoundaries(wordIdx);
            const { units, boundaries } = state;
            
            // Get stress info to add stress marker
            const stressIdx = wordData.processed.stressIndex;
            const showStressMarker = wordData.processed.showStressMarker;
            
            // Find which unit index starts the stressed syllable
            // Syllable N starts at boundary[N-1] (or 0 for first syllable)
            let stressedUnitStart = -1;
            if (showStressMarker && stressIdx >= 0) {
                if (stressIdx === 0) {
                    stressedUnitStart = 0;
                } else if (stressIdx <= boundaries.length) {
                    stressedUnitStart = boundaries[stressIdx - 1];
                }
            }
            
            let html = '<div class="syllable-editor">';
            
            units.forEach((unit, idx) => {
                // Check if there's a boundary before this unit
                const boundaryBefore = boundaries.includes(idx);
                
                if (boundaryBefore) {
                    html += `<span class="boundary-pipe" data-boundary="${idx}">|</span>`;
                }
                
                // Add stress marker before the first unit of the stressed syllable
                if (idx === stressedUnitStart) {
                    html += `<span class="stress-marker">Àà</span>`;
                }
                
                // Is this unit at a boundary? (movable)
                const isAtBoundaryLeft = boundaries.includes(idx); // unit is right after a boundary
                const isAtBoundaryRight = boundaries.includes(idx + 1); // unit is right before a boundary
                const isMovable = !unit.isVowel && (isAtBoundaryLeft || isAtBoundaryRight);
                
                
                // Determine drag direction
                let dragDir = '';
                if (isAtBoundaryLeft && !isAtBoundaryRight) dragDir = 'left';
                else if (isAtBoundaryRight && !isAtBoundaryLeft) dragDir = 'right';
                else if (isAtBoundaryLeft && isAtBoundaryRight) dragDir = 'both';
                
                const classes = [
                    'char-unit',
                    unit.isVowel ? 'vowel' : '',
                    isMovable ? 'movable' : '',
                    unit.isGeminate ? 'geminate' : ''
                ].filter(Boolean).join(' ');
                
                // For geminates, split the display to allow length marker to fade
                let displaySymbol = unit.symbol;
                if (unit.isGeminate && isMovable) {
                    const base = unit.baseConsonant;
                    displaySymbol = `${base}<span class="length-marker">Àê</span>`;
                }
                
                const mouseHandler = isMovable ? 
                    `onmousedown="startDrag(event, ${wordIdx}, ${idx}, '${dragDir}', ${unit.isGeminate}, '${unit.baseConsonant || unit.symbol}')"` 
                    : '';
                
                const title = isMovable ? 
                    (unit.isGeminate ? 'Drag to split and move' : 'Drag to move') : '';
                
                html += `<span class="${classes}" ${mouseHandler} title="${title}" id="unit-${wordIdx}-${idx}">${displaySymbol}</span>`;
            });
            
            html += '</div>';
            return html;
        }
        
        // Drag state
        let dragState = null;
        let dragGhost = null;
        
        /**
         * Start dragging a consonant
         */
        function startDrag(event, wordIdx, unitIdx, dir, isGeminate, baseConsonant) {
            event.preventDefault();
            
            const state = getWordIPAWithBoundaries(wordIdx);
            const { units, boundaries } = state;
            
            
            // Create ghost element
            dragGhost = document.createElement('span');
            dragGhost.className = 'drag-ghost';
            dragGhost.textContent = baseConsonant.replace('Àê', '');
            document.body.appendChild(dragGhost);
            
            // Position ghost at cursor
            dragGhost.style.left = event.clientX + 'px';
            dragGhost.style.top = event.clientY + 'px';
            
            // Find the boundary element based on direction
            const boundaryDataIdx = dir === 'left' ? unitIdx : unitIdx + 1;
            const boundaryEl = document.querySelector(`#card-${wordIdx} .boundary-pipe[data-boundary="${boundaryDataIdx}"]`);
            
            const boundaryX = boundaryEl ? boundaryEl.getBoundingClientRect().left + boundaryEl.offsetWidth / 2 : null;
            
            if (!boundaryX) {
            }
            
            dragState = {
                wordIdx,
                unitIdx,
                dir,
                isGeminate,
                baseConsonant: baseConsonant.replace('Àê', ''),
                startX: event.clientX,
                boundaryX: boundaryX || event.clientX
            };
            
            // Mark original element
            const originalEl = document.getElementById(`unit-${wordIdx}-${unitIdx}`);
            if (originalEl) {
                if (isGeminate) {
                    // Geminate: fade the element (length marker fades separately)
                    originalEl.classList.add('dragging');
                } else {
                    // Non-geminate: hide completely (we're lifting it)
                    originalEl.classList.add('dragging-away');
                }
            }
            
            // Add event listeners
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', endDrag);
        }
        
        /**
         * Handle drag movement
         */
        function onDrag(event) {
            if (!dragState || !dragGhost) return;
            
            // Move ghost
            dragGhost.style.left = event.clientX + 'px';
            dragGhost.style.top = event.clientY + 'px';
            
            // If geminate, fade the length marker based on distance from start
            if (dragState.isGeminate) {
                const originalEl = document.getElementById(`unit-${dragState.wordIdx}-${dragState.unitIdx}`);
                const lengthMarker = originalEl?.querySelector('.length-marker');
                if (lengthMarker) {
                    const distance = Math.abs(event.clientX - dragState.startX);
                    const fadeAmount = Math.min(1, distance / 60);
                    lengthMarker.style.opacity = 1 - fadeAmount;
                }
            }
            
            // Update ghost opacity based on valid drop position
            const crossedBoundary = dragState.dir === 'left' 
                ? event.clientX < dragState.boundaryX - 10
                : event.clientX > dragState.boundaryX + 10;
            
            dragGhost.style.opacity = crossedBoundary ? '1' : '0.5';
        }
        
        /**
         * End drag - execute move if valid drop
         * 
         * Simple rule: if cursor ends up on the opposite side of the pipe from where
         * it started, execute the move. Otherwise return to origin.
         */
        function endDrag(event) {
            if (!dragState) return;
            
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', endDrag);
            
            // Simple check: is cursor on the opposite side of the boundary?
            // For LEFT drag: cursor needs to be LEFT of the pipe (dropX < boundaryX)
            // For RIGHT drag: cursor needs to be RIGHT of the pipe (dropX > boundaryX)
            const crossedBoundary = dragState.dir === 'left' 
                ? event.clientX < dragState.boundaryX
                : event.clientX > dragState.boundaryX;
            
            
            // Clean up ghost
            if (dragGhost) {
                dragGhost.remove();
                dragGhost = null;
            }
            
            // Reset original element
            const originalEl = document.getElementById(`unit-${dragState.wordIdx}-${dragState.unitIdx}`);
            if (originalEl) {
                originalEl.classList.remove('dragging');
                originalEl.classList.remove('dragging-away');
                const lengthMarker = originalEl.querySelector('.length-marker');
                if (lengthMarker) {
                    lengthMarker.style.opacity = '1';
                }
            }
            
            // Execute move if crossed boundary
            if (crossedBoundary) {
                if (dragState.dir === 'left') {
                    moveIPAUnitLeft(dragState.wordIdx, dragState.unitIdx);
                } else {
                    moveIPAUnitRight(dragState.wordIdx, dragState.unitIdx);
                }
            } else {
            }
            
            dragState = null;
        }
        
        /**
         * Move a consonant left across the boundary
         * 
         * RULE: Consonant lands at the EXTREMITY of the destination syllable
         * - Lands immediately to the LEFT of the boundary (right edge of left syllable)
         * - Pushes existing consonants further left (toward vowel)
         */
        function moveIPAUnitLeft(wordIdx, unitIdx) {
            const state = getWordIPAWithBoundaries(wordIdx);
            const { units, boundaries } = state;
            
            const boundaryIdx = boundaries.indexOf(unitIdx);
            if (boundaryIdx === -1) {
                return;
            }
            
            const unit = units[unitIdx];
            const boundaryPos = boundaries[boundaryIdx];
            
            if (unit.isGeminate) {
                // SPLIT: one stays at boundary, one goes immediately left of boundary
                const base = unit.baseConsonant;
                
                // Replace geminate with single (stays on right side of boundary)
                units[unitIdx] = { symbol: base, isVowel: false, isGeminate: false, baseConsonant: base };
                
                // Insert new consonant immediately before the boundary
                units.splice(boundaryPos, 0, { symbol: base, isVowel: false, isGeminate: false, baseConsonant: base });
                
                // Boundary shifts right (we inserted at its position)
                boundaries[boundaryIdx]++;
                
                
                // Check merge with left neighbor
                checkAndMergeAt(units, boundaries, boundaryPos - 1);
                
            } else {
                // SIMPLE MOVE: remove from right of boundary, place at right edge of left syllable
                //
                // Example: v ≤jotÀê | s å with boundary at 4
                // Units: [v ≤(0), j(1), o(2), tÀê(3), s(4),  å(5)]
                // We want: v ≤jotÀês |  å with boundary at 5
                // Result: [v ≤(0), j(1), o(2), tÀê(3), s(4),  å(5)] with boundary at 5
                //
                // The s stays at position 4, but boundary moves from 4 to 5!
                
                const removed = units.splice(unitIdx, 1)[0];
                // After removal: [v ≤, j, o, tÀê,  å] - tÀê at 3,  å at 4
                
                // Insert at boundaryPos (which is now where  å is, but we want s BEFORE  å)
                // splice(4, 0, s) puts s at index 4, pushing  å to 5
                units.splice(boundaryPos, 0, removed);
                // After insert: [v ≤, j, o, tÀê, s,  å] - s at 4,  å at 5
                
                // Boundary moves to 5 (after s, before  å)
                boundaries[boundaryIdx]++;
                
                
                // Check merge with LEFT neighbor (at boundaryPos - 1, which is tÀê at index 3)
                // The moved consonant is now at boundaryPos (index 4)
                checkAndMergeAt(units, boundaries, boundaryPos - 1);
            }
            
            updateDisplayFromState(wordIdx);
            rerenderSyllableEditor(wordIdx);
        }
        
        /**
         * Move a consonant right across the boundary
         * 
         * RULE: Consonant lands at the EXTREMITY of the destination syllable
         * - Lands immediately to the RIGHT of the boundary (left edge of right syllable)
         * - Pushes existing consonants further right (toward vowel)
         */
        function moveIPAUnitRight(wordIdx, unitIdx) {
            const state = getWordIPAWithBoundaries(wordIdx);
            const { units, boundaries } = state;
            
            const boundaryIdx = boundaries.indexOf(unitIdx + 1);
            if (boundaryIdx === -1) {
                return;
            }
            
            const unit = units[unitIdx];
            const boundaryPos = boundaries[boundaryIdx];
            
            if (unit.isGeminate) {
                // SPLIT: one stays before boundary, one goes immediately right of boundary
                const base = unit.baseConsonant;
                
                // Replace geminate with single (stays on left side of boundary)
                units[unitIdx] = { symbol: base, isVowel: false, isGeminate: false, baseConsonant: base };
                
                // The boundary is between unitIdx and boundaryPos
                // Insert new consonant AT boundaryPos (which pushes everything right)
                // This puts it immediately AFTER the boundary
                units.splice(boundaryPos, 0, { symbol: base, isVowel: false, isGeminate: false, baseConsonant: base });
                
                // Boundary stays at boundaryPos (we inserted at its position, pushing it right)
                // Actually no - splice at boundaryPos pushes boundary right too
                // We want boundary to stay between the two t's
                // So boundary should stay at unitIdx + 1 = boundaryPos
                boundaries[boundaryIdx] = boundaryPos;  // Keep it where it was (between the two t's)
                
                
                // The new consonant at boundaryPos, check if it merges with its right neighbor
                checkAndMergeAt(units, boundaries, boundaryPos);
                
            } else {
                // SIMPLE MOVE: remove from left of boundary, place immediately right of boundary
                //
                // Example: v ≤jotÀês |  å with boundary at 5, s at index 4
                // Units: [v ≤(0), j(1), o(2), tÀê(3), s(4),  å(5)]
                // We want: v ≤jotÀê | s å with boundary at 4
                // Result: [v ≤(0), j(1), o(2), tÀê(3), s(4),  å(5)] with boundary at 4
                //
                // The s stays at position 4, but boundary moves from 5 to 4!
                
                const removed = units.splice(unitIdx, 1)[0];
                // After removal: [v ≤, j, o, tÀê,  å] - tÀê at 3,  å at 4
                // Boundary was at 5, now should point to index 4 (where  å now is)
                
                // Boundary shifts left by 1 (we removed before it)
                boundaries[boundaryIdx]--;
                const newBoundaryPos = boundaries[boundaryIdx]; // Now 4
                
                // Insert AFTER the boundary (at newBoundaryPos, which is where  å is)
                // splice(4, 0, s) puts s at 4, pushing  å to 5
                units.splice(newBoundaryPos, 0, removed);
                // After insert: [v ≤, j, o, tÀê, s,  å] - but we want s AFTER boundary!
                
                // Hmm, this puts s back where it was. We need to insert at newBoundaryPos + 1
                // But wait, after removal  å is at 4. We want s to go AFTER  å.
                // splice(5, 0, s) would put s at 5, after  å.
                // But array only has 5 elements [0-4], so splice(5,0,s) appends.
                
                // Actually, the issue is we want boundary to DECREASE, not stay same.
                // Let me reconsider...
                //
                // Before: [v ≤,j,o,tÀê,s, å] boundary=5 ‚Üí v ≤jotÀês |  å
                // After:  [v ≤,j,o,tÀê,s, å] boundary=4 ‚Üí v ≤jotÀê | s å
                //
                // The array doesn't change! Only the boundary moves left.
                // So we should: remove s, decrease boundary, insert s at NEW boundary position.
                
                // WAIT. That's what we did. Let me re-trace:
                // 1. Remove s at 4: [v ≤,j,o,tÀê, å]
                // 2. boundary-- ‚Üí 4
                // 3. Insert at 4: [v ≤,j,o,tÀê,s, å] with s at 4
                // 4. boundary stays at 4
                // Result: v ≤jotÀê | s å ‚úì
                //
                // But we're also doing boundary++ which puts it back to 5!
                
                // DON'T increment boundary - it should stay at newBoundaryPos
                // (we removed before boundary, inserted at boundary, net: boundary stays decreased)
                
                
                // Check merge with right neighbor
                const mergedAt = checkAndMergeAt(units, boundaries, newBoundaryPos);
                
                if (mergedAt) {
                    boundaries[boundaryIdx] = newBoundaryPos;
                }
            }
            
            updateDisplayFromState(wordIdx);
            rerenderSyllableEditor(wordIdx);
        }
        
        /**
         * Re-render just the syllable editor without rebuilding entire output
         */
        function rerenderSyllableEditor(wordIdx) {
            const cardBack = document.querySelector(`#card-${wordIdx} .word-card-back`);
            if (!cardBack) return;
            
            // Update the title with stress mark
            const titleEl = cardBack.querySelector('.card-back-title');
            if (titleEl) {
                const wordData = processedWords[wordIdx];
                titleEl.textContent = getCyrillicWithStress(wordData.processed);
            }
            
            // Find the syllable-editor div and replace its content
            const editorContainer = cardBack.querySelector('.syllable-editor');
            if (editorContainer) {
                const newEditorHTML = renderSyllableEditor(wordIdx);
                // Extract just the inner content (between the outer div tags)
                const temp = document.createElement('div');
                temp.innerHTML = newEditorHTML;
                editorContainer.innerHTML = temp.firstChild.innerHTML;
            }
        }
        
        /**
         * Check if units at idx and idx+1 should merge into a geminate
         * Returns true if merge happened, false otherwise
         * 
         * Special case: if merging at a boundary, the boundary shifts to after the geminate
         */
        function checkAndMergeAt(units, boundaries, idx) {
            
            if (idx < 0 || idx >= units.length - 1) {
                return false;
            }
            
            const current = units[idx];
            const next = units[idx + 1];
            
            
            const boundaryBetween = boundaries.includes(idx + 1);
            
            // Merge if same base consonant, neither is already geminate
            // ALLOW merge even if boundary is between them (we'll shift the boundary)
            if (!current.isVowel && !next.isVowel &&
                current.baseConsonant && next.baseConsonant &&
                current.baseConsonant === next.baseConsonant &&
                !current.isGeminate && !next.isGeminate) {
                
                
                // If there was a boundary between them, note it
                if (boundaryBetween) {
                }
                
                // Merge into geminate
                units[idx] = {
                    symbol: current.baseConsonant + 'Àê',
                    isVowel: false,
                    isGeminate: true,
                    baseConsonant: current.baseConsonant
                };
                units.splice(idx + 1, 1);
                
                // Adjust boundaries (shift down any that were after the removed element)
                for (let i = 0; i < boundaries.length; i++) {
                    if (boundaries[i] > idx + 1) {
                        boundaries[i]--;
                    } else if (boundaries[i] === idx + 1) {
                        // Boundary was between the two consonants - it stays at idx + 1
                        // which now points to what was after the second consonant
                    }
                }
                
                return true;
            } else {
                return false;
            }
        }
        
        /**
         * Update the displayed IPA from the editor state
         * Also updates the front card display and Singer's View if visible
         */
        function updateDisplayFromState(wordIdx) {
            const wordData = processedWords[wordIdx];
            const state = wordData.ipaEditorState;
            const { units, boundaries } = state;
            
            // Split units into syllables based on boundaries
            const syllableIPAs = [];
            let start = 0;
            
            for (const boundary of boundaries) {
                syllableIPAs.push(unitsToIPA(units.slice(start, boundary)));
                start = boundary;
            }
            syllableIPAs.push(unitsToIPA(units.slice(start)));
            
            // Update syllable IPA strings
            wordData.processed.syllables.forEach((syl, idx) => {
                if (idx < syllableIPAs.length) {
                    syl.ipa = syllableIPAs[idx];
                }
            });
            
            // Update the front card IPA display
            const cardFront = document.querySelector(`#card-${wordIdx} .word-card-front .ipa`);
            if (cardFront) {
                // Build full IPA with boundaries and stress mark
                const parts = [];
                start = 0;
                for (const b of boundaries) {
                    parts.push(units.slice(start, b).map(u => u.symbol).join(''));
                    start = b;
                }
                parts.push(units.slice(start).map(u => u.symbol).join(''));
                
                // Add stress mark to stressed syllable
                const stressIdx = wordData.processed.stressIndex;
                if (stressIdx >= 0 && stressIdx < parts.length && wordData.processed.showStressMarker) {
                    parts[stressIdx] = 'Àà' + parts[stressIdx];
                }
                
                let fullIPA = parts.filter(p => p.length > 0).join(' ');
                fullIPA = applyNotationPreferences(applyStyleSettings(fullIPA));
                cardFront.textContent = '/' + fullIPA + '/';
            }
            
            // If Singer's View is active, update it too
            if (currentView === 'singers') {
                renderSingersView();
            }
        }
        
        // NOTE: moveCharLeft() and moveCharRight() removed in v4.14
        // The syllable boundary editor now uses drag-and-drop with moveIPAUnitLeft/Right
        
        /**
         * Re-run IPA transcription for a single syllable after boundary change
         * 
         * This keeps the IPA accurate after user moves consonants around.
         * Position-dependent rules (stressed/unstressed) are recalculated.
         */
        
        // Global storage for locked syllables (prevents vowel reduction)
        // Key format: "wordIdx-sylIdx", Value: true
        const lockedSyllables = new Set();
        
        /**
         * Toggle lock state for a syllable (prevents/allows vowel reduction)
         * @param {number} wordIdx - Word index
         * @param {number} sylIdx - Syllable index within word
         */
        function toggleLock(wordIdx, sylIdx, event) {
            const key = `${wordIdx}-${sylIdx}`;
            if (lockedSyllables.has(key)) {
                lockedSyllables.delete(key);
            } else {
                lockedSyllables.add(key);
            }
            // Update button appearance immediately
            const btn = event.target;
            btn.textContent = lockedSyllables.has(key) ? 'üîì' : 'üîí';
            btn.style.opacity = lockedSyllables.has(key) ? '1' : '0.4';
            // Retranscribe and refresh display
            retranscribeSyllablesWithLock(wordIdx);
            renderOutput();
        }
        
        /**
         * Retranscribe all syllables in a word, respecting locks
         * @param {number} wordIdx - Word index
         */
        function retranscribeSyllablesWithLock(wordIdx) {
            const wordData = processedWords[wordIdx];
            if (!wordData) return;
            
            // Build set of locked positions for this word
            const wordLockedPositions = new Set();
            wordData.processed.syllables.forEach((syl, idx) => {
                if (lockedSyllables.has(`${wordIdx}-${idx}`)) {
                    const position = getSyllablePosition(idx, wordData.processed.stressIndex, wordData.processed.syllables.length);
                    wordLockedPositions.add(position);
                }
            });
            
            // Retranscribe each syllable
            wordData.processed.syllables.forEach((syllable, idx) => {
                const position = getSyllablePosition(idx, wordData.processed.stressIndex, wordData.processed.syllables.length);
                syllable.ipa = transcribeSyllable(syllable.cyrillic, position, { 
                    word: wordData.originalWord, 
                    syllables: wordData.processed.syllables 
                }, wordLockedPositions);
            });
        }
        
        function retranscribeSyllables(wordIdx, sylIdx) {
            const wordData = processedWords[wordIdx];
            const syllable = wordData.processed.syllables[sylIdx];
            const position = getSyllablePosition(sylIdx, wordData.processed.stressIndex, wordData.processed.syllables.length);
            
            // Retranscribe this syllable with current position context
            syllable.ipa = transcribeSyllable(syllable.cyrillic, position, { 
                word: wordData.originalWord, 
                syllables: wordData.processed.syllables 
            });
        }

        function clearAll() {
            document.getElementById('russianInput').value = '';
            processedWords = [];
            renderOutput();
            hideViewToggle();
            switchView('workspace');
            editingWordIndex = null;
            const singersViewControls = document.getElementById('singersViewControls');
            if (singersViewControls) {
                singersViewControls.style.display = 'none';
            }
            updatePlaceholderVisibility(); // Show animated placeholder again
        }

        function copyIPA() {
            const ipaText = processedWords
                .map(wd => wd.processed.syllables.map(s => s.ipa).join(''))
                .join(' ');
            
            navigator.clipboard.writeText(ipaText).then(() => {
                alert('IPA transcription copied to clipboard!');
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }
        
        // ============================================================================
        // VIEW SWITCHING - Workspace ‚Üî Singer's View
        // ============================================================================
        
        let currentView = 'workspace';
        let editingWordIndex = null;
        let metadataPanelExpanded = true;
        let metadataComplete = false;
        
        function switchView(view) {
            currentView = view;
            
            const workspaceView = document.getElementById('workspaceView');
            const singersView = document.getElementById('singersView');
            const singersViewControls = document.getElementById('singersViewControls');
            const workspaceTab = document.getElementById('workspaceTab');
            const singersTab = document.getElementById('singersTab');
            
            if (view === 'workspace') {
                workspaceView.style.display = 'block';
                singersView.style.display = 'none';
                singersViewControls.style.display = 'none';
                workspaceTab.classList.add('active');
                singersTab.classList.remove('active');
            } else {
                workspaceView.style.display = 'none';
                singersView.style.display = 'block';
                singersViewControls.style.display = 'flex';
                workspaceTab.classList.remove('active');
                singersTab.classList.add('active');
                
                // Check if metadata is complete
                validateMetadata();
                if (!metadataComplete) {
                    expandMetadataPanel();
                }
                
                renderSingersView();
            }
        }
        
        // ============================================================================
        // METADATA PANEL FUNCTIONS
        // ============================================================================
        
        function toggleMetadataPanel() {
            const panel = document.getElementById('metadataPanel');
            metadataPanelExpanded = !metadataPanelExpanded;
            
            if (metadataPanelExpanded) {
                panel.classList.remove('collapsed');
            } else {
                panel.classList.add('collapsed');
            }
        }
        
        function expandMetadataPanel() {
            const panel = document.getElementById('metadataPanel');
            metadataPanelExpanded = true;
            panel.classList.remove('collapsed');
        }
        
        function collapseMetadataPanel() {
            const panel = document.getElementById('metadataPanel');
            metadataPanelExpanded = false;
            panel.classList.add('collapsed');
        }
        
        function updateDocumentMeta() {
            // Read values from form
            documentMeta.title = document.getElementById('metaTitle')?.value.trim() || '';
            documentMeta.poet = document.getElementById('metaPoet')?.value.trim() || '';
            documentMeta.composer = document.getElementById('metaComposer')?.value.trim() || '';
            documentMeta.opus = document.getElementById('metaOpus')?.value.trim() || '';
            
            // Validate and update UI
            validateMetadata();
            updateMetadataSummary();
            
            // Re-render canvas with new metadata
            if (currentView === 'singers') {
                renderSingersView();
            }
        }
        
        function validateMetadata() {
            const title = documentMeta.title;
            const poet = documentMeta.poet;
            const composer = documentMeta.composer;
            
            const titleInput = document.getElementById('metaTitle');
            const poetInput = document.getElementById('metaPoet');
            const composerInput = document.getElementById('metaComposer');
            const validationEl = document.getElementById('metadataValidation');
            
            let errors = [];
            
            // Check required fields
            if (!title) {
                errors.push('Title');
                titleInput?.classList.add('invalid');
            } else {
                titleInput?.classList.remove('invalid');
            }
            
            if (!poet) {
                errors.push('Poet');
                poetInput?.classList.add('invalid');
            } else {
                poetInput?.classList.remove('invalid');
            }
            
            if (!composer) {
                errors.push('Composer');
                composerInput?.classList.add('invalid');
            } else {
                composerInput?.classList.remove('invalid');
            }
            
            metadataComplete = errors.length === 0;
            
            // Update validation message
            if (validationEl) {
                if (errors.length > 0) {
                    validationEl.textContent = 'Required: ' + errors.join(', ');
                } else {
                    validationEl.textContent = '';
                }
            }
            
            return metadataComplete;
        }
        
        function updateMetadataSummary() {
            const summaryEl = document.getElementById('metadataSummary');
            if (!summaryEl) return;
            
            if (metadataComplete) {
                // Show condensed info
                let summary = documentMeta.title;
                if (documentMeta.poet) {
                    summary += ' ‚Äî ' + documentMeta.poet;
                }
                if (documentMeta.composer && documentMeta.composer !== documentMeta.poet) {
                    summary += ' / ' + documentMeta.composer;
                }
                // Truncate if too long
                if (summary.length > 50) {
                    summary = summary.substring(0, 47) + '...';
                }
                summaryEl.textContent = summary;
                summaryEl.classList.add('complete');
                summaryEl.classList.remove('incomplete');
            } else {
                summaryEl.textContent = 'Enter work details';
                summaryEl.classList.add('incomplete');
                summaryEl.classList.remove('complete');
            }
        }
        
        function setPageSize(size) {
            documentMeta.pageSize = size;
            
            const btnLetter = document.getElementById('btnLetter');
            const btnA4 = document.getElementById('btnA4');
            
            if (size === 'letter') {
                btnLetter?.classList.add('active');
                btnA4?.classList.remove('active');
            } else {
                btnLetter?.classList.remove('active');
                btnA4?.classList.add('active');
            }
            
            // Re-render canvas with new page size
            if (currentView === 'singers') {
                renderSingersView();
            }
        }
        
        function showViewToggle() {
            const toggle = document.getElementById('viewToggle');
            if (toggle && processedWords.length > 0) {
                toggle.style.display = 'flex';
            }
        }
        
        function hideViewToggle() {
            const toggle = document.getElementById('viewToggle');
            if (toggle) {
                toggle.style.display = 'none';
            }
        }
        
        // ============================================================================
        // SINGER'S VIEW - Interlinear Display with Tap-to-Edit
        // ============================================================================
        
        function addStressMark(cyrillic, stressedSyllableIndex) {
            // Add combining acute accent (ÃÅ) to the stressed vowel
            // Exception: —ë already indicates stress via its dieresis, so no acute needed
            if (stressedSyllableIndex < 0) return cyrillic;
            
            const vowelSet = new Set(['–∞', '–µ', '—ë', '–∏', '–æ', '—É', '—ã', '—ç', '—é', '—è',
                                       '–ê', '–ï', '–Å', '–ò', '–û', '–£', '–´', '–≠', '–Æ', '–Ø']);
            let syllableCount = 0;
            let result = '';
            
            for (let i = 0; i < cyrillic.length; i++) {
                const char = cyrillic[i];
                const lowerChar = char.toLowerCase();
                result += char;
                
                if (vowelSet.has(char)) {
                    // Skip adding acute to —ë - the dieresis already indicates stress
                    if (syllableCount === stressedSyllableIndex && lowerChar !== '—ë') {
                        result += '\u0301'; // Combining acute accent
                    }
                    syllableCount++;
                }
            }
            
            return result;
        }
        
        // ============================================================================
        // SINGER'S VIEW - Canvas-based Zoomable Viewport
        // ============================================================================
        // The Singer's View renders to a canvas that can be pinch-zoomed and panned.
        // This creates a "live PDF preview" that IS the document being exported.
        // 
        // Lifecycle:
        // - Ephemeral: regenerates on every edit (debounced)
        // - Stable: user is reviewing (zoom/pan activity)  
        // - Persistent: user exports/prints (becomes actual file)
        // ============================================================================
        
        let canvasScale = 1;
        let canvasOffsetX = 0;
        let canvasOffsetY = 0;
        let renderDebounceTimer = null;
        let lastRenderTime = 0;
        const RENDER_DEBOUNCE_MS = 150;
        
        // ============================================================================
        // COMPOSER DATABASE - Canonical names with search aliases
        // ============================================================================
        
        const COMPOSER_DATABASE = [
            // === THE BIG NAMES ===
            { canonical: "Tchaikovsky, Pyotr Ilyich", search: ["—á–∞–π–∫–æ–≤—Å–∫–∏–π", "–ø—ë—Ç—Ä", "–ø–µ—Ç—Ä", "tchaikovsky", "chaikovsky", "tschaikowsky", "tschaikovsky", "czajkowski", "ciaikovski", "pyotr", "peter", "piotr"], birth: 1840, death: 1893 },
            { canonical: "Rachmaninoff, Sergei", search: ["—Ä–∞—Ö–º–∞–Ω–∏–Ω–æ–≤", "—Å–µ—Ä–≥–µ–π", "rachmaninoff", "rachmaninov", "rakhmaninov", "rachmaninow", "sergei", "sergey", "serge"], birth: 1873, death: 1943 },
            { canonical: "Mussorgsky, Modest", search: ["–º—É—Å–æ—Ä–≥—Å–∫–∏–π", "–º–æ–¥–µ—Å—Ç", "mussorgsky", "musorgsky", "moussorgsky", "musorgskij", "modest"], birth: 1839, death: 1881 },
            { canonical: "Rimsky-Korsakov, Nikolai", search: ["—Ä–∏–º—Å–∫–∏–π-–∫–æ—Ä—Å–∞–∫–æ–≤", "—Ä–∏–º—Å–∫–∏–π", "–∫–æ—Ä—Å–∞–∫–æ–≤", "–Ω–∏–∫–æ–ª–∞–π", "rimsky-korsakov", "rimsky", "korsakov", "rimskij", "nikolai", "nikolay"], birth: 1844, death: 1908 },
            { canonical: "Glinka, Mikhail", search: ["–≥–ª–∏–Ω–∫–∞", "–º–∏—Ö–∞–∏–ª", "glinka", "mikhail", "michail", "michael"], birth: 1804, death: 1857 },
            { canonical: "Borodin, Alexander", search: ["–±–æ—Ä–æ–¥–∏–Ω", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "borodin", "alexander", "aleksandr"], birth: 1833, death: 1887 },
            { canonical: "Cui, C√©sar", search: ["–∫—é–∏", "—Ü–µ–∑–∞—Ä—å", "cui", "cesar", "caesar", "kyui", "tzesar"], birth: 1835, death: 1918 },
            { canonical: "Balakirev, Mily", search: ["–±–∞–ª–∞–∫–∏—Ä–µ–≤", "–º–∏–ª–∏–π", "balakirev", "balakirew", "mily", "milij", "mili"], birth: 1837, death: 1910 },
            { canonical: "Prokofiev, Sergei", search: ["–ø—Ä–æ–∫–æ—Ñ—å–µ–≤", "—Å–µ—Ä–≥–µ–π", "prokofiev", "prokofieff", "prokofjev", "prokofjew", "sergei", "sergey", "serge"], birth: 1891, death: 1953 },
            { canonical: "Shostakovich, Dmitri", search: ["—à–æ—Å—Ç–∞–∫–æ–≤–∏—á", "–¥–º–∏—Ç—Ä–∏–π", "shostakovich", "schostakowitsch", "chostakovitch", "sostakovic", "dmitri", "dmitry", "dmitrij"], birth: 1906, death: 1975 },
            { canonical: "Stravinsky, Igor", search: ["—Å—Ç—Ä–∞–≤–∏–Ω—Å–∫–∏–π", "–∏–≥–æ—Ä—å", "stravinsky", "strawinsky", "stravinskij", "igor"], birth: 1882, death: 1971 },
            // === ROMANTIC ERA ===
            { canonical: "Arensky, Anton", search: ["–∞—Ä–µ–Ω—Å–∫–∏–π", "–∞–Ω—Ç–æ–Ω", "arensky", "arenski", "anton"], birth: 1861, death: 1906 },
            { canonical: "Dargomyzhsky, Alexander", search: ["–¥–∞—Ä–≥–æ–º—ã–∂—Å–∫–∏–π", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "dargomyzhsky", "dargomyschski", "dargomijsky", "alexander", "aleksandr"], birth: 1813, death: 1869 },
            { canonical: "Rubinstein, Anton", search: ["—Ä—É–±–∏–Ω—à—Ç–µ–π–Ω", "–∞–Ω—Ç–æ–Ω", "rubinstein", "rubin≈°tejn", "anton"], birth: 1829, death: 1894 },
            { canonical: "Taneyev, Sergei", search: ["—Ç–∞–Ω–µ–µ–≤", "—Å–µ—Ä–≥–µ–π", "taneyev", "taneiev", "tanejew", "taneev", "sergei", "sergey"], birth: 1856, death: 1915 },
            { canonical: "Glazunov, Alexander", search: ["–≥–ª–∞–∑—É–Ω–æ–≤", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "glazunov", "glasunow", "alexander", "aleksandr"], birth: 1865, death: 1936 },
            { canonical: "Lyadov, Anatoly", search: ["–ª—è–¥–æ–≤", "–∞–Ω–∞—Ç–æ–ª–∏–π", "lyadov", "liadov", "ljadov", "anatoly", "anatoli"], birth: 1855, death: 1914 },
            { canonical: "Medtner, Nikolai", search: ["–º–µ—Ç–Ω–µ—Ä", "–Ω–∏–∫–æ–ª–∞–π", "medtner", "metner", "nikolai", "nikolay", "nicolas"], birth: 1880, death: 1951 },
            { canonical: "Scriabin, Alexander", search: ["—Å–∫—Ä—è–±–∏–Ω", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "scriabin", "skriabin", "skrjabin", "scriabine", "alexander", "aleksandr"], birth: 1872, death: 1915 },
            { canonical: "Gretchaninov, Alexander", search: ["–≥—Ä–µ—á–∞–Ω–∏–Ω–æ–≤", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "gretchaninov", "grechaninov", "gretchaninoff", "alexander", "aleksandr"], birth: 1864, death: 1956 },
            { canonical: "Ippolitov-Ivanov, Mikhail", search: ["–∏–ø–ø–æ–ª–∏—Ç–æ–≤-–∏–≤–∞–Ω–æ–≤", "–º–∏—Ö–∞–∏–ª", "ippolitov-ivanov", "ippolitov", "ivanov", "mikhail", "michail"], birth: 1859, death: 1935 },
            { canonical: "Kalinnikov, Vasily", search: ["–∫–∞–ª–∏–Ω–Ω–∏–∫–æ–≤", "–≤–∞—Å–∏–ª–∏–π", "kalinnikov", "vasily", "vasili", "wassili"], birth: 1866, death: 1901 },
            { canonical: "Rebikov, Vladimir", search: ["—Ä–µ–±–∏–∫–æ–≤", "–≤–ª–∞–¥–∏–º–∏—Ä", "rebikov", "vladimir"], birth: 1866, death: 1920 },
            // === 20TH CENTURY ===
            { canonical: "Kabalevsky, Dmitry", search: ["–∫–∞–±–∞–ª–µ–≤—Å–∫–∏–π", "–¥–º–∏—Ç—Ä–∏–π", "kabalevsky", "kabalewsky", "kabalevskij", "dmitry", "dmitri"], birth: 1904, death: 1987 },
            { canonical: "Khachaturian, Aram", search: ["—Ö–∞—á–∞—Ç—É—Ä—è–Ω", "–∞—Ä–∞–º", "khachaturian", "chatschaturjan", "khatchaturian", "aram"], birth: 1903, death: 1978 },
            { canonical: "Myaskovsky, Nikolai", search: ["–º—è—Å–∫–æ–≤—Å–∫–∏–π", "–Ω–∏–∫–æ–ª–∞–π", "myaskovsky", "miaskovsky", "mjaskowski", "nikolai", "nikolay"], birth: 1881, death: 1950 },
            { canonical: "Sviridov, Georgy", search: ["—Å–≤–∏—Ä–∏–¥–æ–≤", "–≥–µ–æ—Ä–≥–∏–π", "sviridov", "georgy", "georgi", "yuri"], birth: 1915, death: 1998 },
            { canonical: "Schnittke, Alfred", search: ["—à–Ω–∏—Ç–∫–µ", "–∞–ª—å—Ñ—Ä–µ–¥", "schnittke", "shnitke", "alfred"], birth: 1934, death: 1998 },
            { canonical: "Gubaidulina, Sofia", search: ["–≥—É–±–∞–π–¥—É–ª–∏–Ω–∞", "—Å–æ—Ñ–∏—è", "gubaidulina", "gubajdulina", "sofia", "sofiya", "sophie"], birth: 1931, death: null },
            { canonical: "Shchedrin, Rodion", search: ["—â–µ–¥—Ä–∏–Ω", "—Ä–æ–¥–∏–æ–Ω", "shchedrin", "schedrin", "chtchedrine", "rodion"], birth: 1932, death: 2025 },
            // === EARLIER COMPOSERS ===
            { canonical: "Bortniansky, Dmitry", search: ["–±–æ—Ä—Ç–Ω—è–Ω—Å–∫–∏–π", "–¥–º–∏—Ç—Ä–∏–π", "bortniansky", "bortnjanski", "dmitry", "dmitri"], birth: 1751, death: 1825 },
            { canonical: "Alyabyev, Alexander", search: ["–∞–ª—è–±—å–µ–≤", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "alyabyev", "aljabjew", "aliabiev", "alexander", "aleksandr"], birth: 1787, death: 1851 },
            { canonical: "Varlamov, Alexander", search: ["–≤–∞—Ä–ª–∞–º–æ–≤", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "varlamov", "alexander", "aleksandr"], birth: 1801, death: 1848 },
            { canonical: "Gurilyov, Alexander", search: ["–≥—É—Ä–∏–ª—ë–≤", "–≥—É—Ä–∏–ª–µ–≤", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "gurilyov", "gurilev", "guriljow", "alexander", "aleksandr"], birth: 1803, death: 1858 },
            // === CHURCH MUSIC ===
            { canonical: "Kastalsky, Alexander", search: ["–∫–∞—Å—Ç–∞–ª—å—Å–∫–∏–π", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "kastalsky", "kastalski", "alexander", "aleksandr"], birth: 1856, death: 1926 },
            { canonical: "Chesnokov, Pavel", search: ["—á–µ—Å–Ω–æ–∫–æ–≤", "–ø–∞–≤–µ–ª", "chesnokov", "tschesnokow", "pavel", "paul"], birth: 1877, death: 1944 },
            { canonical: "Arkhangelsky, Alexander", search: ["–∞—Ä—Ö–∞–Ω–≥–µ–ª—å—Å–∫–∏–π", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "arkhangelsky", "archangelski", "alexander", "aleksandr"], birth: 1846, death: 1924 },
            // === OTHER SIGNIFICANT ===
            { canonical: "Gli√®re, Reinhold", search: ["–≥–ª–∏—ç—Ä", "—Ä–µ–π–Ω–≥–æ–ª—å–¥", "gliere", "glier", "reinhold"], birth: 1875, death: 1956 },
            { canonical: "Tcherepnin, Nikolai", search: ["—á–µ—Ä–µ–ø–Ω–∏–Ω", "–Ω–∏–∫–æ–ª–∞–π", "tcherepnin", "cherepnin", "tscherepnin", "nikolai", "nikolay"], birth: 1873, death: 1945 },
            { canonical: "Tcherepnin, Alexander", search: ["—á–µ—Ä–µ–ø–Ω–∏–Ω", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "tcherepnin", "cherepnin", "tscherepnin", "alexander", "aleksandr"], birth: 1899, death: 1977 },
        ];
        
        // ============================================================================
        // POET DATABASE - Canonical names with search aliases
        // ============================================================================
        
        const POET_DATABASE = [
            // === GOLDEN AGE ===
            { canonical: "Pushkin, Aleksandr Sergeyevich", search: ["–ø—É—à–∫–∏–Ω", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "—Å–µ—Ä–≥–µ–µ–≤–∏—á", "pushkin", "pouchkine", "puschkin", "puszkin", "aleksandr", "alexander"], birth: 1799, death: 1837 },
            { canonical: "Lermontov, Mikhail", search: ["–ª–µ—Ä–º–æ–Ω—Ç–æ–≤", "–º–∏—Ö–∞–∏–ª", "lermontov", "lermontow", "mikhail", "michail", "michael"], birth: 1814, death: 1841 },
            { canonical: "Tyutchev, Fyodor", search: ["—Ç—é—Ç—á–µ–≤", "—Ñ—ë–¥–æ—Ä", "—Ñ–µ–¥–æ—Ä", "tyutchev", "tjutschew", "tiutchev", "fyodor", "fedor", "theodore"], birth: 1803, death: 1873 },
            { canonical: "Fet, Afanasy", search: ["—Ñ–µ—Ç", "–∞—Ñ–∞–Ω–∞—Å–∏–π", "fet", "afanasy", "afanasij", "afanasi"], birth: 1820, death: 1892 },
            { canonical: "Koltsov, Aleksey", search: ["–∫–æ–ª—å—Ü–æ–≤", "–∞–ª–µ–∫—Å–µ–π", "koltsov", "kolzow", "kol'cov", "aleksey", "alexey", "alexei"], birth: 1809, death: 1842 },
            { canonical: "Nekrasov, Nikolai", search: ["–Ω–µ–∫—Ä–∞—Å–æ–≤", "–Ω–∏–∫–æ–ª–∞–π", "nekrasov", "nekrassow", "nikolai", "nikolay"], birth: 1821, death: 1878 },
            { canonical: "Tolstoy, Aleksey Konstantinovich", search: ["—Ç–æ–ª—Å—Ç–æ–π", "–∞–ª–µ–∫—Å–µ–π", "–∫–æ–Ω—Å—Ç–∞–Ω—Ç–∏–Ω–æ–≤–∏—á", "tolstoy", "tolstoi", "aleksey", "alexey", "konstantinovich", "a.k."], birth: 1817, death: 1875 },
            { canonical: "Pleshcheyev, Aleksey", search: ["–ø–ª–µ—â–µ–µ–≤", "–∞–ª–µ–∫—Å–µ–π", "pleshcheyev", "pleschtschejew", "plescheev", "aleksey", "alexey"], birth: 1825, death: 1893 },
            { canonical: "Mey, Lev", search: ["–º–µ–π", "–ª–µ–≤", "mey", "mei", "lev", "leo"], birth: 1822, death: 1862 },
            { canonical: "Polonsky, Yakov", search: ["–ø–æ–ª–æ–Ω—Å–∫–∏–π", "—è–∫–æ–≤", "polonsky", "polonski", "yakov", "jakov", "jacob"], birth: 1819, death: 1898 },
            { canonical: "Maikov, Apollon", search: ["–º–∞–π–∫–æ–≤", "–∞–ø–æ–ª–ª–æ–Ω", "maikov", "majkow", "apollon", "apollo"], birth: 1821, death: 1897 },
            { canonical: "Apukhtin, Aleksey", search: ["–∞–ø—É—Ö—Ç–∏–Ω", "–∞–ª–µ–∫—Å–µ–π", "apukhtin", "apuchtin", "aleksey", "alexey"], birth: 1840, death: 1893 },
            { canonical: "Rathaus, Daniil", search: ["—Ä–∞—Ç–≥–∞—É–∑", "–¥–∞–Ω–∏–∏–ª", "rathaus", "ratgauz", "daniil", "daniel"], birth: 1868, death: 1937 },
            // === PRE-GOLDEN AGE ===
            { canonical: "Derzhavin, Gavriil", search: ["–¥–µ—Ä–∂–∞–≤–∏–Ω", "–≥–∞–≤—Ä–∏–∏–ª", "derzhavin", "derschawin", "gavriil", "gavrila"], birth: 1743, death: 1816 },
            { canonical: "Zhukovsky, Vasily", search: ["–∂—É–∫–æ–≤—Å–∫–∏–π", "–≤–∞—Å–∏–ª–∏–π", "zhukovsky", "schukowski", "zhukovskij", "vasily", "vassili", "basil"], birth: 1783, death: 1852 },
            { canonical: "Batyushkov, Konstantin", search: ["–±–∞—Ç—é—à–∫–æ–≤", "–∫–æ–Ω—Å—Ç–∞–Ω—Ç–∏–Ω", "batyushkov", "batjuschkow", "konstantin"], birth: 1787, death: 1855 },
            { canonical: "Delvig, Anton", search: ["–¥–µ–ª—å–≤–∏–≥", "–∞–Ω—Ç–æ–Ω", "delvig", "delwig", "anton"], birth: 1798, death: 1831 },
            { canonical: "Baratynsky, Yevgeny", search: ["–±–∞—Ä–∞—Ç—ã–Ω—Å–∫–∏–π", "–µ–≤–≥–µ–Ω–∏–π", "baratynsky", "boratynski", "yevgeny", "evgeni", "eugene"], birth: 1800, death: 1844 },
            // === SILVER AGE ===
            { canonical: "Blok, Alexander", search: ["–±–ª–æ–∫", "–∞–ª–µ–∫—Å–∞–Ω–¥—Ä", "blok", "block", "alexander", "aleksandr"], birth: 1880, death: 1921 },
            { canonical: "Akhmatova, Anna", search: ["–∞—Ö–º–∞—Ç–æ–≤–∞", "–∞–Ω–Ω–∞", "akhmatova", "achmatowa", "anna"], birth: 1889, death: 1966 },
            { canonical: "Tsvetaeva, Marina", search: ["—Ü–≤–µ—Ç–∞–µ–≤–∞", "–º–∞—Ä–∏–Ω–∞", "tsvetaeva", "zwetajewa", "cvetaeva", "marina"], birth: 1892, death: 1941 },
            { canonical: "Mandelstam, Osip", search: ["–º–∞–Ω–¥–µ–ª—å—à—Ç–∞–º", "–æ—Å–∏–ø", "mandelstam", "mandelshtam", "osip"], birth: 1891, death: 1938 },
            { canonical: "Pasternak, Boris", search: ["–ø–∞—Å—Ç–µ—Ä–Ω–∞–∫", "–±–æ—Ä–∏—Å", "pasternak", "boris"], birth: 1890, death: 1960 },
            { canonical: "Yesenin, Sergei", search: ["–µ—Å–µ–Ω–∏–Ω", "—Å–µ—Ä–≥–µ–π", "yesenin", "esenin", "jessenin", "sergei", "sergey"], birth: 1895, death: 1925 },
            { canonical: "Mayakovsky, Vladimir", search: ["–º–∞—è–∫–æ–≤—Å–∫–∏–π", "–≤–ª–∞–¥–∏–º–∏—Ä", "mayakovsky", "majakowski", "maiakowski", "vladimir"], birth: 1893, death: 1930 },
            { canonical: "Gumilev, Nikolay", search: ["–≥—É–º–∏–ª—ë–≤", "–≥—É–º–∏–ª–µ–≤", "–Ω–∏–∫–æ–ª–∞–π", "gumilev", "gumiljow", "nikolay", "nikolai"], birth: 1886, death: 1921 },
            { canonical: "Balmont, Konstantin", search: ["–±–∞–ª—å–º–æ–Ω—Ç", "–∫–æ–Ω—Å—Ç–∞–Ω—Ç–∏–Ω", "balmont", "bal'mont", "konstantin"], birth: 1867, death: 1942 },
            { canonical: "Bryusov, Valery", search: ["–±—Ä—é—Å–æ–≤", "–≤–∞–ª–µ—Ä–∏–π", "bryusov", "brjussow", "briusov", "valery", "valeri"], birth: 1873, death: 1924 },
            { canonical: "Annensky, Innokenty", search: ["–∞–Ω–Ω–µ–Ω—Å–∫–∏–π", "–∏–Ω–Ω–æ–∫–µ–Ω—Ç–∏–π", "annensky", "annenskij", "innokenty", "innokentij"], birth: 1855, death: 1909 },
            // === PROSE WRITERS SET TO MUSIC ===
            { canonical: "Gogol, Nikolai", search: ["–≥–æ–≥–æ–ª—å", "–Ω–∏–∫–æ–ª–∞–π", "gogol", "nikolai", "nikolay"], birth: 1809, death: 1852 },
            { canonical: "Turgenev, Ivan", search: ["—Ç—É—Ä–≥–µ–Ω–µ–≤", "–∏–≤–∞–Ω", "turgenev", "turgenjew", "ivan"], birth: 1818, death: 1883 },
            { canonical: "Tolstoy, Leo", search: ["—Ç–æ–ª—Å—Ç–æ–π", "–ª–µ–≤", "–Ω–∏–∫–æ–ª–∞–µ–≤–∏—á", "tolstoy", "tolstoi", "leo", "lev"], birth: 1828, death: 1910 },
            { canonical: "Chekhov, Anton", search: ["—á–µ—Ö–æ–≤", "–∞–Ω—Ç–æ–Ω", "chekhov", "tschechow", "cechov", "anton"], birth: 1860, death: 1904 },
            // === FOLK/ANONYMOUS ===
            { canonical: "Traditional (Folk)", search: ["–Ω–∞—Ä–æ–¥–Ω–∞—è", "–Ω–∞—Ä–æ–¥–Ω—ã–π", "traditional", "folk", "—Ñ–æ–ª—å–∫–ª–æ—Ä", "–Ω–∞—Ä–æ–¥–Ω–æ–µ"], birth: null, death: null },
            { canonical: "Anonymous", search: ["–∞–Ω–æ–Ω–∏–º", "anonymous", "unknown", "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π"], birth: null, death: null },
            // === GERMAN POETS (set by Russian composers) ===
            { canonical: "Goethe, Johann Wolfgang von", search: ["–≥—ë—Ç–µ", "–≥–µ—Ç–µ", "–∏–æ–≥–∞–Ω–Ω", "goethe", "g√∂the", "johann", "wolfgang"], birth: 1749, death: 1832 },
            { canonical: "Heine, Heinrich", search: ["–≥–µ–π–Ω–µ", "–≥–µ–Ω—Ä–∏—Ö", "heine", "heinrich"], birth: 1797, death: 1856 },
        ];
        
        // ============================================================================
        // AUTOCOMPLETE FUNCTIONS
        // ============================================================================
        // USER PROFILE SYSTEM - Country/jurisdiction for copyright calculations
        // ============================================================================
        
        // Copyright terms by jurisdiction (years after death)
        const COPYRIGHT_TERMS = {
            'CA': { term: 70, name: 'Canada', note: 'Life + 70 years (since 2022)' },
            'US': { term: 70, name: 'United States', note: 'Life + 70 years (works after 1978). Pre-1928 works are public domain.' },
            'MX': { term: 100, name: 'Mexico', note: 'Life + 100 years' },
            'EU': { term: 70, name: 'European Union', note: 'Life + 70 years (harmonized)' },
            'GB': { term: 70, name: 'United Kingdom', note: 'Life + 70 years' },
            'RU': { term: 70, name: 'Russia', note: 'Life + 70 years (+4 for WWII veterans)' },
            'UA': { term: 70, name: 'Ukraine', note: 'Life + 70 years' },
            'CH': { term: 70, name: 'Switzerland', note: 'Life + 70 years' },
            'AU': { term: 70, name: 'Australia', note: 'Life + 70 years' },
            'NZ': { term: 50, name: 'New Zealand', note: 'Life + 50 years' },
            'JP': { term: 70, name: 'Japan', note: 'Life + 70 years (since 2018)' },
            'KR': { term: 70, name: 'South Korea', note: 'Life + 70 years' },
            'CN': { term: 50, name: 'China', note: 'Life + 50 years' },
            'OTHER': { term: 70, name: 'Other', note: 'Using international standard: Life + 70 years' }
        };
        
        // User profile (loaded from localStorage)
        let userProfile = {
            country: '',
            name: '',
            institution: ''
        };
        
        function loadUserProfile() {
            try {
                const saved = localStorage.getItem('msr_user_profile');
                if (saved) {
                    userProfile = JSON.parse(saved);
                }
            } catch (e) {
                console.warn('Could not load user profile:', e);
            }
        }
        
        // Called after documentMeta is defined to sync profile data
        function applyUserProfileToMeta() {
            if (userProfile.name) {
                documentMeta.userName = userProfile.name;
            }
            if (userProfile.institution) {
                documentMeta.institution = userProfile.institution;
            }
        }
        
        function saveUserProfile() {
            userProfile.country = document.getElementById('profileCountry')?.value || '';
            userProfile.name = document.getElementById('profileName')?.value.trim() || '';
            userProfile.institution = document.getElementById('profileInstitution')?.value.trim() || '';
            
            try {
                localStorage.setItem('msr_user_profile', JSON.stringify(userProfile));
            } catch (e) {
                console.warn('Could not save user profile:', e);
            }
            
            // Update documentMeta
            documentMeta.userName = userProfile.name;
            documentMeta.institution = userProfile.institution;
            
            // Refresh public domain status with new jurisdiction
            updatePublicDomainStatus();
            
            // Re-render if in Singer's View
            if (currentView === 'singers') {
                renderSingersView();
            }
            
            closeProfileModal();
        }
        
        function openProfileModal() {
            const modal = document.getElementById('profileModal');
            if (!modal) return;
            
            // Populate form with current values
            const countrySelect = document.getElementById('profileCountry');
            const nameInput = document.getElementById('profileName');
            const institutionInput = document.getElementById('profileInstitution');
            
            if (countrySelect) countrySelect.value = userProfile.country || '';
            if (nameInput) nameInput.value = userProfile.name || '';
            if (institutionInput) institutionInput.value = userProfile.institution || '';
            
            updateCopyrightPreview();
            
            modal.classList.add('show');
        }
        
        function closeProfileModal() {
            const modal = document.getElementById('profileModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        // ============================================================================
        // FIRST-LAUNCH ONBOARDING
        // ============================================================================
        
        const ONBOARDING_KEY = 'msr_onboarding_complete';
        
        function checkFirstLaunch() {
            try {
                const completed = localStorage.getItem(ONBOARDING_KEY);
                if (!completed) {
                    showOnboardingModal();
                }
            } catch (e) {
                // localStorage not available, skip onboarding
            }
        }
        
        function showOnboardingModal() {
            const modal = document.getElementById('onboardingModal');
            if (modal) {
                modal.classList.add('show');
                // Focus the name input
                setTimeout(() => {
                    document.getElementById('onboardingName')?.focus();
                }, 100);
            }
        }
        
        function skipOnboarding() {
            const modal = document.getElementById('onboardingModal');
            if (modal) {
                modal.classList.remove('show');
            }
            // Mark as complete so we don't ask again
            try {
                localStorage.setItem(ONBOARDING_KEY, 'true');
            } catch (e) {}
        }
        
        function completeOnboarding() {
            const nameInput = document.getElementById('onboardingName');
            const name = nameInput?.value.trim() || '';
            
            // Save the name to user profile
            if (name) {
                userProfile.name = name;
                documentMeta.userName = name;
                try {
                    localStorage.setItem('msr_user_profile', JSON.stringify(userProfile));
                } catch (e) {}
                
                // Also update the profile form if it exists
                const profileNameInput = document.getElementById('profileName');
                if (profileNameInput) {
                    profileNameInput.value = name;
                }
            }
            
            // Mark as complete
            try {
                localStorage.setItem(ONBOARDING_KEY, 'true');
            } catch (e) {}
            
            // Close modal
            const modal = document.getElementById('onboardingModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        function updateCopyrightPreview() {
            const preview = document.getElementById('copyrightPreview');
            const countryCode = document.getElementById('profileCountry')?.value;
            
            if (!preview) return;
            
            if (!countryCode) {
                preview.innerHTML = 'Select a country to see copyright terms.';
                return;
            }
            
            const info = COPYRIGHT_TERMS[countryCode];
            if (info) {
                const pdYear = 2026 - info.term;
                preview.innerHTML = `<strong>${info.name}:</strong> ${info.note}<br>` +
                    `<span style="color: #2d5a3d;">Works by creators who died before ${pdYear} are in the public domain.</span>`;
            }
        }
        
        function getCopyrightTerm() {
            const country = userProfile.country || 'OTHER';
            return COPYRIGHT_TERMS[country]?.term || 70;
        }
        
        // ============================================================================
        // AUTOCOMPLETE FUNCTIONS
        // ============================================================================
        
        let autocompleteSelectedIndex = { poet: -1, composer: -1 };
        let autocompleteResults = { poet: [], composer: [] };
        
        function normalizeSearchTerm(str) {
            return str.toLowerCase()
                .replace(/—ë/g, '–µ')
                .replace(/–π/g, '–∏')
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }
        
        function searchDatabase(query, database) {
            if (!query || query.length < 2) return [];
            
            const normalizedQuery = normalizeSearchTerm(query);
            const results = [];
            
            for (const entry of database) {
                // Check canonical name
                if (normalizeSearchTerm(entry.canonical).includes(normalizedQuery)) {
                    results.push({ ...entry, score: 100 });
                    continue;
                }
                
                // Check search aliases
                for (const term of entry.search) {
                    if (normalizeSearchTerm(term).includes(normalizedQuery)) {
                        const score = term.toLowerCase() === normalizedQuery ? 90 : 50;
                        results.push({ ...entry, score });
                        break;
                    }
                }
            }
            
            // Sort by score, then alphabetically
            results.sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                return a.canonical.localeCompare(b.canonical);
            });
            
            return results.slice(0, 8);
        }
        
        function isPublicDomain(entry, currentYear = 2026) {
            if (!entry.death) {
                return entry.canonical.includes('Traditional') || entry.canonical.includes('Anonymous');
            }
            // Use user's jurisdiction for copyright term
            const term = getCopyrightTerm();
            return (currentYear - entry.death) >= term;
        }
        
        function formatDates(entry) {
            if (!entry.birth) return '';
            if (entry.death) {
                return `${entry.birth}‚Äì${entry.death}`;
            }
            return `b. ${entry.birth}`;
        }
        
        function renderAutocompleteDropdown(type, results) {
            const dropdown = document.getElementById(type + 'Dropdown');
            if (!dropdown) return;
            
            autocompleteResults[type] = results;
            autocompleteSelectedIndex[type] = -1;
            
            if (results.length === 0) {
                dropdown.innerHTML = '<div class="autocomplete-no-results">No matches found ‚Äî type to enter custom name</div>';
                dropdown.classList.add('show');
                return;
            }
            
            dropdown.innerHTML = results.map((entry, idx) => {
                const pd = isPublicDomain(entry);
                const statusIcon = pd ? '‚úì' : '¬©';
                const statusClass = pd ? 'pd' : 'copyright';
                const dates = formatDates(entry);
                
                return `<div class="autocomplete-item" data-index="${idx}" 
                            onclick="selectAutocompleteItem('${type}', ${idx})"
                            onmouseenter="highlightAutocompleteItem('${type}', ${idx})">
                    <span>
                        <span class="autocomplete-name">${entry.canonical}</span>
                        <span class="autocomplete-dates">${dates}</span>
                    </span>
                    <span class="autocomplete-status ${statusClass}">${statusIcon}</span>
                </div>`;
            }).join('');
            
            dropdown.classList.add('show');
        }
        
        function highlightAutocompleteItem(type, index) {
            const dropdown = document.getElementById(type + 'Dropdown');
            if (!dropdown) return;
            
            // Remove existing selection
            dropdown.querySelectorAll('.autocomplete-item').forEach(el => el.classList.remove('selected'));
            
            // Add selection to new item
            const items = dropdown.querySelectorAll('.autocomplete-item');
            if (items[index]) {
                items[index].classList.add('selected');
                autocompleteSelectedIndex[type] = index;
            }
        }
        
        function selectAutocompleteItem(type, index) {
            const results = autocompleteResults[type];
            if (!results || !results[index]) return;
            
            const entry = results[index];
            const input = document.getElementById(type === 'poet' ? 'metaPoet' : 'metaComposer');
            
            if (input) {
                input.value = entry.canonical;
            }
            
            // Store dates in documentMeta
            if (type === 'poet') {
                documentMeta.poet = entry.canonical;
                documentMeta.poetDates = formatDates(entry);
            } else {
                documentMeta.composer = entry.canonical;
                documentMeta.composerDates = formatDates(entry);
            }
            
            // Update public domain status
            updatePublicDomainStatus();
            
            hideAutocomplete(type);
            updateDocumentMeta();
        }
        
        function updatePublicDomainStatus() {
            // Check both poet and composer
            const poetEntry = POET_DATABASE.find(p => p.canonical === documentMeta.poet);
            const composerEntry = COMPOSER_DATABASE.find(c => c.canonical === documentMeta.composer);
            
            const poetPD = poetEntry ? isPublicDomain(poetEntry) : true;
            const composerPD = composerEntry ? isPublicDomain(composerEntry) : true;
            
            if (poetPD && composerPD) {
                documentMeta.publicDomainStatus = 'public_domain';
            } else {
                documentMeta.publicDomainStatus = 'likely_copyright';
            }
        }
        
        function hideAutocomplete(type) {
            const dropdown = document.getElementById(type + 'Dropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
            }
            autocompleteSelectedIndex[type] = -1;
        }
        
        function handlePoetInput(input) {
            const query = input.value.trim();
            if (query.length >= 2) {
                const results = searchDatabase(query, POET_DATABASE);
                renderAutocompleteDropdown('poet', results);
            } else {
                hideAutocomplete('poet');
            }
            // Clear stored dates if user types something new
            documentMeta.poetDates = '';
            updateDocumentMeta();
        }
        
        function handleComposerInput(input) {
            const query = input.value.trim();
            if (query.length >= 2) {
                const results = searchDatabase(query, COMPOSER_DATABASE);
                renderAutocompleteDropdown('composer', results);
            } else {
                hideAutocomplete('composer');
            }
            // Clear stored dates if user types something new
            documentMeta.composerDates = '';
            updateDocumentMeta();
        }
        
        function handleAutocompleteKey(event, type) {
            const dropdown = document.getElementById(type + 'Dropdown');
            if (!dropdown || !dropdown.classList.contains('show')) return;
            
            const results = autocompleteResults[type];
            if (!results || results.length === 0) return;
            
            switch (event.key) {
                case 'ArrowDown':
                    event.preventDefault();
                    const nextIdx = Math.min(autocompleteSelectedIndex[type] + 1, results.length - 1);
                    highlightAutocompleteItem(type, nextIdx);
                    break;
                    
                case 'ArrowUp':
                    event.preventDefault();
                    const prevIdx = Math.max(autocompleteSelectedIndex[type] - 1, 0);
                    highlightAutocompleteItem(type, prevIdx);
                    break;
                    
                case 'Enter':
                    event.preventDefault();
                    if (autocompleteSelectedIndex[type] >= 0) {
                        selectAutocompleteItem(type, autocompleteSelectedIndex[type]);
                    } else if (results.length > 0) {
                        selectAutocompleteItem(type, 0);
                    }
                    break;
                    
                case 'Escape':
                    hideAutocomplete(type);
                    break;
                    
                case 'Tab':
                    if (autocompleteSelectedIndex[type] >= 0) {
                        selectAutocompleteItem(type, autocompleteSelectedIndex[type]);
                    }
                    hideAutocomplete(type);
                    break;
            }
        }
        
        // Document metadata for PDF header/footer
        let documentMeta = {
            title: '',
            poet: '',
            poetDates: '',
            composer: '',
            composerDates: '',
            opus: '',
            userName: '',
            institution: '',
            pageSize: 'letter',  // 'letter' or 'a4'
            publicDomainStatus: 'unknown'  // 'public_domain', 'likely_copyright', 'unknown'
        };
        
        // Runtime document metadata (updated on each render)
        let currentDocumentMeta = {
            generatedAt: null,
            sourceText: '',
            stressPositions: [],
            stylePreset: 'sung_russian_grayson',
            hash: null
        };
        
        function renderSingersView() {
            if (processedWords.length === 0) return;
            
            // Debounce rapid re-renders
            clearTimeout(renderDebounceTimer);
            renderDebounceTimer = setTimeout(() => {
                actuallyRenderCanvas();
            }, RENDER_DEBOUNCE_MS);
            
            // Show "Live" status while debouncing
            updateDocumentStatus('live');
        }
        
        function actuallyRenderCanvas() {
            const canvas = document.getElementById('singersCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // ================================================================
            // PAGE DIMENSIONS - Full letter/A4 page
            // ================================================================
            const pageSize = documentMeta.pageSize || 'letter';
            
            // Dimensions in points (1 pt = 1/72 inch)
            const PAGE_SIZES = {
                letter: { width: 612, height: 792, name: 'US Letter (8.5" √ó 11")' },
                a4: { width: 595, height: 842, name: 'A4 (210 √ó 297 mm)' }
            };
            
            const page = PAGE_SIZES[pageSize];
            const margin = 54; // 0.75 inch margins (restored)
            const contentWidth = page.width - (margin * 2);
            const contentHeight = page.height - (margin * 2);
            
            // ================================================================
            // ZONE HEIGHTS
            // ================================================================
            const headerHeight = 90;   // Title, poet, composer (restored for page 1)
            const footerHeight = 50;   // Slightly tighter
            const contentZoneHeight = contentHeight - headerHeight - footerHeight;
            
            // ================================================================
            // LAYOUT CALCULATIONS
            // ================================================================
            const lineHeight = 48; // Tighter: fits ~1 more line per page
            const wordSpacing = 28;
            
            // Measure and layout words
            ctx.font = '12px "Noto Serif", serif';
            
            let allLines = [];
            let currentLine = [];
            let currentLineWidth = 0;
            
            const wordData = processedWords.map((wd) => {
                const { processed, originalWord } = wd;
                
                // Get IPA
                let ipa;
                if (wd.ipaEditorState) {
                    const { units, boundaries } = wd.ipaEditorState;
                    const parts = [];
                    let start = 0;
                    for (const b of boundaries) {
                        parts.push(units.slice(start, b).map(u => u.symbol).join(''));
                        start = b;
                    }
                    parts.push(units.slice(start).map(u => u.symbol).join(''));
                    const stressIdx = processed.stressIndex;
                    if (stressIdx >= 0 && stressIdx < parts.length && processed.showStressMarker) {
                        parts[stressIdx] = 'Àà' + parts[stressIdx];
                    }
                    ipa = parts.filter(p => p.length > 0).join(' ');
                } else {
                    ipa = processed.syllables.map((s, i) => {
                        const stressMark = s.showStressMarker ? 'Àà' : '';
                        return stressMark + s.ipa;
                    }).join(' ');
                }
                ipa = applyNotationPreferences(applyStyleSettings(ipa));
                
                const cyrillic = addStressMark(originalWord, processed.stressIndex);
                const ipaText = ipa;  // No brackets - line-level solidi instead
                
                // Measure widths
                ctx.font = '11px "Noto Serif", "Doulos SIL", serif';
                const ipaWidth = ctx.measureText(ipaText).width;
                ctx.font = '13px "Noto Serif", serif';
                const cyrWidth = ctx.measureText(cyrillic).width;
                const width = Math.max(ipaWidth, cyrWidth);
                
                return { 
                    ipa: ipaText, 
                    cyrillic, 
                    width,
                    lineBreakAfter: wd.lineBreakAfter  // Preserve poetry line breaks
                };
            });
            
            // Flow words into lines, respecting poetry line breaks
            wordData.forEach((word) => {
                // Check if we need to wrap due to width
                if (currentLineWidth + word.width + wordSpacing > contentWidth && currentLine.length > 0) {
                    allLines.push(currentLine);
                    currentLine = [];
                    currentLineWidth = 0;
                }
                currentLine.push(word);
                currentLineWidth += word.width + wordSpacing;
                
                // If this word ends a poetry line, force a new line
                if (word.lineBreakAfter && currentLine.length > 0) {
                    allLines.push(currentLine);
                    currentLine = [];
                    currentLineWidth = 0;
                }
            });
            if (currentLine.length > 0) {
                allLines.push(currentLine);
            }
            
            // ================================================================
            // PAGINATION - Calculate lines per page (differs for page 1 vs continuation)
            // ================================================================
            const continuationHeaderHeight = 32; // Compact header for pages 2+
            const page1ContentZone = contentHeight - headerHeight - footerHeight;
            const page2ContentZone = contentHeight - continuationHeaderHeight - footerHeight;
            
            const linesPerPage1 = Math.floor(page1ContentZone / lineHeight);
            const linesPerPageN = Math.floor(page2ContentZone / lineHeight);
            
            // Calculate total pages needed
            let totalPages = 1;
            let remainingLines = allLines.length - linesPerPage1;
            if (remainingLines > 0) {
                totalPages += Math.ceil(remainingLines / linesPerPageN);
            }
            
            // Store for export
            currentDocumentMeta.totalPages = totalPages;
            
            // ================================================================
            // CANVAS SETUP - All pages stacked vertically
            // ================================================================
            const scale = 1.0; // 1:1 with PDF points for accurate preview
            const dpr = window.devicePixelRatio || 1;
            const pageGap = 20; // Gap between pages
            const totalHeight = (page.height * totalPages) + (pageGap * (totalPages - 1));
            
            canvas.width = page.width * dpr * scale;
            canvas.height = totalHeight * dpr * scale;
            canvas.style.width = (page.width * scale) + 'px';
            canvas.style.height = (totalHeight * scale) + 'px';
            ctx.scale(dpr * scale, dpr * scale);
            
            // ================================================================
            // DRAW ALL PAGES
            // ================================================================
            let lineIndex = 0; // Track which line we're on globally
            
            for (let pageNum = 0; pageNum < totalPages; pageNum++) {
                const pageOffsetY = pageNum * (page.height + pageGap);
                
                // Different line counts for page 1 vs continuation pages
                const linesThisPage = (pageNum === 0) ? linesPerPage1 : linesPerPageN;
                const endLine = Math.min(lineIndex + linesThisPage, allLines.length);
                const pageLines = allLines.slice(lineIndex, endLine);
                lineIndex = endLine;
                
                // ================================================================
                // DRAW PAGE BACKGROUND
                // ================================================================
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, pageOffsetY, page.width, page.height);
                
                // Page border (subtle)
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, pageOffsetY, page.width, page.height);
                
                // ================================================================
                // DRAW HEADER ZONE
                // ================================================================
                const headerY = pageOffsetY + margin;
                
                if (pageNum === 0) {
                    // ============================================================
                    // PAGE 1: FULL HEADER
                    // ============================================================
                    
                    // Title
                    ctx.fillStyle = '#1a1a1a';
                    ctx.font = 'bold 18px "Noto Serif", Georgia, serif';
                    const title = documentMeta.title || 'Untitled';
                    ctx.fillText(title, margin, headerY + 22);
                    
                    // Poet line
                    ctx.fillStyle = '#444444';
                    ctx.font = '12px "Noto Serif", Georgia, serif';
                    let poetLine = '';
                    if (documentMeta.poet) {
                        poetLine = 'Poetry: ' + documentMeta.poet;
                        if (documentMeta.poetDates) {
                            poetLine += ' (' + documentMeta.poetDates + ')';
                        }
                    }
                    if (poetLine) {
                        ctx.fillText(poetLine, margin, headerY + 42);
                    }
                    
                    // Composer line
                    let composerLine = '';
                    if (documentMeta.composer) {
                        composerLine = 'Music: ' + documentMeta.composer;
                        if (documentMeta.composerDates) {
                            composerLine += ' (' + documentMeta.composerDates + ')';
                        }
                        if (documentMeta.opus) {
                            composerLine += '  ‚Ä¢  ' + documentMeta.opus;
                        }
                    }
                    if (composerLine) {
                        ctx.fillText(composerLine, margin, headerY + 58);
                    }
                } else {
                    // ============================================================
                    // PAGE 2+: CONTINUATION HEADER (compact)
                    // ============================================================
                    
                    // Title, cont'd (left side, smaller)
                    ctx.fillStyle = '#1a1a1a';
                    ctx.font = '13px "Noto Serif", Georgia, serif';
                    const title = documentMeta.title || 'Untitled';
                    // Truncate title if too long
                    const maxTitleLen = 40;
                    const displayTitle = title.length > maxTitleLen ? title.substring(0, maxTitleLen - 3) + '...' : title;
                    ctx.fillText(displayTitle + ", cont'd", margin, headerY + 20);
                    
                    // Poet / Composer surnames (right side, same line)
                    const getSurname = (fullName) => {
                        if (!fullName) return '';
                        // Handle "Surname, First..." format
                        const commaIdx = fullName.indexOf(',');
                        if (commaIdx > 0) {
                            return fullName.substring(0, commaIdx);
                        }
                        // Handle "First Surname" format
                        const parts = fullName.split(' ');
                        return parts[parts.length - 1];
                    };
                    
                    const poetSurname = getSurname(documentMeta.poet);
                    const composerSurname = getSurname(documentMeta.composer);
                    
                    let rightText = '';
                    if (poetSurname && composerSurname && poetSurname !== composerSurname) {
                        rightText = poetSurname + ' / ' + composerSurname;
                    } else if (poetSurname) {
                        rightText = poetSurname;
                    } else if (composerSurname) {
                        rightText = composerSurname;
                    }
                    
                    if (rightText) {
                        ctx.fillStyle = '#444444';
                        ctx.font = '12px "Noto Serif", Georgia, serif';
                        const rightWidth = ctx.measureText(rightText).width;
                        ctx.fillText(rightText, page.width - margin - rightWidth, headerY + 20);
                    }
                }
                
                // Dynamic header height: full for page 1, compact for continuation pages
                const effectiveHeaderHeight = (pageNum === 0) ? headerHeight : 32;
                
                // Header divider line
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(margin, headerY + effectiveHeaderHeight - 8);
                ctx.lineTo(page.width - margin, headerY + effectiveHeaderHeight - 8);
                ctx.stroke();
                
                // ================================================================
                // DRAW CONTENT ZONE - Interlinear text
                // ================================================================
                let y = pageOffsetY + margin + effectiveHeaderHeight + 12;
                
                pageLines.forEach((line) => {
                    let x = margin;
                    
                    // Draw opening solidus at start of IPA line
                    ctx.fillStyle = '#555555';
                    ctx.font = '11px "Noto Serif", "Doulos SIL", serif';
                    ctx.fillText('/', x, y);
                    x += ctx.measureText('/ ').width;
                    
                    line.forEach((word, wordIndex) => {
                        // IPA (smaller, grey)
                        ctx.fillStyle = '#555555';
                        ctx.font = '11px "Noto Serif", "Doulos SIL", serif';
                        ctx.fillText(word.ipa, x, y);
                        
                        // Cyrillic (larger, bold, dark)
                        ctx.fillStyle = '#1a1a1a';
                        ctx.font = '600 13px "Noto Serif", serif';
                        ctx.fillText(word.cyrillic, x, y + 16);
                        
                        x += word.width + wordSpacing;
                    });
                    
                    // Draw closing solidus at end of IPA line
                    ctx.fillStyle = '#555555';
                    ctx.font = '11px "Noto Serif", "Doulos SIL", serif';
                    ctx.fillText('/', x - wordSpacing + 4, y);  // Adjust for word spacing
                    
                    y += lineHeight;
                });
                
                // ================================================================
                // DRAW FOOTER ZONE
                // ================================================================
                const footerY = pageOffsetY + page.height - margin - footerHeight;
                
                // Footer divider
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(margin, footerY);
                ctx.lineTo(page.width - margin, footerY);
                ctx.stroke();
                
                // Line 1: Attribution
                ctx.fillStyle = '#555555';
                ctx.font = '8px "Noto Sans", sans-serif';
                // Format: 24hr timestamp HH:MM:SS
                const now = new Date();
                const dateStr = now.toLocaleDateString('en-CA'); // YYYY-MM-DD
                const timeStr = now.toTimeString().slice(0, 8);  // HH:MM:SS
                let attrLine = '';
                if (documentMeta.userName) {
                    attrLine = `Transcribed by ${documentMeta.userName} using My Sung Russian | ${dateStr} ${timeStr}`;
                } else {
                    attrLine = `Transcribed using My Sung Russian | ${dateStr} ${timeStr}`;
                }
                ctx.fillText(attrLine, margin, footerY + 14);
                
                // Line 2: Disclaimer
                ctx.fillStyle = '#777777';
                ctx.font = '7.5px "Noto Sans", sans-serif';
                const disclaimer = documentMeta.publicDomainStatus === 'public_domain'
                    ? 'Source text believed to be in the public domain. IPA transcription provided for lyric diction study.'
                    : 'Source text anchors its phonetic analysis here in the spirit of fair academic use. Fair dealing (CA/UK/AU) and fair use (US) provisions apply.';
                ctx.fillText(disclaimer, margin, footerY + 28);
                
                // Line 3: MSR credit (left) and page number (right)
                ctx.fillStyle = '#555555';
                ctx.font = '7.5px "Noto Sans", sans-serif';
                ctx.fillText('MSR is based on Grayson, Russian Lyric Diction (2012) and developed by Dann Mitton. Open source (AGPL-3.0)', margin, footerY + 42);
                
                // Page number (right-aligned)
                const pageNumText = `Page ${pageNum + 1} of ${totalPages}`;
                const pageNumWidth = ctx.measureText(pageNumText).width;
                ctx.fillText(pageNumText, page.width - margin - pageNumWidth, footerY + 42);
            }
            
            // ================================================================
            // Draw gap backgrounds (grey between pages)
            // ================================================================
            ctx.fillStyle = '#e8e0d8';
            for (let i = 0; i < totalPages - 1; i++) {
                const gapY = (i + 1) * page.height + i * pageGap;
                ctx.fillRect(0, gapY, page.width, pageGap);
            }
            
            // ================================================================
            // UPDATE DOCUMENT METADATA
            // ================================================================
            currentDocumentMeta = {
                ...documentMeta,
                generatedAt: new Date().toISOString(),
                sourceText: processedWords.map(w => w.originalWord).join(' '),
                stressPositions: processedWords.map(w => w.processed.stressIndex),
                stylePreset: activePresetId,
                wordCount: processedWords.length,
                totalPages: totalPages,
                pageSize: pageSize
            };
            
            // Calculate simple hash for deduplication
            currentDocumentMeta.hash = simpleHash(
                currentDocumentMeta.sourceText + 
                currentDocumentMeta.stressPositions.join(',') +
                currentDocumentMeta.stylePreset
            );
            
            lastRenderTime = Date.now();
            updateDocumentStatus('stable');
        }
        
        // Simple hash function for document fingerprinting
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString(16);
        }
        
        function updateDocumentStatus(status) {
            const statusEl = document.getElementById('documentStatus');
            if (!statusEl) return;
            
            const dot = statusEl.querySelector('.status-dot');
            const text = statusEl.querySelector('.status-text');
            
            if (status === 'live') {
                dot.classList.remove('stable');
                text.textContent = 'Updating...';
            } else {
                dot.classList.add('stable');
                text.textContent = 'Ready';
            }
        }
        
        // Zoom controls
        function zoomCanvas(factor) {
            canvasScale *= factor;
            canvasScale = Math.max(0.25, Math.min(3, canvasScale)); // Clamp 25% - 300%
            
            const canvas = document.getElementById('singersCanvas');
            if (canvas) {
                canvas.style.transform = `scale(${canvasScale})`;
            }
            
            const zoomEl = document.getElementById('zoomLevel');
            if (zoomEl) {
                zoomEl.textContent = Math.round(canvasScale * 100) + '%';
            }
        }
        
        function resetCanvasView() {
            canvasScale = 1;
            const canvas = document.getElementById('singersCanvas');
            if (canvas) {
                canvas.style.transform = 'scale(1)';
            }
            
            const viewport = document.getElementById('canvasViewport');
            if (viewport) {
                viewport.scrollLeft = 0;
                viewport.scrollTop = 0;
            }
            
            const zoomEl = document.getElementById('zoomLevel');
            if (zoomEl) {
                zoomEl.textContent = '100%';
            }
        }
        
        // Touch gesture support for pinch-zoom
        let initialPinchDistance = null;
        let initialScale = 1;
        
        // Drag-to-pan support
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let scrollStartX = 0;
        let scrollStartY = 0;
        
        document.addEventListener('DOMContentLoaded', () => {
            const viewport = document.getElementById('canvasViewport');
            if (!viewport) return;
            
            // === MOUSE DRAG ===
            viewport.addEventListener('mousedown', (e) => {
                // Only left mouse button
                if (e.button !== 0) return;
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                scrollStartX = viewport.scrollLeft;
                scrollStartY = viewport.scrollTop;
                viewport.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;
                viewport.scrollLeft = scrollStartX - dx;
                viewport.scrollTop = scrollStartY - dy;
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    const viewport = document.getElementById('canvasViewport');
                    if (viewport) viewport.style.cursor = 'grab';
                }
            });
            
            // === TOUCH PINCH-ZOOM ===
            viewport.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    initialPinchDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    initialScale = canvasScale;
                } else if (e.touches.length === 1) {
                    // Single finger drag
                    isDragging = true;
                    dragStartX = e.touches[0].clientX;
                    dragStartY = e.touches[0].clientY;
                    scrollStartX = viewport.scrollLeft;
                    scrollStartY = viewport.scrollTop;
                }
            }, { passive: true });
            
            viewport.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && initialPinchDistance) {
                    // Pinch zoom
                    const currentDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const scale = (currentDistance / initialPinchDistance) * initialScale;
                    canvasScale = Math.max(0.25, Math.min(3, scale));
                    
                    const canvas = document.getElementById('singersCanvas');
                    if (canvas) {
                        canvas.style.transform = `scale(${canvasScale})`;
                    }
                    
                    const zoomEl = document.getElementById('zoomLevel');
                    if (zoomEl) {
                        zoomEl.textContent = Math.round(canvasScale * 100) + '%';
                    }
                } else if (e.touches.length === 1 && isDragging) {
                    // Single finger pan
                    const dx = e.touches[0].clientX - dragStartX;
                    const dy = e.touches[0].clientY - dragStartY;
                    viewport.scrollLeft = scrollStartX - dx;
                    viewport.scrollTop = scrollStartY - dy;
                }
            }, { passive: true });
            
            viewport.addEventListener('touchend', () => {
                initialPinchDistance = null;
                isDragging = false;
            }, { passive: true });
        });
        
        // Footer collapse/expand for mobile
        function toggleFooter() {
            const footer = document.getElementById('mainFooter');
            if (footer) {
                footer.classList.toggle('collapsed');
                const label = footer.querySelector('.footer-collapsed-label');
                if (label) {
                    if (footer.classList.contains('collapsed')) {
                        label.innerHTML = 'My Sung Russian (MSR) <span id="versionNumber" onclick="event.stopPropagation()">v4.16</span> ‚Äî tap for credits & license <span class="footer-arrow">‚ñ≤</span>';
                    } else {
                        label.innerHTML = 'My Sung Russian (MSR) <span id="versionNumber" onclick="event.stopPropagation()">v4.16</span> ‚Äî tap to collapse <span class="footer-arrow">‚ñº</span>';
                    }
                    // Re-attach triple-click handler after innerHTML change
                    attachVersionClickHandlers();
                }
            }
        }
        
        // ============================================================================
        // DEVELOPER TOOLS - Hidden Harvest Export
        // ============================================================================
        // Triple-click the version number (v4.16) in the footer to:
        //   - First time: Unlock "developer mode" (stored in localStorage)
        //   - After unlock: Shows harvest indicator (üåæ + count) next to version
        //   - Click the indicator: Downloads harvest immediately
        //
        // Regular users never see the indicator because they never triple-click.
        // ============================================================================
        
        const DEV_MODE_KEY = 'msr_dev_mode';
        let versionClickCount = 0;
        let versionClickTimer = null;
        
        function isDevModeUnlocked() {
            try {
                return localStorage.getItem(DEV_MODE_KEY) === 'true';
            } catch (e) {
                return false;
            }
        }
        
        function unlockDevMode() {
            try {
                localStorage.setItem(DEV_MODE_KEY, 'true');
                console.log('[Dev] Developer mode unlocked');
            } catch (e) {
                console.warn('[Dev] Could not save dev mode state');
            }
        }
        
        function handleVersionClick(event) {
            event.stopPropagation();
            versionClickCount++;
            
            if (versionClickTimer) {
                clearTimeout(versionClickTimer);
            }
            
            versionClickTimer = setTimeout(() => {
                if (versionClickCount >= 3) {
                    // Triple-click detected
                    if (!isDevModeUnlocked()) {
                        // First triple-click: unlock dev mode
                        unlockDevMode();
                        updateHarvestIndicator();
                        alert('Developer mode unlocked.\n\nYou\'ll now see a harvest indicator (üåæ) next to the version number when words have been collected.\n\nClick it to download.');
                    } else {
                        // Already unlocked: just download
                        downloadHarvestWithFeedback();
                    }
                }
                versionClickCount = 0;
            }, 400);
        }
        
        function handleHarvestIndicatorClick(event) {
            event.stopPropagation();
            downloadHarvestWithFeedback();
        }
        
        function downloadHarvestWithFeedback() {
            const stats = getHarvestStats();
            if (stats.total === 0) {
                alert('Harvest is empty.\n\nUse MSR to look up words via Wiktionary first.');
            } else {
                downloadHarvest(false); // Vuizur format
                alert(`Downloaded ${stats.total} words.\n\nOldest: ${stats.oldest || 'N/A'}\nNewest: ${stats.newest || 'N/A'}`);
            }
        }
        
        function updateHarvestIndicator() {
            // Only show indicator if dev mode is unlocked
            if (!isDevModeUnlocked()) return;
            
            const stats = getHarvestStats();
            const indicators = document.querySelectorAll('.harvest-indicator');
            
            // Remove existing indicators
            indicators.forEach(el => el.remove());
            
            // Add indicator next to version numbers if harvest has data
            const versionElements = document.querySelectorAll('#versionNumber, #versionNumberExpanded');
            versionElements.forEach(el => {
                const indicator = document.createElement('span');
                indicator.className = 'harvest-indicator';
                indicator.style.cssText = 'margin-left: 6px; cursor: pointer; opacity: 0.8;';
                indicator.title = stats.total > 0 
                    ? `Click to download ${stats.total} harvested words`
                    : 'No words harvested yet';
                
                if (stats.total > 0) {
                    indicator.textContent = `üåæ${stats.total}`;
                    indicator.style.opacity = '1';
                } else {
                    indicator.textContent = 'üåæ';
                    indicator.style.opacity = '0.4';
                }
                
                indicator.addEventListener('click', handleHarvestIndicatorClick);
                el.parentNode.insertBefore(indicator, el.nextSibling);
            });
        }
        
        function attachVersionClickHandlers() {
            const versionElements = document.querySelectorAll('#versionNumber, #versionNumberExpanded');
            versionElements.forEach(el => {
                el.style.cursor = 'default'; // Don't hint that it's clickable
                el.removeEventListener('click', handleVersionClick);
                el.addEventListener('click', handleVersionClick);
            });
            
            // Update harvest indicator (only visible if dev mode unlocked)
            updateHarvestIndicator();
        }
        
        // Also update indicator whenever harvest changes
        const originalHarvestWord = harvestWord;
        harvestWord = function(word, stressIndex) {
            const result = originalHarvestWord(word, stressIndex);
            updateHarvestIndicator();
            return result;
        };
        
        // NOTE: renderStressEditor(), toggleWordEditor(), and setStressFromSingersView()
        // removed in v4.14 - these were part of an old Singer's View editing system
        // that was never fully implemented. Stress editing now happens in Workspace view.
        
        // Show tooltip at cursor position (for Singer's View)
        function showTooltipAtCursor(message) {
            const existing = document.querySelector('.msr-tooltip');
            if (existing) existing.remove();
            
            const tooltip = document.createElement('div');
            tooltip.className = 'msr-tooltip';
            tooltip.textContent = message;
            tooltip.style.position = 'fixed';
            tooltip.style.left = '50%';
            tooltip.style.top = '50%';
            tooltip.style.transform = 'translate(-50%, -50%)';
            
            document.body.appendChild(tooltip);
            
            setTimeout(() => {
                tooltip.style.opacity = '0';
                setTimeout(() => tooltip.remove(), 300);
            }, 2500);
        }
        
        // Close editor when clicking outside
        document.addEventListener('click', function(event) {
            if (editingWordIndex !== null && !event.target.closest('.interlinear-word')) {
                editingWordIndex = null;
                renderSingersView();
            }
        });
        
        function copySingersView() {
            // Generate plain text version for clipboard
            let lines = { ipa: [], cyrillic: [], gloss: [] };
            
            processedWords.forEach((wordData) => {
                const { processed, originalWord } = wordData;
                
                let ipa = processed.syllables.map((s, i) => {
                    const stressMark = s.showStressMarker ? 'Àà' : '';
                    return stressMark + s.ipa;
                }).join('');
                ipa = applyNotationPreferences(applyStyleSettings(ipa));
                
                const stressedCyrillic = addStressMark(
                    originalWord, 
                    processed.stressIndex
                );
                
                lines.ipa.push('[' + ipa + ']');
                lines.cyrillic.push(stressedCyrillic);
                lines.gloss.push('___');
            });
            
            const text = lines.ipa.join('  ') + '\n' + 
                        lines.cyrillic.join('  ') + '\n' + 
                        lines.gloss.join('  ');
            
            navigator.clipboard.writeText(text).then(() => {
                alert('Singer\'s View copied to clipboard!');
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }
        
        function printSingersView() {
            window.print();
        }
        
        /**
         * Export Singers View to PDF
         * Preserves user's syllable boundary adjustments and stress markings
         */
        function exportToPDF() {
            const { jsPDF } = window.jspdf;
            
            if (!jsPDF) {
                alert('PDF library not loaded. Please check your internet connection.');
                return;
            }
            
            // Make sure canvas is rendered
            actuallyRenderCanvas();
            
            const canvas = document.getElementById('singersCanvas');
            if (!canvas) {
                alert('Please switch to Singer\'s View first.');
                return;
            }
            
            // Get page dimensions based on user preference
            const pageSize = documentMeta.pageSize || 'letter';
            const format = pageSize === 'a4' ? 'a4' : 'letter';
            
            // Create PDF with correct page size
            const doc = new jsPDF({
                orientation: 'portrait',
                unit: 'pt',
                format: format
            });
            
            const pdfWidth = doc.internal.pageSize.getWidth();
            const pdfHeight = doc.internal.pageSize.getHeight();
            
            // Get canvas as image
            const imgData = canvas.toDataURL('image/png');
            const dpr = window.devicePixelRatio || 1;
            
            // Canvas is rendered at page size, so it should fit 1:1
            // Add with no margin since canvas already has margins
            doc.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
            
            // Set document metadata
            const title = documentMeta.title || 'Untitled Transcription';
            doc.setProperties({
                title: title + ' ‚Äî MSR Transcription',
                subject: 'Russian IPA Transcription for Lyric Diction',
                author: documentMeta.userName || 'My Sung Russian (MSR)',
                keywords: 'IPA, Russian, diction, transcription, Grayson, ' + (documentMeta.poet || '') + ', ' + (documentMeta.composer || ''),
                creator: 'MSR v4.8 (msr.app)'
            });
            
            // Generate filename from title or first words
            let filename;
            if (documentMeta.title) {
                // Clean title for filename
                filename = 'msr_' + documentMeta.title
                    .replace(/[^a-zA-Z–∞-—è–ê-–Ø—ë–Å0-9\s]/g, '')
                    .replace(/\s+/g, '_')
                    .substring(0, 40);
            } else {
                const firstWords = processedWords.slice(0, 3).map(w => w.originalWord).join('_');
                filename = 'msr_' + (firstWords || 'transcription');
            }
            filename += '.pdf';
            
            // Download
            doc.save(filename);
            
            // Log for potential cataloguing
            console.log('PDF exported:', {
                title: documentMeta.title,
                poet: documentMeta.poet,
                composer: documentMeta.composer,
                hash: currentDocumentMeta.hash,
                pages: currentDocumentMeta.totalPages
            });
        }

        // Animated placeholder visibility
        function updatePlaceholderVisibility() {
            const textarea = document.getElementById('russianInput');
            const placeholder = document.getElementById('animatedPlaceholder');
            if (textarea && placeholder) {
                if (textarea.value.length > 0) {
                    placeholder.classList.add('hidden');
                } else {
                    placeholder.classList.remove('hidden');
                }
            }
        }

        // ============================================================================
        // CHAPTER 6 TEST RUNNER
        // ============================================================================
        
        const CH6_TESTS = {
            'Voicing Assimilation (Devoicing)': [
                { word: '—Ç—Ä—É–±–∫–∞', stress: 0, expected: 'trup k…ë', note: '–±‚Üí–ø before –∫ (p.215)' },
                { word: '–æ–±—Ö–æ–¥', stress: 1, expected: '…ëp xot', note: '–±‚Üí–ø before —Ö (p.215)' },
                { word: '–Ω–æ–≥—Ç–∏', stress: 0, expected: 'nok t ≤i', note: '–≥‚Üí–∫ before —Ç (p.216)' },
                { word: '–≤–æ–¥–∫–∞', stress: 0, expected: 'vot k…ë', note: '–¥‚Üí—Ç before –∫ (p.217)' },
                { word: '–Ω–∞–¥–ø–∏—Å—å', stress: 0, expected: 'n…ë t ≤p ≤is å', note: '–¥‚Üí—Ç before –ø (p.217) - syllabification needs review' },
                { word: '–ø–æ–¥—Ö–æ–¥', stress: 1, expected: 'p…ët xot', note: '–¥‚Üí—Ç before —Ö (p.217)' },
                { word: '–ª–æ–∂–∫–∞', stress: 0, expected: '…´o É k…ë', note: '–∂‚Üí—à before –∫ (p.218)' },
                { word: '—Ä–æ–∂–∫–∏', stress: 0, expected: 'ro É k ≤i', note: '–∂‚Üí—à before –∫ (p.218)' },
                { word: '–º—É–∂—Å–∫–æ–π', stress: 1, expected: 'mu É skoj', note: '–∂‚Üí—à before —Å (p.218)' },
                { word: '–ª–µ–∑—Ç—å', stress: 0, expected: 'l ≤…õs ≤t ≤', note: '–∑‚Üí—Å before —Ç (p.219)' },
                { word: '–º–∞–∑–∫–∏', stress: 1, expected: 'm…ë s ≤k ≤i', note: '–∑‚Üí—Å before –∫ (p.219)' },
            ],
            'Voicing Assimilation (Voicing)': [
                { word: '–≤–æ–∫–∑–∞–ª', stress: 1, expected: 'v…ë…° z…ë…´', note: '–∫‚Üí–≥ before –∑ (p.220)' },
                { word: '–∞–Ω–µ–∫–¥–æ—Ç', stress: 2, expected: ' å …≤…™…° dot', note: '–∫‚Üí–≥ before –¥ (p.220)' },
                { word: '—ç–∫–∑–∞–º–µ–Ω', stress: 1, expected: '…™…° z…ë m ≤…™n', note: '–∫‚Üí–≥ before –∑ (p.220)' },
                { word: '—Å–±–æ—Ä', stress: 0, expected: 'zbor', note: '—Å‚Üí–∑ before –± (p.220)' },
                { word: '–ø—Ä–æ—Å—å–±–∞', stress: 0, expected: 'proz ≤ b…ë', note: '—Å‚Üí–∑ before –± (p.220)' },
                { word: '—Å–¥–∞–≤–∞—Ç—å', stress: 1, expected: 'zd…ë v…ët ≤', note: '—Å‚Üí–∑ before –¥ (p.220)' },
                { word: '—Å–¥–µ–ª–∫–∞', stress: 0, expected: 'z ≤d ≤…õ…´ k…ë', note: '—Å‚Üí–∑ before –¥ (p.220)' },
                { word: '–æ—Ç–±–æ–π', stress: 1, expected: '…ëd boj', note: '—Ç‚Üí–¥ before –± (p.221)' },
                { word: '–æ—Ç–∑—ã–≤', stress: 0, expected: 'od z…®f', note: '—Ç‚Üí–¥ before –∑ (p.221)' },
            ],
            'Special Clusters': [
                { word: '–±–µ—Å—à—É–º–Ω–æ', stress: 1, expected: 'b ≤…™  ÉÀêum n å', note: '—Å—à‚Üí ÉÀê (p.235)' },
                { word: '—Å–∂–∏–≥–∞—Ç—å', stress: 1, expected: ' íÀê…® …°…ët ≤', note: '—Å–∂‚Üí íÀê (p.236)' },
                { word: '–∏–∑–∂–∏–≤–∞—Ç—å', stress: 2, expected: 'i  íÀê…® v…ët ≤', note: '–∑–∂‚Üí íÀê (p.236)' },
                { word: '–º—É–∂—á–∏–Ω–∞', stress: 1, expected: 'mu  É ≤ É ≤i n…ë', note: '–∂—á‚Üí É ≤ É ≤ (p.236)' },
                { word: '–º–ª–∞–¥—à–∏–π', stress: 0, expected: 'm…´…ë t ÉÀê…®j', note: '–¥—à‚Üít ÉÀê (p.236)' },
                { word: '–ª—É—á—à–∏–π', stress: 0, expected: '…´u t ÉÀê…®j', note: '—á—à‚Üít ÉÀê (p.236)' },
                { word: '–ø–æ–¥–∂—ë–≥', stress: 1, expected: 'p…ë d íÀêok', note: '–¥–∂‚Üíd íÀê (p.237)' },
                { word: '–ø–æ–¥—á–∞—Å', stress: 1, expected: 'p…ë t ≤ É ≤…ës', note: '–¥—á‚Üít ≤ É ≤ (p.237)' },
                { word: '—Å–∫—É—á–Ω–æ', stress: 0, expected: 'sku  Én å', note: '—á–Ω‚Üí Én (p.239)' },
                { word: '–∫–æ–Ω–µ—á–Ω–æ', stress: 1, expected: 'k…ë …≤…õ  Én å', note: '—á–Ω‚Üí Én (p.239), –Ω‚Üí…≤ before –µ' },
                { word: '—á—Ç–æ', stress: 0, expected: ' Éto', note: '—á—Ç‚Üí Ét (p.240)' },
                { word: '—á—Ç–æ–±—ã', stress: 0, expected: ' Éto b…®', note: '—á—Ç‚Üí Ét (p.240)' },
                { word: '–Ω–∏—á—Ç–æ', stress: 1, expected: '…≤i  Éto', note: '—á—Ç‚Üí Ét (p.240), –Ω‚Üí…≤ before –∏' },
            ],
            '–≥–∫/–≥—á Rules': [
                { word: '–º—è–≥–∫–æ', stress: 0, expected: 'm ≤…ëx k å', note: '–≥–∫‚Üíxk before hard (p.240)' },
                { word: '–ª–µ–≥–∫–æ', stress: 1, expected: 'l ≤…™x ko', note: '–≥–∫‚Üíxk before hard (p.240)' },
                { word: '–º—è–≥–∫–∏–π', stress: 0, expected: 'm ≤…ë x ≤k ≤ij', note: '–≥–∫‚Üíx ≤k ≤ before soft (p.240)' },
                { word: '–ª—ë–≥–∫–∏–π', stress: 0, expected: 'l ≤o x ≤k ≤ij', note: '–≥–∫‚Üíx ≤k ≤ before soft (p.240)' },
                { word: '–ª–µ–≥—á–µ', stress: 0, expected: 'l ≤…õx t É ≤…™', note: '–≥—á‚Üíxt É ≤ (p.241)' },
                { word: '–º—è–≥—á–µ', stress: 0, expected: 'm ≤…ëx t É ≤…™', note: '–≥—á‚Üíxt É ≤ (p.241)' },
            ],
            'Additional Deletions': [
                { word: '—Å—Ç—Ä–∞—Å—Ç–Ω—ã–π', stress: 0, expected: 'str…ë sn…®j', note: '—Å—Ç–Ω‚Üísn (p.243)' },
                { word: '–ø–æ–∑–¥–Ω–æ', stress: 0, expected: 'po zn å', note: '–∑–¥–Ω‚Üízn (p.243)' },
                { word: '–ø–æ–∑–¥–Ω–∏–π', stress: 0, expected: 'po z…≤ij', note: '–∑–¥–Ω‚Üíz…≤ (p.243), –Ω‚Üí…≤ before –∏' },
                { word: '–±–µ–∑–¥–Ω–∞', stress: 0, expected: 'b ≤…õz dn…ë', note: '–∑–¥–Ω preserved (p.244)' },
            ],
            'Reflexive Verbs': [
                { word: '–±–æ–∏—Ç—Å—è', stress: 1, expected: 'b…ë i tÀês å', note: '-—Ç—Å—è‚ÜítÀês å (p.238)' },
                { word: '–∫—É–ø–∞—Ç—å—Å—è', stress: 1, expected: 'ku p…ë tÀês å', note: '-—Ç—å—Å—è‚ÜítÀês å (p.238)' },
                { word: '–æ—Ç—Ü–∞', stress: 1, expected: '…ë tÀês…ë', note: '—Ç—Ü‚ÜítÀês (p.238)' },
                { word: '–º–æ–ª–æ–¥—Ü—ã', stress: 2, expected: 'm å …´…ë tÀês…®', note: '–¥—Ü‚ÜítÀês (p.238)' },
            ],
        };
        
        function normalizeForComparison(ipa) {
            return ipa.replace(/\s+/g, '').replace(/Àà/g, '').replace(/Àå/g, '').replace(/[\/\[\]]/g, '').replace(/\./g, '');
        }
        
        function runCh6Tests() {
            let html = '<div style="background:#1a1a2e;color:#eee;padding:20px;font-family:system-ui;">';
            html += '<h2 style="color:#d4a820;">Chapter 6 Test Results</h2>';
            
            let totalPassed = 0;
            let totalFailed = 0;
            const failures = [];
            
            for (const [category, tests] of Object.entries(CH6_TESTS)) {
                html += '<h3 style="color:#d4784a;border-bottom:1px solid #333;padding-bottom:5px;">' + category + '</h3>';
                
                for (const test of tests) {
                    const result = processWord(test.word, test.stress);
                    const actual = result.syllables.map((s, idx) => {
                        return s.ipa;
                    }).join(' ');
                    
                    const normalizedActual = normalizeForComparison(actual);
                    const normalizedExpected = normalizeForComparison(test.expected);
                    const passed = normalizedActual === normalizedExpected;
                    
                    if (passed) {
                        totalPassed++;
                        html += '<div style="margin:3px 0;padding:5px;background:#0d2818;border-left:3px solid #4ade80;border-radius:4px;">‚úÖ <strong>' + test.word + '</strong>: /' + actual + '/</div>';
                    } else {
                        totalFailed++;
                        failures.push({ ...test, actual });
                        html += '<div style="margin:3px 0;padding:5px;background:#2d1a1a;border-left:3px solid #f87171;border-radius:4px;">‚ùå <strong>' + test.word + '</strong>: got /' + actual + '/, expected /' + test.expected + '/ <span style="color:#888;font-size:0.9em;">‚Äî ' + test.note + '</span></div>';
                    }
                }
            }
            
            const total = totalPassed + totalFailed;
            const passRate = ((totalPassed / total) * 100).toFixed(1);
            
            html = '<div style="background:#0f3460;padding:15px;border-radius:8px;margin-bottom:20px;">' +
                   '<h2 style="margin:0;color:' + (totalFailed === 0 ? '#4ade80' : '#f87171') + ';">' + 
                   totalPassed + '/' + total + ' passed (' + passRate + '%)</h2>' +
                   (totalFailed === 0 ? '<p style="color:#4ade80;">üéâ All Chapter 6 tests passing!</p>' : '') +
                   '</div>' + html;
            
            html += '</div>';
            
            // Show in new window
            const w = window.open('', 'Ch6Tests', 'width=800,height=600');
            w.document.write('<!DOCTYPE html><html><head><title>Ch6 Test Results</title></head><body style="margin:0;">' + html + '</body></html>');
            w.document.close();
            
            return { passed: totalPassed, failed: totalFailed, failures };
        }
        
        // Expose for console testing
        window.runCh6Tests = runCh6Tests;

        // ============================================================================
        // STYLE PRESET TESTS
        // Run in console: runStylePresetTests()
        // ============================================================================
        
        const STYLE_PRESET_TESTS = {
            // Test 1: Vowel reduction - unstressed –µ
            // –≤–µ—Å–Ω–∞ (spring) - stress on syllable 1, so first –µ is unstressed
            "–≤–µ—Å–Ω–∞": {
                stress: 1,
                expected: {
                    "sung_russian_grayson": { shouldContain: "…™", description: "Unstressed –µ ‚Üí /…™/ (ikanye)" },
                    "petersburg": { shouldContain: "…õ", shouldNotContain: "…™", description: "Unstressed –µ ‚Üí /…õ/ (ekanye)" },
                    "choir": { shouldContain: "…õ", shouldNotContain: "…™", description: "Unstressed –µ ‚Üí /…õ/ (no reduction)" }
                }
            },
            // Test 2: Vowel reduction - remote unstressed –æ
            // —Å–ª–æ–≤–æ (word) - stress on syllable 0, so final –æ is remote unstressed
            "—Å–ª–æ–≤–æ": {
                stress: 0,
                expected: {
                    "sung_russian_grayson": { shouldContain: " å", description: "Remote unstressed –æ ‚Üí / å/" },
                    "choir": { shouldNotContain: " å", description: "No reduction: –æ stays full" }
                }
            },
            // Test 3: –© pronunciation - –µ—â—ë
            "–µ—â—ë": {
                stress: 1,
                expected: {
                    "sung_russian_grayson": { shouldContain: " É ≤ É ≤", shouldNotContain: "t É ≤", description: "–© ‚Üí / É ≤ É ≤/ (shshokanye)" },
                    "petersburg": { shouldContain: " É ≤t É ≤", description: "–© ‚Üí / É ≤t É ≤/ (shchokanye)" }
                }
            },
            // Test 4: –∑–µ–º–ª—è - unstressed –µ
            "–∑–µ–º–ª—è": {
                stress: 1,
                expected: {
                    "sung_russian_grayson": { shouldContain: "…™", description: "Unstressed –µ ‚Üí /…™/" },
                    "petersburg": { shouldContain: "…õ", shouldNotContain: "…™", description: "Unstressed –µ ‚Üí /…õ/" }
                }
            },
            // Test 5: —Ä–µ–∫–∞ - unstressed –µ
            "—Ä–µ–∫–∞": {
                stress: 1,
                expected: {
                    "sung_russian_grayson": { shouldContain: "…™", description: "Unstressed –µ ‚Üí /…™/" },
                    "choir": { shouldContain: "…õ", shouldNotContain: "…™", description: "Unstressed –µ ‚Üí /…õ/" }
                }
            }
        };
        
        function runStylePresetTests() {
            const results = { passed: 0, failed: 0, details: [] };
            const originalPreset = activePresetId;
            
            console.log("=".repeat(60));
            console.log("STYLE PRESET TESTS");
            console.log("=".repeat(60));
            
            for (const [word, testConfig] of Object.entries(STYLE_PRESET_TESTS)) {
                console.log(`\nTesting: ${word}`);
                
                for (const [presetId, expectations] of Object.entries(testConfig.expected)) {
                    applyStylePreset(presetId);
                    const processed = processWord(word, testConfig.stress);
                    let fullIPA = processed.syllables.map(s => s.ipa).join('');
                    fullIPA = applyStyleSettings(fullIPA);
                    fullIPA = applyNotationPreferences(fullIPA);
                    
                    let passed = true;
                    let failReason = "";
                    
                    if (expectations.shouldContain && !fullIPA.includes(expectations.shouldContain)) {
                        passed = false;
                        failReason = `Expected "${expectations.shouldContain}" not found`;
                    }
                    if (expectations.shouldNotContain && fullIPA.includes(expectations.shouldNotContain)) {
                        passed = false;
                        failReason = `Should NOT contain "${expectations.shouldNotContain}"`;
                    }
                    
                    const status = passed ? "‚úÖ PASS" : "‚ùå FAIL";
                    console.log(`  ${presetId}: ${status} ‚Äî /${fullIPA}/`);
                    console.log(`    ${expectations.description}`);
                    if (!passed) console.log(`    REASON: ${failReason}`);
                    
                    passed ? results.passed++ : results.failed++;
                    results.details.push({ word, preset: presetId, ipa: fullIPA, passed, failReason });
                }
            }
            
            applyStylePreset(originalPreset);
            console.log("\n" + "=".repeat(60));
            console.log(`RESULTS: ${results.passed} passed, ${results.failed} failed`);
            console.log("=".repeat(60));
            return results;
        }
        
        window.runStylePresetTests = runStylePresetTests;

        // Process initial text on load
        window.addEventListener('DOMContentLoaded', async () => {
            // Load Vuizur stress dictionary from external JSON
            try {
                const response = await fetch('data/vuizur.json');
                STRESS_DICTIONARY = await response.json();
                console.log(`[MSR] Loaded ${Object.keys(STRESS_DICTIONARY).length} words from Vuizur dictionary`);
            } catch (e) {
                console.error('[MSR] Failed to load Vuizur dictionary:', e);
                console.warn('[MSR] Stress lookup will be limited to corrections and Wiktionary');
            }
            
            // Load user profile from localStorage
            loadUserProfile();
            applyUserProfileToMeta();
            
            // Load Wiktionary harvest from localStorage
            loadHarvest();
            
            // Attach hidden developer tool (triple-click version number)
            attachVersionClickHandlers();
            
            // Check for first launch and show onboarding if needed
            checkFirstLaunch();
            
            // Set up placeholder visibility listeners
            const textarea = document.getElementById('russianInput');
            if (textarea) {
                textarea.addEventListener('input', updatePlaceholderVisibility);
                textarea.addEventListener('focus', updatePlaceholderVisibility);
                textarea.addEventListener('blur', updatePlaceholderVisibility);
                updatePlaceholderVisibility(); // Initial check
            }
            
            processText();
        });
    </script>
    
    <!-- Golden-master tests (run in console: runGoldenTests()) -->
    <script src="tests/golden.js"></script>
    
    <!-- Exception dictionary audit (run in console: auditExceptions()) -->
    <script src="tests/audit-exceptions.js"></script>
    
    <!-- Remove redundant exceptions (run: removeRedundantExceptions(auditExceptions())) -->
    <script src="tests/remove-redundant.js"></script>
</body>
</html>
